{"version":3,"sources":["StyleSheet.js"],"names":["PixelRatio","require","ReactNativePropRegistry","ReactNativeStyleAttributes","StyleSheetValidation","flatten","hairlineWidth","roundToNearestPixel","get","absoluteFillObject","position","left","right","top","bottom","absoluteFill","register","module","exports","compose","style1","style2","setStyleAttributePreprocessor","property","process","value","console","error","__DEV__","warn","create","obj","result","key","validateStyle"],"mappings":"AAWA,a,gOAEA,GAAMA,YAAaC,OAAb,cAAN,CACA,GAAMC,yBAA0BD,OAA1B,2BAAN,CACA,GAAME,4BAA6BF,OAA7B,8BAAN,CACA,GAAMG,sBAAuBH,OAAvB,wBAAN,CAEA,GAAMI,SAAUJ,OAAV,gBAAN,CAgBA,GAAIK,eAAgBN,WAAWO,mBAAX,CAA+B,GAA/B,CAApB,CACA,GAAID,gBAAkB,CAAtB,CAAyB,CACvBA,cAAgB,EAAIN,WAAWQ,GAAX,EAApB,CACD,CAED,GAAMC,oBAAqB,CACzBC,SAAW,UADc,CAEzBC,KAAM,CAFmB,CAGzBC,MAAO,CAHkB,CAIzBC,IAAK,CAJoB,CAKzBC,OAAQ,CALiB,CAA3B,CAOA,GAAMC,cACJb,wBAAwBc,QAAxB,CAAiCP,kBAAjC,CADF,CA+CAQ,OAAOC,OAAP,CAAiB,CAoBfZ,2BApBe,CA2BfS,yBA3Be,CAyCfN,qCAzCe,CAiDfU,OAjDe,kBAiDPC,MAjDO,CAiDaC,MAjDb,CAiD6C,CAC1D,GAAID,QAAUC,MAAd,CAAsB,CACpB,MAAO,CAACD,MAAD,CAASC,MAAT,CAAP,CACD,CAFD,IAEO,CACL,MAAOD,SAAUC,MAAjB,CACD,CACF,CAvDc,CAgGfhB,eAhGe,CA2GfiB,6BA3Ge,wCA2GeC,QA3Gf,CA2GiCC,OA3GjC,CA2GsE,CACnF,GAAIC,aAAJ,CAEA,GAAI,MAAOtB,4BAA2BoB,QAA3B,CAAP,GAAgD,QAApD,CAA8D,CAC5DE,MAAQ,EAAR,CACD,CAFD,IAEO,IAAI,MAAOtB,4BAA2BoB,QAA3B,CAAP,GAAgD,QAApD,CAA8D,CACnEE,MAAQtB,2BAA2BoB,QAA3B,CAAR,CACD,CAFM,IAEA,CACLG,QAAQC,KAAR,CAAiBJ,QAAjB,oCACA,OACD,CAED,GAAIK,SAAW,MAAOH,OAAMD,OAAb,GAAyB,UAAxC,CAAoD,CAClDE,QAAQG,IAAR,gBAA4BN,QAA5B,kCACD,CAEDpB,2BAA2BoB,QAA3B,cAA4CE,KAA5C,EAAmDD,eAAnD,GACD,CA5Hc,CAiIfM,MAjIe,iBAiIGC,GAjIH,CAiI0B,CACvC,GAAMC,QAAS,EAAf,CACA,IAAK,GAAMC,IAAX,GAAkBF,IAAlB,CAAuB,CACrB3B,qBAAqB8B,aAArB,CAAmCD,GAAnC,CAAwCF,GAAxC,EACAC,OAAOC,GAAP,EAAcF,IAAIE,GAAJ,GAAY/B,wBAAwBc,QAAxB,CAAiCe,IAAIE,GAAJ,CAAjC,CAA1B,CACD,CACD,MAAOD,OAAP,CACD,CAxIc,CAAjB","file":"StyleSheet.js","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule StyleSheet\n * @flow\n */\n'use strict';\n\nconst PixelRatio = require('PixelRatio');\nconst ReactNativePropRegistry = require('ReactNativePropRegistry');\nconst ReactNativeStyleAttributes = require('ReactNativeStyleAttributes');\nconst StyleSheetValidation = require('StyleSheetValidation');\n\nconst flatten = require('flattenStyle');\n\nimport type {\n  StyleSheetStyle as _StyleSheetStyle,\n  Styles as _Styles,\n  StyleSheet as _StyleSheet,\n  StyleValue as _StyleValue,\n  StyleObj,\n} from 'StyleSheetTypes';\n\nexport type StyleProp = StyleObj;\nexport type Styles = _Styles;\nexport type StyleSheet<S> = _StyleSheet<S>;\nexport type StyleValue = _StyleValue;\nexport type StyleSheetStyle = _StyleSheetStyle;\n\nlet hairlineWidth = PixelRatio.roundToNearestPixel(0.4);\nif (hairlineWidth === 0) {\n  hairlineWidth = 1 / PixelRatio.get();\n}\n\nconst absoluteFillObject = {\n  position: ('absolute': 'absolute'),\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0,\n};\nconst absoluteFill: typeof absoluteFillObject =\n  ReactNativePropRegistry.register(absoluteFillObject); // This also freezes it\n\n/**\n * A StyleSheet is an abstraction similar to CSS StyleSheets\n *\n * Create a new StyleSheet:\n *\n * ```\n * const styles = StyleSheet.create({\n *   container: {\n *     borderRadius: 4,\n *     borderWidth: 0.5,\n *     borderColor: '#d6d7da',\n *   },\n *   title: {\n *     fontSize: 19,\n *     fontWeight: 'bold',\n *   },\n *   activeTitle: {\n *     color: 'red',\n *   },\n * });\n * ```\n *\n * Use a StyleSheet:\n *\n * ```\n * <View style={styles.container}>\n *   <Text style={[styles.title, this.props.isActive && styles.activeTitle]} />\n * </View>\n * ```\n *\n * Code quality:\n *\n *  - By moving styles away from the render function, you're making the code\n *  easier to understand.\n *  - Naming the styles is a good way to add meaning to the low level components\n *  in the render function.\n *\n * Performance:\n *\n *  - Making a stylesheet from a style object makes it possible to refer to it\n * by ID instead of creating a new style object every time.\n *  - It also allows to send the style only once through the bridge. All\n * subsequent uses are going to refer an id (not implemented yet).\n */\nmodule.exports = {\n  /**\n   * This is defined as the width of a thin line on the platform. It can be\n   * used as the thickness of a border or division between two elements.\n   * Example:\n   * ```\n   *   {\n   *     borderBottomColor: '#bbb',\n   *     borderBottomWidth: StyleSheet.hairlineWidth\n   *   }\n   * ```\n   *\n   * This constant will always be a round number of pixels (so a line defined\n   * by it look crisp) and will try to match the standard width of a thin line\n   * on the underlying platform. However, you should not rely on it being a\n   * constant size, because on different platforms and screen densities its\n   * value may be calculated differently.\n   *\n   * A line with hairline width may not be visible if your simulator is downscaled.\n   */\n  hairlineWidth,\n\n  /**\n   * A very common pattern is to create overlays with position absolute and zero positioning,\n   * so `absoluteFill` can be used for convenience and to reduce duplication of these repeated\n   * styles.\n   */\n  absoluteFill,\n\n  /**\n   * Sometimes you may want `absoluteFill` but with a couple tweaks - `absoluteFillObject` can be\n   * used to create a customized entry in a `StyleSheet`, e.g.:\n   *\n   *   const styles = StyleSheet.create({\n   *     wrapper: {\n   *       ...StyleSheet.absoluteFillObject,\n   *       top: 10,\n   *       backgroundColor: 'transparent',\n   *     },\n   *   });\n   */\n  absoluteFillObject,\n\n  /**\n   * Combines two styles such that `style2` will override any styles in `style1`.\n   * If either style is falsy, the other one is returned without allocating an\n   * array, saving allocations and maintaining reference equality for\n   * PureComponent checks.\n   */\n  compose(style1: ?StyleProp, style2: ?StyleProp): ?StyleProp {\n    if (style1 && style2) {\n      return [style1, style2];\n    } else {\n      return style1 || style2;\n    }\n  },\n\n  /**\n   * Flattens an array of style objects, into one aggregated style object.\n   * Alternatively, this method can be used to lookup IDs, returned by\n   * StyleSheet.register.\n   *\n   * > **NOTE**: Exercise caution as abusing this can tax you in terms of\n   * > optimizations.\n   * >\n   * > IDs enable optimizations through the bridge and memory in general. Refering\n   * > to style objects directly will deprive you of these optimizations.\n   *\n   * Example:\n   * ```\n   * const styles = StyleSheet.create({\n   *   listItem: {\n   *     flex: 1,\n   *     fontSize: 16,\n   *     color: 'white'\n   *   },\n   *   selectedListItem: {\n   *     color: 'green'\n   *   }\n   * });\n   *\n   * StyleSheet.flatten([styles.listItem, styles.selectedListItem])\n   * // returns { flex: 1, fontSize: 16, color: 'green' }\n   * ```\n   * Alternative use:\n   * ```\n   * StyleSheet.flatten(styles.listItem);\n   * // return { flex: 1, fontSize: 16, color: 'white' }\n   * // Simply styles.listItem would return its ID (number)\n   * ```\n   * This method internally uses `StyleSheetRegistry.getStyleByID(style)`\n   * to resolve style objects represented by IDs. Thus, an array of style\n   * objects (instances of StyleSheet.create), are individually resolved to,\n   * their respective objects, merged as one and then returned. This also explains\n   * the alternative use.\n   */\n  flatten,\n\n  /**\n   * WARNING: EXPERIMENTAL. Breaking changes will probably happen a lot and will\n   * not be reliably announced. The whole thing might be deleted, who knows? Use\n   * at your own risk.\n   *\n   * Sets a function to use to pre-process a style property value. This is used\n   * internally to process color and transform values. You should not use this\n   * unless you really know what you are doing and have exhausted other options.\n   */\n  setStyleAttributePreprocessor(property: string, process: (nextProp: mixed) => mixed) {\n    let value;\n\n    if (typeof ReactNativeStyleAttributes[property] === 'string') {\n      value = {};\n    } else if (typeof ReactNativeStyleAttributes[property] === 'object') {\n      value = ReactNativeStyleAttributes[property];\n    } else {\n      console.error(`${property} is not a valid style attribute`);\n      return;\n    }\n\n    if (__DEV__ && typeof value.process === 'function') {\n      console.warn(`Overwriting ${property} style attribute preprocessor`);\n    }\n\n    ReactNativeStyleAttributes[property] = { ...value, process };\n  },\n\n  /**\n   * Creates a StyleSheet style reference from the given object.\n   */\n  create<S: Styles>(obj: S): StyleSheet<S> {\n    const result = {};\n    for (const key in obj) {\n      StyleSheetValidation.validateStyle(key, obj);\n      result[key] = obj[key] && ReactNativePropRegistry.register(obj[key]);\n    }\n    return result;\n  },\n};\n"]}