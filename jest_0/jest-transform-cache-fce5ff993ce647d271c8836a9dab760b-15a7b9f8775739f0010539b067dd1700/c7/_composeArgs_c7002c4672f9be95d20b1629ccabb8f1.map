{"version":3,"sources":["_composeArgs.js"],"names":["nativeMax","Math","max","composeArgs","args","partials","holders","isCurried","argsIndex","argsLength","length","holdersLength","leftIndex","leftLength","rangeLength","result","Array","isUncurried","module","exports"],"mappings":"AACA,GAAIA,WAAYC,KAAKC,GAArB,CAaA,QAASC,YAAT,CAAqBC,IAArB,CAA2BC,QAA3B,CAAqCC,OAArC,CAA8CC,SAA9C,CAAyD,CACvD,GAAIC,WAAY,CAAC,CAAjB,CACIC,WAAaL,KAAKM,MADtB,CAEIC,cAAgBL,QAAQI,MAF5B,CAGIE,UAAY,CAAC,CAHjB,CAIIC,WAAaR,SAASK,MAJ1B,CAKII,YAAcd,UAAUS,WAAaE,aAAvB,CAAsC,CAAtC,CALlB,CAMII,OAASC,MAAMH,WAAaC,WAAnB,CANb,CAOIG,YAAc,CAACV,SAPnB,CASA,MAAO,EAAEK,SAAF,CAAcC,UAArB,CAAiC,CAC/BE,OAAOH,SAAP,EAAoBP,SAASO,SAAT,CAApB,CACD,CACD,MAAO,EAAEJ,SAAF,CAAcG,aAArB,CAAoC,CAClC,GAAIM,aAAeT,UAAYC,UAA/B,CAA2C,CACzCM,OAAOT,QAAQE,SAAR,CAAP,EAA6BJ,KAAKI,SAAL,CAA7B,CACD,CACF,CACD,MAAOM,aAAP,CAAsB,CACpBC,OAAOH,WAAP,EAAsBR,KAAKI,WAAL,CAAtB,CACD,CACD,MAAOO,OAAP,CACD,CAEDG,OAAOC,OAAP,CAAiBhB,WAAjB","file":"_composeArgs.js","sourcesContent":["/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates an array that is the composition of partially applied arguments,\n * placeholders, and provided arguments into a single array of arguments.\n *\n * @private\n * @param {Array} args The provided arguments.\n * @param {Array} partials The arguments to prepend to those provided.\n * @param {Array} holders The `partials` placeholder indexes.\n * @params {boolean} [isCurried] Specify composing for a curried function.\n * @returns {Array} Returns the new array of composed arguments.\n */\nfunction composeArgs(args, partials, holders, isCurried) {\n  var argsIndex = -1,\n      argsLength = args.length,\n      holdersLength = holders.length,\n      leftIndex = -1,\n      leftLength = partials.length,\n      rangeLength = nativeMax(argsLength - holdersLength, 0),\n      result = Array(leftLength + rangeLength),\n      isUncurried = !isCurried;\n\n  while (++leftIndex < leftLength) {\n    result[leftIndex] = partials[leftIndex];\n  }\n  while (++argsIndex < holdersLength) {\n    if (isUncurried || argsIndex < argsLength) {\n      result[holders[argsIndex]] = args[argsIndex];\n    }\n  }\n  while (rangeLength--) {\n    result[leftIndex++] = args[argsIndex++];\n  }\n  return result;\n}\n\nmodule.exports = composeArgs;\n"]}