{"version":3,"sources":["selectors.js"],"names":["Object","defineProperty","exports","value","_typeof","Symbol","iterator","obj","constructor","prototype","buildPredicate","reduceTreeBySelector","reduceTreesBySelector","_rstSelectorParser","require","_object","_object2","_interopRequireDefault","_isEmpty","_isEmpty2","_flatten","_flatten2","_uniq","_uniq2","_objectIs","_objectIs2","_has","_has2","_RSTTraversal","_Utils","__esModule","parser","createParser","CHILD","ADJACENT_SIBLING","GENERAL_SIBLING","DESCENDANT","SELECTOR","TYPE_SELECTOR","CLASS_SELECTOR","ID_SELECTOR","ATTRIBUTE_PRESENCE","ATTRIBUTE_VALUE","PSEUDO_CLASS","PSEUDO_ELEMENT","EXACT_ATTRIBUTE_OPERATOR","WHITELIST_ATTRIBUTE_OPERATOR","HYPHENATED_ATTRIBUTE_OPERATOR","PREFIX_ATTRIBUTE_OPERATOR","SUFFIX_ATTRIBUTE_OPERATOR","SUBSTRING_ATTRIBUTE_OPERATOR","uniqueReduce","fn","nodes","reduce","safelyGenerateTokens","selector","parse","err","Error","String","matchAttributeSelector","node","token","operator","name","nodeProps","propsOfNode","descriptor","getOwnPropertyDescriptor","get","nodePropValue","type","split","indexOf","startsWith","slice","length","nodeMatchesToken","hasClassName","nodeHasType","nodeHasId","buildPredicateFromToken","body","every","bodyToken","isComplexSelector","tokens","some","Array","isArray","hasUndefinedValues","TypeError","nodeMatchesObjectProps","matchAdjacentSiblings","predicate","root","matches","parent","findParentNode","nodeIndex","rendered","adjacentSibling","push","matchGeneralSibling","forEach","sibling","i","matchDirectChild","children","childrenOfNode","child","matchDescendant","concat","treeFilter","results","index","_token","_predicate","roots","map","n"],"mappings":"AAAAA,OAAOC,cAAP,CAAsBC,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CC,MAAO,IADoC,CAA7C,EAIA,GAAIC,SAAU,MAAOC,OAAP,GAAkB,UAAlB,EAAgC,kCAAOA,OAAOC,QAAd,iBAA2B,QAA3D,CAAsE,SAAUC,GAAV,CAAe,CAAE,MAAO,OAAOA,IAAd,CAAoB,CAA3G,CAA8G,SAAUA,GAAV,CAAe,CAAE,MAAOA,MAAO,MAAOF,OAAP,GAAkB,UAAzB,EAAuCE,IAAIC,WAAJ,GAAoBH,MAA3D,EAAqEE,kCAAQF,OAAOI,SAAf,eAArE,CAAgG,QAAhG,CAA2G,MAAOF,IAAzH,CAA+H,CAA5Q,CAEAL,QAAQQ,cAAR,CAAyBA,cAAzB,CACAR,QAAQS,oBAAR,CAA+BA,oBAA/B,CACAT,QAAQU,qBAAR,CAAgCA,qBAAhC,CAEA,GAAIC,oBAAqBC,OAArB,uBAAJ,CAEA,GAAIC,SAAUD,OAAV,iBAAJ,CAEA,GAAIE,UAAWC,uBAAuBF,OAAvB,CAAf,CAEA,GAAIG,UAAWJ,OAAX,kBAAJ,CAEA,GAAIK,WAAYF,uBAAuBC,QAAvB,CAAhB,CAEA,GAAIE,UAAWN,OAAX,kBAAJ,CAEA,GAAIO,WAAYJ,uBAAuBG,QAAvB,CAAhB,CAEA,GAAIE,OAAQR,OAAR,eAAJ,CAEA,GAAIS,QAASN,uBAAuBK,KAAvB,CAAb,CAEA,GAAIE,WAAYV,OAAZ,aAAJ,CAEA,GAAIW,YAAaR,uBAAuBO,SAAvB,CAAjB,CAEA,GAAIE,MAAOZ,OAAP,OAAJ,CAEA,GAAIa,OAAQV,uBAAuBS,IAAvB,CAAZ,CAEA,GAAIE,eAAgBd,QAAQ,gBAAR,CAApB,CAEA,GAAIe,QAASf,QAAQ,SAAR,CAAb,CAEA,QAASG,uBAAT,CAAgCV,GAAhC,CAAqC,CAAE,MAAOA,MAAOA,IAAIuB,UAAX,CAAwBvB,GAAxB,CAA8B,CAAE,UAAWA,GAAb,CAArC,CAA0D,CAGjG,GAAIwB,QAAS,CAAC,EAAGlB,mBAAmBmB,YAAvB,GAAb,CAGA,GAAIC,OAAQ,iBAAZ,CACA,GAAIC,kBAAmB,2BAAvB,CACA,GAAIC,iBAAkB,0BAAtB,CACA,GAAIC,YAAa,sBAAjB,CAGA,GAAIC,UAAW,UAAf,CACA,GAAIC,eAAgB,cAApB,CACA,GAAIC,gBAAiB,eAArB,CACA,GAAIC,aAAc,YAAlB,CACA,GAAIC,oBAAqB,2BAAzB,CACA,GAAIC,iBAAkB,wBAAtB,CAEA,GAAIC,cAAe,qBAAnB,CACA,GAAIC,gBAAiB,uBAArB,CAEA,GAAIC,0BAA2B,GAA/B,CACA,GAAIC,8BAA+B,IAAnC,CACA,GAAIC,+BAAgC,IAApC,CACA,GAAIC,2BAA4B,IAAhC,CACA,GAAIC,2BAA4B,IAAhC,CACA,GAAIC,8BAA+B,IAAnC,CAQA,QAASC,aAAT,CAAsBC,EAAtB,CAA0BC,KAA1B,CAAiC,CAC/B,MAAO,CAAC,EAAG9B,OAAO,SAAP,CAAJ,EAAuB8B,MAAMC,MAAN,CAAaF,EAAb,CAAiB,EAAjB,CAAvB,CAAP,CACD,CAOD,QAASG,qBAAT,CAA8BC,QAA9B,CAAwC,CACtC,GAAI,CACF,MAAOzB,QAAO0B,KAAP,CAAaD,QAAb,CAAP,CACD,CAAC,MAAOE,GAAP,CAAY,CACZ,KAAM,IAAIC,MAAJ,CAAU,6BAA+BC,OAAOJ,QAAP,CAAzC,CAAN,CACD,CACF,CAED,QAASK,uBAAT,CAAgCC,IAAhC,CAAsCC,KAAtC,CAA6C,CAC3C,GAAIC,UAAWD,MAAMC,QAArB,CACI7D,MAAQ4D,MAAM5D,KADlB,CAEI8D,KAAOF,MAAME,IAFjB,CAIA,GAAIC,WAAY,CAAC,EAAGrC,OAAOsC,WAAX,EAAwBL,IAAxB,CAAhB,CACA,GAAIM,YAAapE,OAAOqE,wBAAP,CAAgCH,SAAhC,CAA2CD,IAA3C,CAAjB,CACA,GAAIG,YAAcA,WAAWE,GAA7B,CAAkC,CAChC,MAAO,MAAP,CACD,CACD,GAAIC,eAAgBL,UAAUD,IAAV,CAApB,CACA,GAAI,MAAOM,cAAP,GAAyB,WAA7B,CAA0C,CACxC,MAAO,MAAP,CACD,CACD,GAAIR,MAAMS,IAAN,GAAe/B,kBAAnB,CAAuC,CACrC,MAAO,CAAC,EAAGd,MAAM,SAAN,CAAJ,EAAsBuC,SAAtB,CAAiCH,MAAME,IAAvC,CAAP,CACD,CAED,GAAI,MAAOM,cAAP,GAAyB,QAAzB,EAAqC,MAAOpE,MAAP,GAAiB,QAA1D,CAAoE,CAClE,GAAI6D,WAAanB,wBAAjB,CAA2C,CACzC,MAAO,MAAP,CACD,CACF,CACD,OAAQmB,QAAR,EAME,IAAKnB,yBAAL,CACE,MAAO,CAAC,EAAGpB,WAAW,SAAX,CAAJ,EAA2B8C,aAA3B,CAA0CpE,KAA1C,CAAP,CAOF,IAAK2C,6BAAL,CACE,MAAOyB,eAAcE,KAAd,CAAoB,GAApB,EAAyBC,OAAzB,CAAiCvE,KAAjC,IAA4C,CAAC,CAApD,CAOF,IAAK4C,8BAAL,CACE,MAAOwB,iBAAkBpE,KAAlB,EAA2BoE,cAAcI,UAAd,CAAyBf,OAAOzD,KAAP,EAAgB,GAAzC,CAAlC,CAOF,IAAK6C,0BAAL,CACE,MAAO7C,SAAU,EAAV,CAAe,KAAf,CAAuBoE,cAAcK,KAAd,CAAoB,CAApB,CAAuBzE,MAAM0E,MAA7B,IAAyC1E,KAAvE,CAOF,IAAK8C,0BAAL,CACE,MAAO9C,SAAU,EAAV,CAAe,KAAf,CAAuBoE,cAAcK,KAAd,CAAoB,CAACzE,MAAM0E,MAA3B,IAAuC1E,KAArE,CAQF,IAAK+C,6BAAL,CACE,MAAO/C,SAAU,EAAV,CAAe,KAAf,CAAuBoE,cAAcG,OAAd,CAAsBvE,KAAtB,IAAiC,CAAC,CAAhE,CACF,QACE,KAAM,IAAIwD,MAAJ,CAAU,0DAA4DC,OAAOI,QAAP,CAA5D,CAA+E,GAAzF,CAAN,CAlDJ,CAoDD,CAQD,QAASc,iBAAT,CAA0BhB,IAA1B,CAAgCC,KAAhC,CAAuC,CACrC,GAAID,OAAS,IAAT,EAAiB,MAAOA,KAAP,GAAgB,QAArC,CAA+C,CAC7C,MAAO,MAAP,CACD,CACD,OAAQC,MAAMS,IAAd,EAKE,IAAKjC,eAAL,CACE,MAAO,CAAC,EAAGX,cAAcmD,YAAlB,EAAgCjB,IAAhC,CAAsCC,MAAME,IAA5C,CAAP,CAKF,IAAK3B,cAAL,CACE,MAAO,CAAC,EAAGT,OAAOmD,WAAX,EAAwBlB,IAAxB,CAA8BC,MAAME,IAApC,CAAP,CAKF,IAAKzB,YAAL,CACE,MAAO,CAAC,EAAGZ,cAAcqD,SAAlB,EAA6BnB,IAA7B,CAAmCC,MAAME,IAAzC,CAAP,CAMF,IAAKxB,mBAAL,CACE,MAAOoB,wBAAuBC,IAAvB,CAA6BC,KAA7B,CAAP,CAMF,IAAKrB,gBAAL,CACE,MAAOmB,wBAAuBC,IAAvB,CAA6BC,KAA7B,CAAP,CACF,IAAKnB,eAAL,CACA,IAAKD,aAAL,CACE,KAAM,IAAIgB,MAAJ,CAAU,6EAAV,CAAN,CACF,QACE,KAAM,IAAIA,MAAJ,CAAU,uBAAyBC,OAAOG,MAAMS,IAAb,CAAnC,CAAN,CArCJ,CAuCD,CAQD,QAASU,wBAAT,CAAiCnB,KAAjC,CAAwC,CACtC,MAAO,UAAUD,IAAV,CAAgB,CACrB,MAAOC,OAAMoB,IAAN,CAAWC,KAAX,CAAiB,SAAUC,SAAV,CAAqB,CAC3C,MAAOP,kBAAiBhB,IAAjB,CAAuBuB,SAAvB,CAAP,CACD,CAFM,CAAP,CAGD,CAJD,CAKD,CAOD,QAASC,kBAAT,CAA2BC,MAA3B,CAAmC,CACjC,MAAOA,QAAOC,IAAP,CAAY,SAAUzB,KAAV,CAAiB,CAClC,MAAOA,OAAMS,IAAN,GAAenC,QAAtB,CACD,CAFM,CAAP,CAGD,CAQD,QAAS3B,eAAT,CAAwB8C,QAAxB,CAAkC,CAEhC,GAAI,MAAOA,SAAP,GAAoB,UAAxB,CAAoC,CAClC,MAAO,UAAUM,IAAV,CAAgB,CACrB,MAAOA,OAAQA,KAAKU,IAAL,GAAchB,QAA7B,CACD,CAFD,CAGD,CAED,GAAI,CAAC,MAAOA,SAAP,GAAoB,WAApB,CAAkC,WAAlC,CAAgDpD,QAAQoD,QAAR,CAAjD,IAAwE,QAA5E,CAAsF,CACpF,GAAI,CAACiC,MAAMC,OAAN,CAAclC,QAAd,CAAD,EAA4BA,WAAa,IAAzC,EAAiD,CAAC,CAAC,EAAGrC,UAAU,SAAV,CAAJ,EAA0BqC,QAA1B,CAAtD,CAA2F,CACzF,GAAImC,oBAAqB,CAAC,EAAG3E,SAAS,SAAT,CAAJ,EAAyBwC,QAAzB,EAAmCgC,IAAnC,CAAwC,SAAUrF,KAAV,CAAiB,CAChF,MAAO,OAAOA,MAAP,GAAiB,WAAxB,CACD,CAFwB,CAAzB,CAGA,GAAIwF,kBAAJ,CAAwB,CACtB,KAAM,IAAIC,UAAJ,CAAc,+EAAd,CAAN,CACD,CACD,MAAO,UAAU9B,IAAV,CAAgB,CACrB,MAAO,CAAC,EAAGlC,cAAciE,sBAAlB,EAA0C/B,IAA1C,CAAgDN,QAAhD,CAAP,CACD,CAFD,CAGD,CACD,KAAM,IAAIoC,UAAJ,CAAc,iFAAd,CAAN,CACD,CAED,GAAI,MAAOpC,SAAP,GAAoB,QAAxB,CAAkC,CAChC,GAAI+B,QAAShC,qBAAqBC,QAArB,CAAb,CACA,GAAI8B,kBAAkBC,MAAlB,CAAJ,CAA+B,CAC7B,KAAM,IAAIK,UAAJ,CAAc,oDAAd,CAAN,CACD,CAED,MAAOV,yBAAwBK,OAAO,CAAP,CAAxB,CAAP,CACD,CACD,KAAM,IAAIK,UAAJ,CAAc,qEAAd,CAAN,CACD,CASD,QAASE,sBAAT,CAA+BzC,KAA/B,CAAsC0C,SAAtC,CAAiDC,IAAjD,CAAuD,CACrD,MAAO3C,OAAMC,MAAN,CAAa,SAAU2C,OAAV,CAAmBnC,IAAnB,CAAyB,CAC3C,GAAIoC,QAAS,CAAC,EAAGtE,cAAcuE,cAAlB,EAAkCH,IAAlC,CAAwClC,IAAxC,CAAb,CAEA,GAAI,CAACoC,MAAL,CAAa,CACX,MAAOD,QAAP,CACD,CACD,GAAIG,WAAYF,OAAOG,QAAP,CAAgB3B,OAAhB,CAAwBZ,IAAxB,CAAhB,CACA,GAAIwC,iBAAkBJ,OAAOG,QAAP,CAAgBD,UAAY,CAA5B,CAAtB,CAEA,GAAI,CAACE,eAAL,CAAsB,CACpB,MAAOL,QAAP,CACD,CACD,GAAIF,UAAUO,eAAV,CAAJ,CAAgC,CAC9BL,QAAQM,IAAR,CAAaD,eAAb,EACD,CACD,MAAOL,QAAP,CACD,CAhBM,CAgBJ,EAhBI,CAAP,CAiBD,CASD,QAASO,oBAAT,CAA6BnD,KAA7B,CAAoC0C,SAApC,CAA+CC,IAA/C,CAAqD,CACnD,MAAO7C,cAAa,SAAU8C,OAAV,CAAmBnC,IAAnB,CAAyB,CAC3C,GAAIoC,QAAS,CAAC,EAAGtE,cAAcuE,cAAlB,EAAkCH,IAAlC,CAAwClC,IAAxC,CAAb,CACA,GAAIsC,WAAYF,OAAOG,QAAP,CAAgB3B,OAAhB,CAAwBZ,IAAxB,CAAhB,CACAoC,OAAOG,QAAP,CAAgBI,OAAhB,CAAwB,SAAUC,OAAV,CAAmBC,CAAnB,CAAsB,CAC5C,GAAIA,EAAIP,SAAJ,EAAiBL,UAAUW,OAAV,CAArB,CAAyC,CACvCT,QAAQM,IAAR,CAAaG,OAAb,EACD,CACF,CAJD,EAKA,MAAOT,QAAP,CACD,CATM,CASJ5C,KATI,CAAP,CAUD,CAQD,QAASuD,iBAAT,CAA0BvD,KAA1B,CAAiC0C,SAAjC,CAA4C,CAC1C,MAAO5C,cAAa,SAAU8C,OAAV,CAAmBnC,IAAnB,CAAyB,CAC3C,GAAI+C,UAAW,CAAC,EAAGjF,cAAckF,cAAlB,EAAkChD,IAAlC,CAAf,CACA+C,SAASJ,OAAT,CAAiB,SAAUM,KAAV,CAAiB,CAChC,GAAIhB,UAAUgB,KAAV,CAAJ,CAAsB,CACpBd,QAAQM,IAAR,CAAaQ,KAAb,EACD,CACF,CAJD,EAKA,MAAOd,QAAP,CACD,CARM,CAQJ5C,KARI,CAAP,CASD,CAQD,QAAS2D,gBAAT,CAAyB3D,KAAzB,CAAgC0C,SAAhC,CAA2C,CACzC,MAAO5C,cAAa,SAAU8C,OAAV,CAAmBnC,IAAnB,CAAyB,CAC3C,MAAOmC,SAAQgB,MAAR,CAAe,CAAC,EAAGrF,cAAcsF,UAAlB,EAA8BpD,IAA9B,CAAoCiC,SAApC,CAAf,CAAP,CACD,CAFM,CAEJ1C,KAFI,CAAP,CAGD,CAUD,QAAS1C,qBAAT,CAA8B6C,QAA9B,CAAwCwC,IAAxC,CAA8C,CAC5C,GAAImB,SAAU,EAAd,CAEA,GAAI,MAAO3D,SAAP,GAAoB,UAApB,EAAkC,CAAC,MAAOA,SAAP,GAAoB,WAApB,CAAkC,WAAlC,CAAgDpD,QAAQoD,QAAR,CAAjD,IAAwE,QAA9G,CAAwH,CACtH2D,QAAU,CAAC,EAAGvF,cAAcsF,UAAlB,EAA8BlB,IAA9B,CAAoCtF,eAAe8C,QAAf,CAApC,CAAV,CACD,CAFD,IAEO,IAAI,MAAOA,SAAP,GAAoB,QAAxB,CAAkC,CACvC,GAAI+B,QAAShC,qBAAqBC,QAArB,CAAb,CACA,GAAI4D,OAAQ,CAAZ,CACA,GAAIrD,OAAQ,IAAZ,CACA,MAAOqD,MAAQ7B,OAAOV,MAAtB,CAA8B,CAC5Bd,MAAQwB,OAAO6B,KAAP,CAAR,CAeA,GAAIrD,MAAMS,IAAN,GAAenC,QAAnB,CAA6B,CAC3B,GAAI0D,WAAYb,wBAAwBnB,KAAxB,CAAhB,CACAoD,QAAUA,QAAQF,MAAR,CAAe,CAAC,EAAGrF,cAAcsF,UAAlB,EAA8BlB,IAA9B,CAAoCD,SAApC,CAAf,CAAV,CACD,CAHD,IAGO,CAGL,GAAIsB,QAAStD,KAAb,CACIS,KAAO6C,OAAO7C,IADlB,CAKA4C,OAAS,CAAT,CACArD,MAAQwB,OAAO6B,KAAP,CAAR,CACA,GAAIE,YAAapC,wBAAwBnB,KAAxB,CAAjB,CAGA,OAAQS,IAAR,EAEE,IAAKtC,iBAAL,CACEiF,QAAUrB,sBAAsBqB,OAAtB,CAA+BG,UAA/B,CAA2CtB,IAA3C,CAAV,CACA,MAEF,IAAK7D,gBAAL,CACEgF,QAAUX,oBAAoBW,OAApB,CAA6BG,UAA7B,CAAyCtB,IAAzC,CAAV,CACA,MAEF,IAAK/D,MAAL,CACEkF,QAAUP,iBAAiBO,OAAjB,CAA0BG,UAA1B,CAAV,CACA,MAEF,IAAKlF,WAAL,CACE,CACE+E,QAAUH,gBAAgBG,OAAhB,CAAyBG,UAAzB,CAAV,CACA,MACD,CACH,QACE,KAAM,IAAI3D,MAAJ,CAAU,+BAAiCC,OAAOY,IAAP,CAA3C,CAAN,CApBJ,CAsBD,CACD4C,OAAS,CAAT,CACD,CACF,CA7DM,IA6DA,CACL,KAAM,IAAIxB,UAAJ,CAAc,qEAAd,CAAN,CACD,CACD,MAAOuB,QAAP,CACD,CAED,QAASvG,sBAAT,CAA+B4C,QAA/B,CAAyC+D,KAAzC,CAAgD,CAC9C,GAAIJ,SAAUI,MAAMC,GAAN,CAAU,SAAUC,CAAV,CAAa,CACnC,MAAO9G,sBAAqB6C,QAArB,CAA+BiE,CAA/B,CAAP,CACD,CAFa,CAAd,CAGA,MAAO,CAAC,EAAGlG,OAAO,SAAP,CAAJ,EAAuB,CAAC,EAAGF,UAAU,SAAV,CAAJ,EAA0B8F,OAA1B,CAAvB,CAAP,CACD","file":"selectors.js","sourcesContent":["Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.buildPredicate = buildPredicate;\nexports.reduceTreeBySelector = reduceTreeBySelector;\nexports.reduceTreesBySelector = reduceTreesBySelector;\n\nvar _rstSelectorParser = require('rst-selector-parser');\n\nvar _object = require('object.values');\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _isEmpty = require('lodash/isEmpty');\n\nvar _isEmpty2 = _interopRequireDefault(_isEmpty);\n\nvar _flatten = require('lodash/flatten');\n\nvar _flatten2 = _interopRequireDefault(_flatten);\n\nvar _uniq = require('lodash/uniq');\n\nvar _uniq2 = _interopRequireDefault(_uniq);\n\nvar _objectIs = require('object-is');\n\nvar _objectIs2 = _interopRequireDefault(_objectIs);\n\nvar _has = require('has');\n\nvar _has2 = _interopRequireDefault(_has);\n\nvar _RSTTraversal = require('./RSTTraversal');\n\nvar _Utils = require('./Utils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n// our CSS selector parser instance\nvar parser = (0, _rstSelectorParser.createParser)();\n\n// Combinators that allow you to chance selectors\nvar CHILD = 'childCombinator';\nvar ADJACENT_SIBLING = 'adjacentSiblingCombinator';\nvar GENERAL_SIBLING = 'generalSiblingCombinator';\nvar DESCENDANT = 'descendantCombinator';\n\n// Selectors for targeting elements\nvar SELECTOR = 'selector';\nvar TYPE_SELECTOR = 'typeSelector';\nvar CLASS_SELECTOR = 'classSelector';\nvar ID_SELECTOR = 'idSelector';\nvar ATTRIBUTE_PRESENCE = 'attributePresenceSelector';\nvar ATTRIBUTE_VALUE = 'attributeValueSelector';\n// @TODO we dont support these, throw if they are used\nvar PSEUDO_CLASS = 'pseudoClassSelector';\nvar PSEUDO_ELEMENT = 'pseudoElementSelector';\n\nvar EXACT_ATTRIBUTE_OPERATOR = '=';\nvar WHITELIST_ATTRIBUTE_OPERATOR = '~=';\nvar HYPHENATED_ATTRIBUTE_OPERATOR = '|=';\nvar PREFIX_ATTRIBUTE_OPERATOR = '^=';\nvar SUFFIX_ATTRIBUTE_OPERATOR = '$=';\nvar SUBSTRING_ATTRIBUTE_OPERATOR = '*=';\n\n/**\n * Calls reduce on a array of nodes with the passed\n * function, returning only unique results.\n * @param {Function} fn\n * @param {Array<Node>} nodes\n */\nfunction uniqueReduce(fn, nodes) {\n  return (0, _uniq2['default'])(nodes.reduce(fn, []));\n}\n\n/**\n * Takes a CSS selector and returns a set of tokens parsed\n * by scalpel.\n * @param {String} selector\n */\nfunction safelyGenerateTokens(selector) {\n  try {\n    return parser.parse(selector);\n  } catch (err) {\n    throw new Error('Failed to parse selector: ' + String(selector));\n  }\n}\n\nfunction matchAttributeSelector(node, token) {\n  var operator = token.operator,\n      value = token.value,\n      name = token.name;\n\n  var nodeProps = (0, _Utils.propsOfNode)(node);\n  var descriptor = Object.getOwnPropertyDescriptor(nodeProps, name);\n  if (descriptor && descriptor.get) {\n    return false;\n  }\n  var nodePropValue = nodeProps[name];\n  if (typeof nodePropValue === 'undefined') {\n    return false;\n  }\n  if (token.type === ATTRIBUTE_PRESENCE) {\n    return (0, _has2['default'])(nodeProps, token.name);\n  }\n  // Only the exact value operator (\"=\") can match non-strings\n  if (typeof nodePropValue !== 'string' || typeof value !== 'string') {\n    if (operator !== EXACT_ATTRIBUTE_OPERATOR) {\n      return false;\n    }\n  }\n  switch (operator) {\n    /**\n     * Represents an element with the att attribute whose value is exactly \"val\".\n     * @example\n     * [attr=\"val\"] matches attr=\"val\"\n     */\n    case EXACT_ATTRIBUTE_OPERATOR:\n      return (0, _objectIs2['default'])(nodePropValue, value);\n    /**\n     * Represents an element with the att attribute whose value is a whitespace-separated\n     * list of words, one of which is exactly\n     * @example\n     *  [rel~=\"copyright\"] matches rel=\"copyright other\"\n     */\n    case WHITELIST_ATTRIBUTE_OPERATOR:\n      return nodePropValue.split(' ').indexOf(value) !== -1;\n    /**\n     * Represents an element with the att attribute, its value either being exactly the\n     * value or beginning with the value immediately followed by \"-\"\n     * @example\n     * [hreflang|=\"en\"] matches hreflang=\"en-US\"\n     */\n    case HYPHENATED_ATTRIBUTE_OPERATOR:\n      return nodePropValue === value || nodePropValue.startsWith(String(value) + '-');\n    /**\n     * Represents an element with the att attribute whose value begins with the prefix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type^=\"image\"] matches type=\"imageobject\"\n     */\n    case PREFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(0, value.length) === value;\n    /**\n     * Represents an element with the att attribute whose value ends with the suffix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type$=\"image\"] matches type=\"imageobject\"\n     */\n    case SUFFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(-value.length) === value;\n    /**\n     * Represents an element with the att attribute whose value contains at least one\n     * instance of the value. If value is the empty string then the\n     * selector does not represent anything.\n     * @example\n     * [title*=\"hello\"] matches title=\"well hello there\"\n     */\n    case SUBSTRING_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.indexOf(value) !== -1;\n    default:\n      throw new Error('Enzyme::Selector: Unknown attribute selector operator \"' + String(operator) + '\"');\n  }\n}\n\n/**\n * Takes a node and a token and determines if the node\n * matches the predicate defined by the token.\n * @param {Node} node\n * @param {Token} token\n */\nfunction nodeMatchesToken(node, token) {\n  if (node === null || typeof node === 'string') {\n    return false;\n  }\n  switch (token.type) {\n    /**\n     * Match against the className prop\n     * @example '.active' matches <div className='active' />\n     */\n    case CLASS_SELECTOR:\n      return (0, _RSTTraversal.hasClassName)(node, token.name);\n    /**\n     * Simple type matching\n     * @example 'div' matches <div />\n     */\n    case TYPE_SELECTOR:\n      return (0, _Utils.nodeHasType)(node, token.name);\n    /**\n     * Match against the `id` prop\n     * @example '#nav' matches <ul id=\"nav\" />\n     */\n    case ID_SELECTOR:\n      return (0, _RSTTraversal.nodeHasId)(node, token.name);\n    /**\n     * Matches if an attribute is present, regardless\n     * of its value\n     * @example '[disabled]' matches <a disabled />\n     */\n    case ATTRIBUTE_PRESENCE:\n      return matchAttributeSelector(node, token);\n    /**\n     * Matches if an attribute is present with the\n     * provided value\n     * @example '[data-foo=foo]' matches <div data-foo=\"foo\" />\n     */\n    case ATTRIBUTE_VALUE:\n      return matchAttributeSelector(node, token);\n    case PSEUDO_ELEMENT:\n    case PSEUDO_CLASS:\n      throw new Error('Enzyme::Selector does not support pseudo-element or pseudo-class selectors.');\n    default:\n      throw new Error('Unknown token type: ' + String(token.type));\n  }\n}\n\n/**\n * Returns a predicate function that checks if a\n * node matches every token in the body of a selector\n * token.\n * @param {Token} token\n */\nfunction buildPredicateFromToken(token) {\n  return function (node) {\n    return token.body.every(function (bodyToken) {\n      return nodeMatchesToken(node, bodyToken);\n    });\n  };\n}\n\n/**\n * Returns whether a parsed selector is a complex selector, which\n * is defined as a selector that contains combinators.\n * @param {Array<Token>} tokens\n */\nfunction isComplexSelector(tokens) {\n  return tokens.some(function (token) {\n    return token.type !== SELECTOR;\n  });\n}\n\n/**\n * Takes a component constructor, object, or string representing\n * a simple selector and returns a predicate function that can\n * be applied to a single node.\n * @param {Function|Object|String} selector\n */\nfunction buildPredicate(selector) {\n  // If the selector is a function, check if the node's constructor matches\n  if (typeof selector === 'function') {\n    return function (node) {\n      return node && node.type === selector;\n    };\n  }\n  // If the selector is an non-empty object, treat the keys/values as props\n  if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {\n    if (!Array.isArray(selector) && selector !== null && !(0, _isEmpty2['default'])(selector)) {\n      var hasUndefinedValues = (0, _object2['default'])(selector).some(function (value) {\n        return typeof value === 'undefined';\n      });\n      if (hasUndefinedValues) {\n        throw new TypeError('Enzyme::Props can’t have `undefined` values. Try using ‘findWhere()’ instead.');\n      }\n      return function (node) {\n        return (0, _RSTTraversal.nodeMatchesObjectProps)(node, selector);\n      };\n    }\n    throw new TypeError('Enzyme::Selector does not support an array, null, or empty object as a selector');\n  }\n  // If the selector is a string, parse it as a simple CSS selector\n  if (typeof selector === 'string') {\n    var tokens = safelyGenerateTokens(selector);\n    if (isComplexSelector(tokens)) {\n      throw new TypeError('This method does not support complex CSS selectors');\n    }\n    // Simple selectors only have a single selector token\n    return buildPredicateFromToken(tokens[0]);\n  }\n  throw new TypeError('Enzyme::Selector expects a string, object, or Component Constructor');\n}\n\n/**\n * Matches only nodes which are adjacent siblings (direct next sibling)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\nfunction matchAdjacentSiblings(nodes, predicate, root) {\n  return nodes.reduce(function (matches, node) {\n    var parent = (0, _RSTTraversal.findParentNode)(root, node);\n    // If there's no parent, there's no siblings\n    if (!parent) {\n      return matches;\n    }\n    var nodeIndex = parent.rendered.indexOf(node);\n    var adjacentSibling = parent.rendered[nodeIndex + 1];\n    // No sibling\n    if (!adjacentSibling) {\n      return matches;\n    }\n    if (predicate(adjacentSibling)) {\n      matches.push(adjacentSibling);\n    }\n    return matches;\n  }, []);\n}\n\n/**\n * Matches only nodes which are general siblings (any sibling *after*)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\nfunction matchGeneralSibling(nodes, predicate, root) {\n  return uniqueReduce(function (matches, node) {\n    var parent = (0, _RSTTraversal.findParentNode)(root, node);\n    var nodeIndex = parent.rendered.indexOf(node);\n    parent.rendered.forEach(function (sibling, i) {\n      if (i > nodeIndex && predicate(sibling)) {\n        matches.push(sibling);\n      }\n    });\n    return matches;\n  }, nodes);\n}\n\n/**\n * Matches only nodes which are direct children (not grandchildren, etc.)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\nfunction matchDirectChild(nodes, predicate) {\n  return uniqueReduce(function (matches, node) {\n    var children = (0, _RSTTraversal.childrenOfNode)(node);\n    children.forEach(function (child) {\n      if (predicate(child)) {\n        matches.push(child);\n      }\n    });\n    return matches;\n  }, nodes);\n}\n\n/**\n * Matches all descendant nodes against a predicate,\n * returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\nfunction matchDescendant(nodes, predicate) {\n  return uniqueReduce(function (matches, node) {\n    return matches.concat((0, _RSTTraversal.treeFilter)(node, predicate));\n  }, nodes);\n}\n\n/**\n * Takes an RST and reduces it to a set of nodes matching\n * the selector. The selector can be a simple selector, which\n * is handled by `buildPredicate`, or a complex CSS selector which\n * reduceTreeBySelector parses and reduces the tree based on the combinators.\n * @param {Function|Object|String} selector\n * @param {RSTNode} wrapper\n */\nfunction reduceTreeBySelector(selector, root) {\n  var results = [];\n\n  if (typeof selector === 'function' || (typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {\n    results = (0, _RSTTraversal.treeFilter)(root, buildPredicate(selector));\n  } else if (typeof selector === 'string') {\n    var tokens = safelyGenerateTokens(selector);\n    var index = 0;\n    var token = null;\n    while (index < tokens.length) {\n      token = tokens[index];\n      /**\n       * There are two types of tokens in a CSS selector:\n       *\n       * 1. Selector tokens. These target nodes directly, like\n       *    type or attribute selectors. These are easy to apply\n       *    because we can travserse the tree and return only\n       *    the nodes that match the predicate.\n       *\n       * 2. Combinator tokens. These tokens chain together\n       *    selector nodes. For example > for children, or +\n       *    for adjecent siblings. These are harder to match\n       *    as we have to track where in the tree we are\n       *    to determine if a selector node applies or not.\n       */\n      if (token.type === SELECTOR) {\n        var predicate = buildPredicateFromToken(token);\n        results = results.concat((0, _RSTTraversal.treeFilter)(root, predicate));\n      } else {\n        // We can assume there always all previously matched tokens since selectors\n        // cannot start with combinators.\n        var _token = token,\n            type = _token.type;\n        // We assume the next token is a selector, so move the index\n        // forward and build the predicate.\n\n        index += 1;\n        token = tokens[index];\n        var _predicate = buildPredicateFromToken(token);\n        // We match against only the nodes which have already been matched,\n        // since a combinator is meant to refine a previous selector.\n        switch (type) {\n          // The + combinator\n          case ADJACENT_SIBLING:\n            results = matchAdjacentSiblings(results, _predicate, root);\n            break;\n          // The ~ combinator\n          case GENERAL_SIBLING:\n            results = matchGeneralSibling(results, _predicate, root);\n            break;\n          // The > combinator\n          case CHILD:\n            results = matchDirectChild(results, _predicate);\n            break;\n          // The ' ' (whitespace) combinator\n          case DESCENDANT:\n            {\n              results = matchDescendant(results, _predicate);\n              break;\n            }\n          default:\n            throw new Error('Unkown combinator selector: ' + String(type));\n        }\n      }\n      index += 1;\n    }\n  } else {\n    throw new TypeError('Enzyme::Selector expects a string, object, or Component Constructor');\n  }\n  return results;\n}\n\nfunction reduceTreesBySelector(selector, roots) {\n  var results = roots.map(function (n) {\n    return reduceTreeBySelector(selector, n);\n  });\n  return (0, _uniq2['default'])((0, _flatten2['default'])(results));\n}"]}