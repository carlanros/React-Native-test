{"version":3,"sources":["ReactNativeRenderer-dev.js"],"names":["__DEV__","require","invariant","warning","emptyFunction","RCTEventEmitter","UIManager","React","ExceptionsManager","TextInputState","deepDiffer","flattenStyle","emptyObject","checkPropTypes","shallowEqual","deepFreezeAndThrowOnMutationInDev","ReactErrorUtils","_caughtError","_hasCaughtError","_rethrowError","_hasRethrowError","injection","injectErrorUtils","injectedErrorUtils","invokeGuardedCallback","name","func","context","a","b","c","d","e","f","apply","arguments","invokeGuardedCallbackAndCatchFirstError","hasCaughtError","error","clearCaughtError","rethrowCaughtError","funcArgs","Array","prototype","slice","call","window","dispatchEvent","document","createEvent","fakeNode","createElement","invokeGuardedCallbackDev","evt","didError","callCallback","removeEventListener","evtType","didSetError","isCrossOriginError","onError","event","colno","lineno","addEventListener","initEvent","Error","eventPluginOrder","namesToPlugins","recomputePluginOrdering","pluginName","pluginModule","pluginIndex","indexOf","plugins","extractEvents","publishedEvents","eventTypes","eventName","publishEventForPlugin","dispatchConfig","eventNameDispatchConfigs","hasOwnProperty","phasedRegistrationNames","phaseName","phasedRegistrationName","publishRegistrationName","registrationName","registrationNameModules","registrationNameDependencies","dependencies","lowerCasedName","toLowerCase","injectEventPluginOrder","injectedEventPluginOrder","injectEventPluginsByName","injectedNamesToPlugins","isOrderingDirty","getFiberCurrentPropsFromNode","getInstanceFromNode","getNodeFromInstance","injection$1","injectComponentTree","Injected","isEndish","topLevelType","isMoveish","isStartish","validateEventDispatches","dispatchListeners","_dispatchListeners","dispatchInstances","_dispatchInstances","listenersIsArr","isArray","listenersLen","length","instancesIsArr","instancesLen","executeDispatch","simulated","listener","inst","type","currentTarget","undefined","executeDispatchesInOrder","i","isPropagationStopped","executeDispatchesInOrderStopAtTrueImpl","executeDispatchesInOrderStopAtTrue","ret","executeDirectDispatch","dispatchListener","dispatchInstance","res","hasDispatches","accumulateInto","current","next","push","concat","forEachAccumulated","arr","cb","scope","forEach","eventQueue","executeDispatchesAndRelease","isPersistent","constructor","release","executeDispatchesAndReleaseSimulated","executeDispatchesAndReleaseTopLevel","isInteractive","tag","shouldPreventMouseEvent","props","disabled","getListener","stateNode","targetInst","nativeEvent","nativeEventTarget","events","possiblePlugin","extractedEvents","enqueueEvents","processEventQueue","processingEventQueue","IndeterminateComponent","FunctionalComponent","ClassComponent","HostRoot","HostPortal","HostComponent","HostText","CallComponent","CallHandlerPhase","ReturnComponent","Fragment","getParent","getLowestCommonAncestor","instA","instB","depthA","tempA","depthB","tempB","depth","alternate","isAncestor","getParentInstance","traverseTwoPhase","fn","arg","path","listenerAtPhase","propagationPhase","accumulateDirectionalDispatches","phase","accumulateTwoPhaseDispatchesSingle","_targetInst","accumulateTwoPhaseDispatchesSingleSkipTarget","parentInst","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","accumulateTwoPhaseDispatchesSkipTarget","accumulateDirectDispatches","didWarnForAddedNewProperty","isProxySupported","Proxy","EVENT_POOL_SIZE","shouldBeReleasedProperties","EventInterface","target","thatReturnsNull","eventPhase","bubbles","cancelable","timeStamp","Date","now","defaultPrevented","isTrusted","SyntheticEvent","preventDefault","stopPropagation","Interface","propName","normalize","returnValue","isDefaultPrevented","thatReturnsTrue","thatReturnsFalse","cancelBubble","persist","destructor","Object","defineProperty","getPooledWarningPropertyDefinition","augmentClass","Class","Super","E","addEventPoolingTo","construct","args","create","that","set","prop","value","getVal","isFunction","configurable","get","val","action","warn","result","warningCondition","getPooledEvent","nativeInst","EventConstructor","eventPool","instance","pop","releasePooledEvent","getPooled","SyntheticEvent$1","ResponderEventInterface","touchHistory","ResponderSyntheticEvent","dispatchMarker","MAX_TOUCH_BANK","touchBank","numberActiveTouches","indexOfSingleActiveTouch","mostRecentTimeStamp","timestampForTouch","touch","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","_ref","identifier","recordTouchStart","recordTouchMove","console","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","ResponderTouchHistoryStore","recordTouchTrack","changedTouches","touches","touchTrackToCheck","activeRecord","accumulate","responderInst","trackedTouchCount","previousActiveTouches","changeResponder","nextResponderInst","blockHostResponder","oldResponderInst","ResponderEventPlugin","GlobalResponderHandler","onChange","startShouldSetResponder","bubbled","captured","scrollShouldSetResponder","selectionChangeShouldSetResponder","moveShouldSetResponder","responderStart","responderMove","responderEnd","responderRelease","responderTerminationRequest","responderGrant","responderReject","responderTerminate","setResponderAndExtractTransfer","shouldSetEventType","bubbleShouldSetFrom","skipOverBubbleShouldSetFrom","shouldSetEvent","wantsResponderInst","extracted","grantEvent","terminationRequestEvent","shouldSwitch","terminateEvent","rejectEvent","canTriggerTransfer","topLevelInst","responderIgnoreScroll","noResponderTouches","activeTouch","_getResponder","isResponderTouchStart","isResponderTouchMove","isResponderTouchEnd","incrementalTouch","gesture","isResponderTerminate","isResponderRelease","finalTouch","finalEvent","GlobalInteractionHandler","injectGlobalResponderHandler","injectGlobalInteractionHandler","customBubblingEventTypes","customDirectEventTypes","ReactNativeBridgeEventPlugin","bubbleDispatchConfig","directDispatchConfig","processEventTypes","viewConfig","bubblingEventTypes","directEventTypes","_topLevelType","_topLevelType2","instanceCache","instanceProps","precacheFiberNode","hostInst","uncacheFiberNode","getInstanceFromTag","getTagFromInstance","_nativeTag","getFiberCurrentPropsFromNode$1","updateFiberProps","ReactNativeComponentTree","freeze","getClosestInstanceFromNode","fiberHostComponent","restoreTarget","restoreQueue","restoreStateOfTarget","internalInstance","restoreControlledState","restoreStateIfNeeded","queuedTargets","fiberBatchedUpdates","bookkeeping","isNestingBatched","batchedUpdates","ReactGenericBatchingInjection","injectFiberBatchedUpdates","_batchedUpdates","injection$2","runEventQueueInBatch","handleTopLevel","INITIAL_TAG_COUNT","ReactNativeTagHandles","tagsStartAt","tagCount","allocateTag","reactTagIsNativeTopRootID","assertRootTag","reactTag","EMPTY_NATIVE_EVENT","touchSubsequence","indices","removeTouchesAtIndices","rippedOut","temp","index","fillAt","j","cur","_receiveRootNodeIDEvent","rootNodeID","nativeEventParam","receiveEvent","receiveTouches","eventTopLevelType","changedIndices","jj","ReactNativeEventEmitter","registrationNames","ReactNativeEventPluginOrder","ReactNativeGlobalResponderHandler","from","to","blockNativeResponder","setJSResponder","clearJSResponder","register","defaultShowDialog","capturedError","showDialog","logCapturedError","logError","suppressLogging","suppressReactErrorLogging","componentName","componentStack","errorBoundaryName","errorBoundaryFound","willRetry","componentNameMessage","errorBoundaryMessage","combinedMessage","injection$4","injectDialog","hasSymbol","Symbol","REACT_ELEMENT_TYPE","REACT_CALL_TYPE","REACT_RETURN_TYPE","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","MAYBE_ITERATOR_SYMBOL","iterator","FAUX_ITERATOR_SYMBOL","getIteratorFn","maybeIterable","maybeIterator","createPortal","children","containerInfo","implementation","key","$$typeof","TouchHistoryMath","centroidDimension","touchesChangedAfter","isXAxis","ofCurrent","total","count","oneTouchData","touchTrack","toAdd","noCentroid","currentCentroidXOfTouchesChangedAfter","currentCentroidYOfTouchesChangedAfter","previousCentroidXOfTouchesChangedAfter","previousCentroidYOfTouchesChangedAfter","currentCentroidX","currentCentroidY","ReactInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentOwner","ReactDebugCurrentFrame","ReactGlobalSharedState","ReactVersion","showDialog$1","errorToHandle","message","summary","handleException","_classCallCheck","Constructor","TypeError","objects","uniqueID","emptyObject$2","ReactNativePropRegistry","object","id","getByID","emptyObject$1","removedKeys","removedKeyCount","defaultDiffer","prevProp","nextProp","resolveObject","idOrObject","restoreDeletedValuesInNestedArray","updatePayload","node","validAttributes","obj","propKey","attributeConfig","diff","process","nextValue","diffNestedArrayProperty","prevArray","nextArray","minLength","diffNestedProperty","clearNestedProperty","addNestedProperty","diffProperties","addProperties","clearProperties","prevProps","nextProps","shouldUpdate","mountSafeCallback","callback","__isMounted","isMounted","throwOnStylesProp","component","styles","owner","_owner","displayName","msg","warnForStyleProps","style","_reactInternalFiber","getComponentName","fiber","_require","debugRenderPhaseSideEffects","enableAsyncSubtreeAPI","enableUserTimingAPI","enableMutatingReconciler","enableNoopReconciler","enablePersistentReconciler","NoEffect","PerformedWork","Placement","Update","PlacementAndUpdate","Deletion","ContentReset","Callback","Err","Ref","MOUNTING","MOUNTED","UNMOUNTED","isFiberMountedImpl","effectTag","isFiberMounted","ownerFiber","_warnedAboutRefsInRender","assertIsMounted","findCurrentFiberUsingSlowPath","state","parentA","parentB","child","sibling","didFindChild","_child","findCurrentHostFiber","parent","currentParent","findCurrentHostFiberWithNoPortals","valueStack","fiberStack","createCursor","defaultValue","cursor","reset","describeComponentFrame","source","ownerName","fileName","replace","lineNumber","describeFiber","_debugOwner","_debugSource","getStackAddendumByWorkInProgressFiber","workInProgress","info","getCurrentFiberOwnerName","ReactDebugCurrentFiber","getCurrentFiberStackAddendum","resetCurrentFiber","getCurrentStack","setCurrentFiber","setCurrentPhase","reactEmoji","warningEmoji","supportsUserTiming","performance","mark","clearMarks","measure","clearMeasures","currentFiber","currentPhase","currentPhaseFiber","isCommitting","hasScheduledUpdateInCurrentCommit","hasScheduledUpdateInCurrentPhase","commitCountInCurrentWorkLoop","effectCountInCurrentCommit","isWaitingForCallback","labelsInCurrentCommit","Set","formatMarkName","markName","formatLabel","label","warning$$1","prefix","suffix","beginMark","clearMark","endMark","formattedMarkName","formattedLabel","err","getFiberMarkName","debugID","getFiberLabel","beginFiberMark","_debugID","has","add","clearFiberMark","endFiberMark","shouldIgnoreFiber","clearPendingPhaseMeasurement","pauseTimers","_debugIsCurrentlyTiming","resumeTimersRecursively","resumeTimers","recordEffect","recordScheduleUpdate","startRequestCallbackTimer","stopRequestCallbackTimer","didExpire","startWorkTimer","cancelWorkTimer","stopWorkTimer","stopFailedWorkTimer","startPhaseTimer","stopPhaseTimer","startWorkLoopTimer","nextUnitOfWork","stopWorkLoopTimer","interruptedBy","startCommitTimer","clear","stopCommitTimer","startCommitHostEffectsTimer","stopCommitHostEffectsTimer","startCommitLifeCyclesTimer","stopCommitLifeCyclesTimer","warnedAboutMissingGetChildContext","contextStackCursor","didPerformWorkStackCursor","previousContext","getUnmaskedContext","hasOwnContext","isContextProvider","cacheContext","unmaskedContext","maskedContext","__reactInternalMemoizedUnmaskedChildContext","__reactInternalMemoizedMaskedChildContext","getMaskedContext","contextTypes","hasContextChanged","isContextConsumer","childContextTypes","popContextProvider","popTopLevelContextObject","pushTopLevelContextObject","didChange","processChildContext","parentContext","getChildContext","childContext","contextKey","pushContextProvider","memoizedMergedChildContext","__reactInternalMemoizedMergedChildContext","invalidateContextProvider","mergedContext","resetContext","findCurrentUnmaskedContext","NoWork","Sync","Never","UNIT_SIZE","MAGIC_NUMBER_OFFSET","msToExpirationTime","ms","expirationTimeToMs","expirationTime","ceiling","num","precision","computeExpirationBucket","currentTime","expirationInMs","bucketSizeMs","NoContext","AsyncUpdates","hasBadMapPolyfill","nonExtensibleObject","preventExtensions","Map","debugCounter","FiberNode","pendingProps","internalContextTag","ref","memoizedProps","updateQueue","memoizedState","nextEffect","firstEffect","lastEffect","createFiber","shouldConstruct","Component","isReactComponent","createWorkInProgress","createHostRootFiber","createFiberFromElement","element","keys","_source","createFiberFromFragment","elements","createFiberFromText","content","createFiberFromHostInstanceForDeletion","createFiberFromCall","handler","createFiberFromReturn","returnNode","createFiberFromPortal","portal","pendingChildren","createFiberRoot","hydrate","uninitializedFiber","root","remainingExpirationTime","isReadyForCommit","finishedWork","pendingContext","firstBatch","nextScheduledRoot","onCommitFiberRoot","onCommitFiberUnmount","hasLoggedError","catchErrors","injectInternals","internals","__REACT_DEVTOOLS_GLOBAL_HOOK__","hook","isDisabled","supportsFiber","rendererID","inject","onCommitRoot","onCommitUnmount","didWarnUpdateInsideUpdate","createUpdateQueue","baseState","queue","first","last","callbackList","hasForceUpdate","isInitialized","isProcessing","insertUpdateIntoQueue","update","insertUpdateIntoFiber","alternateFiber","queue1","queue2","getUpdateExpirationTime","getStateFromUpdate","prevState","partialState","updateFn","processUpdateQueue","renderExpirationTime","currentQueue","dontMutatePrevState","didSkip","updateExpirationTime","_partialState","isReplace","isForced","_callbackList","commitCallbacks","_callback","fakeInternalInstance","didWarnAboutStateAssignmentForComponent","warnOnInvalidCallback","callerName","enumerable","ReactFiberClassComponent","scheduleWork","computeExpirationForFiber","memoizeProps","memoizeState","updater","enqueueSetState","nextCallback","enqueueReplaceState","enqueueForceUpdate","checkShouldComponentUpdate","oldProps","newProps","oldState","newState","newContext","shouldComponentUpdate","isPureReactComponent","checkClassInstance","renderPresent","render","noGetInitialStateOnES6","getInitialState","isReactClassApproved","noGetDefaultPropsOnES6","getDefaultProps","noInstancePropTypes","propTypes","noInstanceContextTypes","noComponentShouldUpdate","componentShouldUpdate","noComponentDidUnmount","componentDidUnmount","noComponentDidReceiveProps","componentDidReceiveProps","noComponentWillRecieveProps","componentWillRecieveProps","hasMutatedProps","noInstanceDefaultProps","defaultProps","resetInputPointers","adoptClassInstance","_reactInternalInstance","constructClassInstance","ctor","needsContext","callComponentWillMount","componentWillMount","callComponentWillReceiveProps","componentWillReceiveProps","mountClassInstance","refs","unstable_isAsyncReactComponent","componentDidMount","updateClassInstance","oldContext","newUnmaskedContext","componentDidUpdate","componentWillUpdate","getCurrentFiberStackAddendum$1","didWarnAboutMaps","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","_store","validated","currentComponentErrorInfo","isArray$1","coerceRef","mixedRef","stringRef","_stringRef","throwOnInvalidObjectType","returnFiber","newChild","addendum","toString","join","warnOnFunctionType","ChildReconciler","shouldTrackSideEffects","deleteChild","childToDelete","deleteRemainingChildren","currentFirstChild","mapRemainingChildren","existingChildren","existingChild","useFiber","clone","placeChild","newFiber","lastPlacedIndex","newIndex","oldIndex","placeSingleChild","updateTextNode","textContent","created","existing","updateElement","updateCall","updateReturn","updatePortal","updateFragment","fragment","createChild","_created","_created2","_created3","_created4","_created5","_created6","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","_matchedFiber","_matchedFiber2","_matchedFiber3","_matchedFiber4","_matchedFiber5","warnOnInvalidKey","knownKeys","reconcileChildrenArray","newChildren","resultingFirstChild","previousNewFiber","nextOldFiber","_newFiber","_newFiber2","reconcileChildrenIterator","newChildrenIterable","iteratorFn","entries","possibleMap","_newChildren","_step","done","step","_newFiber3","_newFiber4","reconcileSingleTextNode","reconcileSingleElement","_created7","reconcileSingleCall","reconcileSingleReturn","reconcileSinglePortal","reconcileChildFibers","isObject","_isMockFunction","mountChildFibers","cloneChildFibers","currentChild","warnedAboutStatelessRefs","ReactFiberBeginWork","config","hostContext","hydrationContext","shouldSetTextContent","useSyncScheduling","shouldDeprioritizeSubtree","pushHostContext","pushHostContainer","enterHydrationState","resetHydrationState","tryToClaimNextHydratableInstance","_ReactFiberClassCompo","reconcileChildren","nextChildren","reconcileChildrenAtExpirationTime","bailoutOnAlreadyFinishedWork","markRef","updateFunctionalComponent","updateClassComponent","hasContext","finishClassComponent","pushHostRootContext","updateHostRoot","updateHostComponent","isDirectTextChild","updateHostText","mountIndeterminateComponent","warningKey","debugSource","updateCallComponent","nextCall","updatePortalComponent","bailoutOnLowPriority","nextState","beginWork","beginFailedWork","ReactFiberCompleteWork","createInstance","createTextInstance","appendInitialChild","finalizeInitialChildren","prepareUpdate","mutation","persistence","getRootHostContainer","popHostContext","getHostContext","popHostContainer","prepareToHydrateHostInstance","prepareToHydrateHostTextInstance","popHydrationState","markUpdate","appendAllReturns","returns","moveCallToHandlerPhase","appendAllChildren","updateHostContainer","rootContainerInstance","oldText","newText","cloneInstance","createContainerChildSet","appendChildToContainerChildSet","finalizeContainerChildren","appendAllChildrenToContainer","containerChildSet","portalOrRoot","childrenUnchanged","container","newChildSet","currentInstance","recyclableInstance","newInstance","currentHostContext","completeWork","fiberRoot","_currentHostContext","wasHydrated","_instance","_rootContainerInstance","_currentHostContext2","_wasHydrated","invokeGuardedCallback$2","hasCaughtError$1","clearCaughtError$1","ReactFiberCommitWork","captureError","getPublicInstance","callComponentWillUnmountWithTimer","componentWillUnmount","safelyCallComponentWillUnmount","unmountError","safelyDetachRef","refError","commitLifeCycles","_updateQueue","_instance2","commitMount","commitAttachRef","commitDetachRef","currentRef","commitUnmount","commitNestedUnmounts","unmountHostComponents","emptyPortalContainer","detachFiber","commitContainer","replaceContainerChildren","emptyChildSet","_pendingChildren","commitResetTextContent","commitPlacement","commitDeletion","commitWork","commitUpdate","resetTextContent","commitTextUpdate","appendChild","appendChildToContainer","insertBefore","insertInContainerBefore","removeChild","removeChildFromContainer","getHostParentFiber","isHostParent","getHostSibling","siblings","parentFiber","isContainer","before","currentParentIsValid","currentParentIsContainer","findParent","textInstance","NO_CONTEXT","ReactFiberHostContext","getChildHostContext","getRootHostContext","contextFiberStackCursor","rootInstanceStackCursor","requiredContext","rootInstance","nextRootInstance","nextRootContext","nextContext","resetHostContainer","ReactFiberHydrationContext","hydration","canHydrateInstance","canHydrateTextInstance","getNextHydratableSibling","getFirstHydratableChild","hydrateInstance","hydrateTextInstance","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","didNotHydrateContainerInstance","didNotHydrateInstance","didNotFindHydratableContainerInstance","didNotFindHydratableContainerTextInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","hydrationParentFiber","nextHydratableInstance","isHydrating","parentInstance","deleteHydratableInstance","insertNonHydratedInstance","parentContainer","text","parentType","parentProps","_type","_props","_text","tryHydrate","nextInstance","popToNextHostParent","ReactFiberInstrumentation","debugTool","ReactFiberInstrumentation_1","invokeGuardedCallback$1","didWarnAboutStateTransition","didWarnSetStateChildContext","didWarnStateUpdateForUnmountedComponent","warnAboutUpdateOnUnmounted","warnAboutInvalidUpdates","ReactFiberScheduler","_ReactFiberBeginWork","_ReactFiberCompleteWo","_ReactFiberCommitWork","scheduleDeferredCallback","cancelDeferredCallback","prepareForCommit","resetAfterCommit","startTime","mostRecentCurrentTime","lastUniqueAsyncExpiration","expirationContext","isWorking","nextRoot","nextRenderExpirationTime","capturedErrors","failedBoundaries","commitPhaseBoundaries","firstUncaughtError","didFatal","isUnmounting","resetContextStack","commitAllHostEffects","primaryEffectTag","_current","_current2","commitAllLifeCycles","commitErrorHandling","commitRoot","_error","_didError","_error2","onCommitWork","scheduleErrorRecovery","_error3","onUncaughtError","remainingTime","resetExpirationTime","renderTime","newExpirationTime","completeUnitOfWork","siblingFiber","onCompleteWork","performUnitOfWork","onBeginWork","performFailedUnitOfWork","workLoop","slowWorkLoopThatChecksForFailedWork","shouldYield","hasCapturedError","renderRootCatchBlock","failedWork","boundary","unwindContexts","renderRoot","uncaughtError","isFailedBoundary","componentDidCatch","_componentStack","_componentName","errorBoundary","effectfulFiber","computeAsyncExpiration","recalculateCurrentTime","expirationMs","computeUniqueAsyncExpiration","scheduleWorkImpl","checkRootNeedsClearing","isErrorRecovery","requestWork","deferredUpdates","previousExpirationContext","syncUpdates","firstScheduledRoot","lastScheduledRoot","callbackExpirationTime","callbackID","isRendering","nextFlushedRoot","nextFlushedExpirationTime","deadlineDidExpire","hasUnhandledError","unhandledError","deadline","isBatchingUpdates","isUnbatchingUpdates","completedBatches","NESTED_UPDATE_LIMIT","nestedUpdateCount","timeHeuristicForUnitOfWork","scheduleCallbackWithExpiration","currentMs","timeout","performAsyncWork","performWorkOnRoot","performWork","findHighestPriorityRoot","highestPriorityWork","highestPriorityRoot","previousScheduledRoot","previousFlushedRoot","dl","minExpirationTime","finishRendering","flushRoot","batches","batch","_onComplete","_error4","completeRoot","_finishedWork","_expirationTime","_defer","timeRemaining","previousIsBatchingUpdates","unbatchedUpdates","flushSync","didWarnAboutNestedUpdates","getContextForSubtree","parentComponent","ReactFiberReconciler$1","_ReactFiberScheduler","computeRootExpirationTime","scheduleRootUpdate","updateContainerAtExpirationTime","onMountContainer","onUnmountContainer","onUpdateContainer","findHostInstance","hostFiber","createContainer","updateContainer","getPublicRootInstance","containerFiber","findHostInstanceWithNoPortals","injectIntoDevTools","devToolsConfig","findFiberByHostInstance","findHostInstanceByFiber","ReactFiberReconciler$2","default","ReactFiberReconciler$3","reactReconciler","viewConfigCallbacks","viewConfigs","get$1","_classCallCheck$1","ReactNativeFiberHostComponent","_children","blur","blurTextInput","focus","focusTextInput","measureInWindow","measureLayout","relativeToNativeNode","onSuccess","onFail","setNativeProps","nativeProps","updateView","uiViewClassName","hasNativePerformanceNow","scheduledCallback","frameDeadline","frameDeadlineObject","setTimeoutCallback","setTimeout","clearTimeout","recursivelyUncacheFiberNode","NativeRenderer","internalInstanceHandle","createView","nativeTags","map","setChildren","childTag","splice","manageChildren","updatePayloadTODO","beforeChild","beforeChildIndex","_beforeChildIndex","findNodeHandle","componentOrHandle","findNumericNodeHandleFiber","NativeMethodsMixin","maybeInstance","NativeMethodsMixin_DEV","_classCallCheck$2","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","writable","setPrototypeOf","__proto__","ReactNativeComponent","_React$Component","getInspectorDataForViewTag","traverseOwnerTreeUp","hierarchy","unshift","getOwnerHierarchy","lastNonHostInstance","getHostProps","host","getHostNode","hostNode","createHierarchy","fiberHierarchy","getInspectorData","viewTag","closestInstance","selection","createReactNativeComponentClass","takeSnapshot","view","options","__takeSnapshot","roots","ReactNativeRenderer","NativeComponent","containerTag","unmountComponentAtNode","unmountComponentAtNodeAndRemoveContainer","removeRootView","unstable_batchedUpdates","ReactDebugTool","addHook","removeHook","ReactPerf","start","stop","printInclusive","printWasted","bundleType","version","rendererPackageName","ReactNativeRenderer$2","ReactNativeRenderer$3","reactNativeRenderer","module","exports"],"mappings":"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","file":"ReactNativeRenderer-dev.js","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @noflow\n * @providesModule ReactNativeRenderer-dev\n * @preventMunge\n */\n\n'use strict';\n\nif (__DEV__) {\n  (function() {\n\"use strict\";\n\nrequire(\"InitializeCore\");\nvar invariant = require(\"fbjs/lib/invariant\");\nvar warning = require(\"fbjs/lib/warning\");\nvar emptyFunction = require(\"fbjs/lib/emptyFunction\");\nvar RCTEventEmitter = require(\"RCTEventEmitter\");\nvar UIManager = require(\"UIManager\");\nvar React = require(\"react\");\nvar ExceptionsManager = require(\"ExceptionsManager\");\nvar TextInputState = require(\"TextInputState\");\nvar deepDiffer = require(\"deepDiffer\");\nvar flattenStyle = require(\"flattenStyle\");\nvar emptyObject = require(\"fbjs/lib/emptyObject\");\nvar checkPropTypes = require(\"prop-types/checkPropTypes\");\nvar shallowEqual = require(\"fbjs/lib/shallowEqual\");\nvar deepFreezeAndThrowOnMutationInDev = require(\"deepFreezeAndThrowOnMutationInDev\");\n\nvar ReactErrorUtils = {\n  // Used by Fiber to simulate a try-catch.\n  _caughtError: null,\n  _hasCaughtError: false,\n\n  // Used by event system to capture/rethrow the first error.\n  _rethrowError: null,\n  _hasRethrowError: false,\n\n  injection: {\n    injectErrorUtils: function(injectedErrorUtils) {\n      invariant(\n        typeof injectedErrorUtils.invokeGuardedCallback === \"function\",\n        \"Injected invokeGuardedCallback() must be a function.\"\n      );\n      invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;\n    }\n  },\n\n  /**\n   * Call a function while guarding against errors that happens within it.\n   * Returns an error if it throws, otherwise null.\n   *\n   * In production, this is implemented using a try-catch. The reason we don't\n   * use a try-catch directly is so that we can swap out a different\n   * implementation in DEV mode.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallback: function(name, func, context, a, b, c, d, e, f) {\n    invokeGuardedCallback.apply(ReactErrorUtils, arguments);\n  },\n\n  /**\n   * Same as invokeGuardedCallback, but instead of returning an error, it stores\n   * it in a global so it can be rethrown by `rethrowCaughtError` later.\n   * TODO: See if _caughtError and _rethrowError can be unified.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallbackAndCatchFirstError: function(\n    name,\n    func,\n    context,\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  ) {\n    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n    if (ReactErrorUtils.hasCaughtError()) {\n      var error = ReactErrorUtils.clearCaughtError();\n      if (!ReactErrorUtils._hasRethrowError) {\n        ReactErrorUtils._hasRethrowError = true;\n        ReactErrorUtils._rethrowError = error;\n      }\n    }\n  },\n\n  /**\n   * During execution of guarded functions we will capture the first error which\n   * we will rethrow to be handled by the top level error handler.\n   */\n  rethrowCaughtError: function() {\n    return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n  },\n\n  hasCaughtError: function() {\n    return ReactErrorUtils._hasCaughtError;\n  },\n\n  clearCaughtError: function() {\n    if (ReactErrorUtils._hasCaughtError) {\n      var error = ReactErrorUtils._caughtError;\n      ReactErrorUtils._caughtError = null;\n      ReactErrorUtils._hasCaughtError = false;\n      return error;\n    } else {\n      invariant(\n        false,\n        \"clearCaughtError was called but no error was captured. This error \" +\n          \"is likely caused by a bug in React. Please file an issue.\"\n      );\n    }\n  }\n};\n\nvar invokeGuardedCallback = function(name, func, context, a, b, c, d, e, f) {\n  ReactErrorUtils._hasCaughtError = false;\n  ReactErrorUtils._caughtError = null;\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    ReactErrorUtils._caughtError = error;\n    ReactErrorUtils._hasCaughtError = true;\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (\n    typeof window !== \"undefined\" &&\n    typeof window.dispatchEvent === \"function\" &&\n    typeof document !== \"undefined\" &&\n    typeof document.createEvent === \"function\"\n  ) {\n    var fakeNode = document.createElement(\"react\");\n\n    var invokeGuardedCallbackDev = function(\n      name,\n      func,\n      context,\n      a,\n      b,\n      c,\n      d,\n      e,\n      f\n    ) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebookincubator/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      invariant(\n        typeof document !== \"undefined\",\n        \"The `document` global was defined when React was initialized, but is not \" +\n          \"defined anymore. This can happen in a test environment if a component \" +\n          \"schedules an update from an asynchronous callback, but the test has already \" +\n          \"finished running. To solve this, you can either unmount the component at \" +\n          \"the end of your test (and ensure that any asynchronous operations get \" +\n          \"canceled in `componentWillUnmount`), or you can change the test itself \" +\n          \"to be asynchronous.\"\n      );\n      var evt = document.createEvent(\"Event\");\n\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function onError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = \"react-\" + (name ? name : \"invokeguardedcallback\");\n\n      // Attach our event handlers\n      window.addEventListener(\"error\", onError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error(\n            \"An error was thrown inside one of your components, but React \" +\n              \"doesn't know what it was. This is likely due to browser \" +\n              'flakiness. React does its best to preserve the \"Pause on ' +\n              'exceptions\" behavior of the DevTools, which requires some ' +\n              \"DEV-mode only tricks. It's possible that these don't work in \" +\n              \"your browser. Try triggering the error in production mode, \" +\n              \"or switching to a modern browser. If you suspect that this is \" +\n              \"actually an issue with React, please file an issue.\"\n          );\n        } else if (isCrossOriginError) {\n          error = new Error(\n            \"A cross-origin error was thrown. React doesn't have access to \" +\n              \"the actual error object in development. \" +\n              \"See https://fb.me/react-crossorigin-error for more information.\"\n          );\n        }\n        ReactErrorUtils._hasCaughtError = true;\n        ReactErrorUtils._caughtError = error;\n      } else {\n        ReactErrorUtils._hasCaughtError = false;\n        ReactErrorUtils._caughtError = null;\n      }\n\n      // Remove our event listeners\n      window.removeEventListener(\"error\", onError);\n    };\n\n    invokeGuardedCallback = invokeGuardedCallbackDev;\n  }\n}\n\nvar rethrowCaughtError = function() {\n  if (ReactErrorUtils._hasRethrowError) {\n    var error = ReactErrorUtils._rethrowError;\n    ReactErrorUtils._rethrowError = null;\n    ReactErrorUtils._hasRethrowError = false;\n    throw error;\n  }\n};\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    invariant(\n      pluginIndex > -1,\n      \"EventPluginRegistry: Cannot inject event plugins that do not exist in \" +\n        \"the plugin ordering, `%s`.\",\n      pluginName\n    );\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n    invariant(\n      pluginModule.extractEvents,\n      \"EventPluginRegistry: Event plugins must implement an `extractEvents` \" +\n        \"method, but `%s` does not.\",\n      pluginName\n    );\n    plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      invariant(\n        publishEventForPlugin(\n          publishedEvents[eventName],\n          pluginModule,\n          eventName\n        ),\n        \"EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.\",\n        eventName,\n        pluginName\n      );\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  invariant(\n    !eventNameDispatchConfigs.hasOwnProperty(eventName),\n    \"EventPluginHub: More than one plugin attempted to publish the same \" +\n      \"event name, `%s`.\",\n    eventName\n  );\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(\n          phasedRegistrationName,\n          pluginModule,\n          eventName\n        );\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(\n      dispatchConfig.registrationName,\n      pluginModule,\n      eventName\n    );\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  invariant(\n    !registrationNameModules[registrationName],\n    \"EventPluginHub: More than one plugin attempted to publish the same \" +\n      \"registration name, `%s`.\",\n    registrationName\n  );\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] =\n    pluginModule.eventTypes[eventName].dependencies;\n\n  {\n    var lowerCasedName = registrationName.toLowerCase();\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\nvar plugins = [];\n\n/**\n * Mapping from event name to dispatch config\n */\nvar eventNameDispatchConfigs = {};\n\n/**\n * Mapping from registration name to plugin module\n */\nvar registrationNameModules = {};\n\n/**\n * Mapping from registration name to event name\n */\nvar registrationNameDependencies = {};\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\n\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\nfunction injectEventPluginOrder(injectedEventPluginOrder) {\n  invariant(\n    !eventPluginOrder,\n    \"EventPluginRegistry: Cannot inject event plugin ordering more than \" +\n      \"once. You are likely trying to load more than one copy of React.\"\n  );\n  // Clone the ordering so it cannot be dynamically mutated.\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\nfunction injectEventPluginsByName(injectedNamesToPlugins) {\n  var isOrderingDirty = false;\n  for (var pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n    var pluginModule = injectedNamesToPlugins[pluginName];\n    if (\n      !namesToPlugins.hasOwnProperty(pluginName) ||\n      namesToPlugins[pluginName] !== pluginModule\n    ) {\n      invariant(\n        !namesToPlugins[pluginName],\n        \"EventPluginRegistry: Cannot inject two different event plugins \" +\n          \"using the same name, `%s`.\",\n        pluginName\n      );\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\n\nvar injection$1 = {\n  injectComponentTree: function(Injected) {\n    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;\n    getInstanceFromNode = Injected.getInstanceFromNode;\n    getNodeFromInstance = Injected.getNodeFromInstance;\n\n    {\n      warning(\n        getNodeFromInstance && getInstanceFromNode,\n        \"EventPluginUtils.injection.injectComponentTree(...): Injected \" +\n          \"module is missing getNodeFromInstance or getInstanceFromNode.\"\n      );\n    }\n  }\n};\n\nfunction isEndish(topLevelType) {\n  return (\n    topLevelType === \"topMouseUp\" ||\n    topLevelType === \"topTouchEnd\" ||\n    topLevelType === \"topTouchCancel\"\n  );\n}\n\nfunction isMoveish(topLevelType) {\n  return topLevelType === \"topMouseMove\" || topLevelType === \"topTouchMove\";\n}\nfunction isStartish(topLevelType) {\n  return topLevelType === \"topMouseDown\" || topLevelType === \"topTouchStart\";\n}\n\nvar validateEventDispatches;\n{\n  validateEventDispatches = function(event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr\n      ? dispatchListeners.length\n      : dispatchListeners ? 1 : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr\n      ? dispatchInstances.length\n      : dispatchInstances ? 1 : 0;\n\n    warning(\n      instancesIsArr === listenersIsArr && instancesLen === listenersLen,\n      \"EventPluginUtils: Invalid `event`.\"\n    );\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || \"unknown-event\";\n  event.currentTarget = getNodeFromInstance(inst);\n  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(\n    type,\n    listener,\n    undefined,\n    event\n  );\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(\n        event,\n        simulated,\n        dispatchListeners[i],\n        dispatchInstances[i]\n      );\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      if (dispatchListeners[i](event, dispatchInstances[i])) {\n        return dispatchInstances[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchInstances)) {\n      return dispatchInstances;\n    }\n  }\n  return null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchInstances = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\nfunction executeDirectDispatch(event) {\n  {\n    validateEventDispatches(event);\n  }\n  var dispatchListener = event._dispatchListeners;\n  var dispatchInstance = event._dispatchInstances;\n  invariant(\n    !Array.isArray(dispatchListener),\n    \"executeDirectDispatch(...): Invalid `event`.\"\n  );\n  event.currentTarget = dispatchListener\n    ? getNodeFromInstance(dispatchInstance)\n    : null;\n  var res = dispatchListener ? dispatchListener(event) : null;\n  event.currentTarget = null;\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n  return res;\n}\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  invariant(\n    next != null,\n    \"accumulateInto(...): Accumulated items must not be null or undefined.\"\n  );\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function(event, simulated) {\n  if (event) {\n    executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function(e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function(e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nfunction isInteractive(tag) {\n  return (\n    tag === \"button\" ||\n    tag === \"input\" ||\n    tag === \"select\" ||\n    tag === \"textarea\"\n  );\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case \"onClick\":\n    case \"onClickCapture\":\n    case \"onDoubleClick\":\n    case \"onDoubleClickCapture\":\n    case \"onMouseDown\":\n    case \"onMouseDownCapture\":\n    case \"onMouseMove\":\n    case \"onMouseMoveCapture\":\n    case \"onMouseUp\":\n    case \"onMouseUpCapture\":\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\nvar injection = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder: injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName: injectEventPluginsByName\n};\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  invariant(\n    !listener || typeof listener === \"function\",\n    \"Expected `%s` listener to be a function, instead got a value of `%s` type.\",\n    registrationName,\n    typeof listener\n  );\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractEvents(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var events;\n  for (var i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    var possiblePlugin = plugins[i];\n    if (possiblePlugin) {\n      var extractedEvents = possiblePlugin.extractEvents(\n        topLevelType,\n        targetInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\n/**\n * Enqueues a synthetic event that should be dispatched when\n * `processEventQueue` is invoked.\n *\n * @param {*} events An accumulation of synthetic events.\n * @internal\n */\nfunction enqueueEvents(events) {\n  if (events) {\n    eventQueue = accumulateInto(eventQueue, events);\n  }\n}\n\n/**\n * Dispatches all synthetic events on the event queue.\n *\n * @internal\n */\nfunction processEventQueue(simulated) {\n  // Set `eventQueue` to null before processing it so that we can tell if more\n  // events get enqueued while processing.\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n\n  if (!processingEventQueue) {\n    return;\n  }\n\n  if (simulated) {\n    forEachAccumulated(\n      processingEventQueue,\n      executeDispatchesAndReleaseSimulated\n    );\n  } else {\n    forEachAccumulated(\n      processingEventQueue,\n      executeDispatchesAndReleaseTopLevel\n    );\n  }\n  invariant(\n    !eventQueue,\n    \"processEventQueue(): Additional events were enqueued while processing \" +\n      \"an event queue. Support for this has not yet been implemented.\"\n  );\n  // This would be a good time to rethrow if any of the event handlers threw.\n  ReactErrorUtils.rethrowCaughtError();\n}\n\nvar IndeterminateComponent = 0; // Before we know whether it is functional or class\nvar FunctionalComponent = 1;\nvar ClassComponent = 2;\nvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 5;\nvar HostText = 6;\nvar CallComponent = 7;\nvar CallHandlerPhase = 8;\nvar ReturnComponent = 9;\nvar Fragment = 10;\n\nfunction getParent(inst) {\n  do {\n    inst = inst[\"return\"];\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\nfunction isAncestor(instA, instB) {\n  while (instB) {\n    if (instA === instB || instA === instB.alternate) {\n      return true;\n    }\n    instB = getParent(instB);\n  }\n  return false;\n}\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i;\n  for (i = path.length; i-- > 0; ) {\n    fn(path[i], \"captured\", arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], \"bubbled\", arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName =\n    event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    warning(inst, \"Dispatching inst must not be null\");\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(\n      event._dispatchListeners,\n      listener\n    );\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(\n        event._dispatchListeners,\n        listener\n      );\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/* eslint valid-typeof: 0 */\n\nvar didWarnForAddedNewProperty = false;\nvar isProxySupported = typeof Proxy === \"function\";\nvar EVENT_POOL_SIZE = 10;\n\nvar shouldBeReleasedProperties = [\n  \"dispatchConfig\",\n  \"_targetInst\",\n  \"nativeEvent\",\n  \"isDefaultPrevented\",\n  \"isPropagationStopped\",\n  \"_dispatchListeners\",\n  \"_dispatchInstances\"\n];\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: emptyFunction.thatReturnsNull,\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function(event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(\n  dispatchConfig,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === \"target\") {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented =\n    nativeEvent.defaultPrevented != null\n      ? nativeEvent.defaultPrevented\n      : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;\n  }\n  this.isPropagationStopped = emptyFunction.thatReturnsFalse;\n  return this;\n}\n\nObject.assign(SyntheticEvent.prototype, {\n  preventDefault: function() {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== \"unknown\") {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  },\n\n  stopPropagation: function() {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== \"unknown\") {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function() {\n    this.isPersistent = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: emptyFunction.thatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function() {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(\n          this,\n          propName,\n          getPooledWarningPropertyDefinition(propName, Interface[propName])\n        );\n      }\n    }\n    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {\n      this[shouldBeReleasedProperties[i]] = null;\n    }\n    {\n      Object.defineProperty(\n        this,\n        \"nativeEvent\",\n        getPooledWarningPropertyDefinition(\"nativeEvent\", null)\n      );\n      Object.defineProperty(\n        this,\n        \"preventDefault\",\n        getPooledWarningPropertyDefinition(\"preventDefault\", emptyFunction)\n      );\n      Object.defineProperty(\n        this,\n        \"stopPropagation\",\n        getPooledWarningPropertyDefinition(\"stopPropagation\", emptyFunction)\n      );\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n *\n * @param {function} Class\n * @param {?object} Interface\n */\nSyntheticEvent.augmentClass = function(Class, Interface) {\n  var Super = this;\n\n  var E = function() {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  Object.assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = Object.assign({}, Super.Interface, Interface);\n  Class.augmentClass = Super.augmentClass;\n  addEventPoolingTo(Class);\n};\n\n/** Proxying after everything set on SyntheticEvent\n * to resolve Proxy issue on some WebKit browsers\n * in which some Event properties are set to undefined (GH#10010)\n */\n{\n  if (isProxySupported) {\n    /*eslint-disable no-func-assign */\n    SyntheticEvent = new Proxy(SyntheticEvent, {\n      construct: function(target, args) {\n        return this.apply(target, Object.create(target.prototype), args);\n      },\n      apply: function(constructor, that, args) {\n        return new Proxy(constructor.apply(that, args), {\n          set: function(target, prop, value) {\n            if (\n              prop !== \"isPersistent\" &&\n              !target.constructor.Interface.hasOwnProperty(prop) &&\n              shouldBeReleasedProperties.indexOf(prop) === -1\n            ) {\n              warning(\n                didWarnForAddedNewProperty || target.isPersistent(),\n                \"This synthetic event is reused for performance reasons. If you're \" +\n                  \"seeing this, you're adding a new property in the synthetic event object. \" +\n                  \"The property is never released. See \" +\n                  \"https://fb.me/react-event-pooling for more information.\"\n              );\n              didWarnForAddedNewProperty = true;\n            }\n            target[prop] = value;\n            return true;\n          }\n        });\n      }\n    });\n    /*eslint-enable no-func-assign */\n  }\n}\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === \"function\";\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? \"setting the method\" : \"setting the property\";\n    warn(action, \"This is effectively a no-op\");\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? \"accessing the method\" : \"accessing the property\";\n    var result = isFunction\n      ? \"This is a no-op function\"\n      : \"This is set to null\";\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    warning(\n      warningCondition,\n      \"This synthetic event is reused for performance reasons. If you're seeing this, \" +\n        \"you're %s `%s` on a released/nullified synthetic event. %s. \" +\n        \"If you must keep the original synthetic event around, use event.persist(). \" +\n        \"See https://fb.me/react-event-pooling for more information.\",\n      action,\n      propName,\n      result\n    );\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(\n      instance,\n      dispatchConfig,\n      targetInst,\n      nativeEvent,\n      nativeInst\n    );\n    return instance;\n  }\n  return new EventConstructor(\n    dispatchConfig,\n    targetInst,\n    nativeEvent,\n    nativeInst\n  );\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  invariant(\n    event instanceof EventConstructor,\n    \"Trying to release an event instance  into a pool of a different type.\"\n  );\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\nvar SyntheticEvent$1 = SyntheticEvent;\n\n/**\n * `touchHistory` isn't actually on the native event, but putting it in the\n * interface will ensure that it is cleaned up when pooled/destroyed. The\n * `ResponderEventPlugin` will populate it appropriately.\n */\nvar ResponderEventInterface = {\n  touchHistory: function(nativeEvent) {\n    return null; // Actually doesn't even look at the native event.\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native event.\n * @extends {SyntheticEvent}\n */\nfunction ResponderSyntheticEvent(\n  dispatchConfig,\n  dispatchMarker,\n  nativeEvent,\n  nativeEventTarget\n) {\n  return SyntheticEvent$1.call(\n    this,\n    dispatchConfig,\n    dispatchMarker,\n    nativeEvent,\n    nativeEventTarget\n  );\n}\n\nSyntheticEvent$1.augmentClass(ResponderSyntheticEvent, ResponderEventInterface);\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\n\nvar MAX_TOUCH_BANK = 20;\nvar touchBank = [];\nvar touchHistory = {\n  touchBank: touchBank,\n  numberActiveTouches: 0,\n  // If there is only one active touch, we remember its location. This prevents\n  // us having to loop through all of the touches all the time in the most\n  // common case.\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0\n};\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\". Let both work for now while we iron it out\n  // TODO (evv): rename timeStamp to timestamp in internal code\n  return touch.timeStamp || touch.timestamp;\n}\n\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  invariant(identifier != null, \"Touch object is missing identifier.\");\n  {\n    warning(\n      identifier <= MAX_TOUCH_BANK,\n      \"Touch identifier %s is greater than maximum supported %s which causes \" +\n        \"performance issues backfilling array locations for all of the indices.\",\n      identifier,\n      MAX_TOUCH_BANK\n    );\n  }\n  return identifier;\n}\n\nfunction recordTouchStart(touch) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchBank[identifier];\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error(\n      \"Cannot record touch move without a touch start.\\n\" + \"Touch Move: %s\\n\",\n      \"Touch Bank: %s\",\n      printTouch(touch),\n      printTouchBank()\n    );\n  }\n}\n\nfunction recordTouchEnd(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error(\n      \"Cannot record touch end without a touch start.\\n\" + \"Touch End: %s\\n\",\n      \"Touch Bank: %s\",\n      printTouch(touch),\n      printTouchBank()\n    );\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank() {\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += \" (original size: \" + touchBank.length + \")\";\n  }\n  return printed;\n}\n\nvar ResponderTouchHistoryStore = {\n  recordTouchTrack: function(topLevelType, nativeEvent) {\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch =\n          nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n        {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n          warning(\n            activeRecord != null && activeRecord.touchActive,\n            \"Cannot find single active touch.\"\n          );\n        }\n      }\n    }\n  },\n\n  touchHistory: touchHistory\n};\n\n/**\n * Accumulates items that must not be null or undefined.\n *\n * This is used to conserve memory by avoiding array allocations.\n *\n * @return {*|array<*>} An accumulation of items.\n */\nfunction accumulate(current, next) {\n  invariant(\n    next != null,\n    \"accumulate(...): Accumulated items must be not be null or undefined.\"\n  );\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    return current.concat(next);\n  }\n\n  if (Array.isArray(next)) {\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * Instance of element that should respond to touch/move types of interactions,\n * as indicated explicitly by relevant callbacks.\n */\nvar responderInst = null;\n\n/**\n * Count of current touches. A textInput should become responder iff the\n * selection changes while there is a touch on the screen.\n */\nvar trackedTouchCount = 0;\n\n/**\n * Last reported number of active touches.\n */\nvar previousActiveTouches = 0;\n\nvar changeResponder = function(nextResponderInst, blockHostResponder) {\n  var oldResponderInst = responderInst;\n  responderInst = nextResponderInst;\n  if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n    ResponderEventPlugin.GlobalResponderHandler.onChange(\n      oldResponderInst,\n      nextResponderInst,\n      blockHostResponder\n    );\n  }\n};\n\nvar eventTypes = {\n  /**\n   * On a `touchStart`/`mouseDown`, is it desired that this element become the\n   * responder?\n   */\n  startShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onStartShouldSetResponder\",\n      captured: \"onStartShouldSetResponderCapture\"\n    }\n  },\n\n  /**\n   * On a `scroll`, is it desired that this element become the responder? This\n   * is usually not needed, but should be used to retroactively infer that a\n   * `touchStart` had occurred during momentum scroll. During a momentum scroll,\n   * a touch start will be immediately followed by a scroll event if the view is\n   * currently scrolling.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  scrollShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onScrollShouldSetResponder\",\n      captured: \"onScrollShouldSetResponderCapture\"\n    }\n  },\n\n  /**\n   * On text selection change, should this element become the responder? This\n   * is needed for text inputs or other views with native selection, so the\n   * JS view can claim the responder.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  selectionChangeShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onSelectionChangeShouldSetResponder\",\n      captured: \"onSelectionChangeShouldSetResponderCapture\"\n    }\n  },\n\n  /**\n   * On a `touchMove`/`mouseMove`, is it desired that this element become the\n   * responder?\n   */\n  moveShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: \"onMoveShouldSetResponder\",\n      captured: \"onMoveShouldSetResponderCapture\"\n    }\n  },\n\n  /**\n   * Direct responder events dispatched directly to responder. Do not bubble.\n   */\n  responderStart: { registrationName: \"onResponderStart\" },\n  responderMove: { registrationName: \"onResponderMove\" },\n  responderEnd: { registrationName: \"onResponderEnd\" },\n  responderRelease: { registrationName: \"onResponderRelease\" },\n  responderTerminationRequest: {\n    registrationName: \"onResponderTerminationRequest\"\n  },\n  responderGrant: { registrationName: \"onResponderGrant\" },\n  responderReject: { registrationName: \"onResponderReject\" },\n  responderTerminate: { registrationName: \"onResponderTerminate\" }\n};\n\n/**\n *\n * Responder System:\n * ----------------\n *\n * - A global, solitary \"interaction lock\" on a view.\n * - If a node becomes the responder, it should convey visual feedback\n *   immediately to indicate so, either by highlighting or moving accordingly.\n * - To be the responder means, that touches are exclusively important to that\n *   responder view, and no other view.\n * - While touches are still occurring, the responder lock can be transferred to\n *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\n *   the current responder).\n *\n * Responder being granted:\n * ------------------------\n *\n * - Touch starts, moves, and scrolls can cause an ID to become the responder.\n * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\n *   the \"appropriate place\".\n * - If nothing is currently the responder, the \"appropriate place\" is the\n *   initiating event's `targetID`.\n * - If something *is* already the responder, the \"appropriate place\" is the\n *   first common ancestor of the event target and the current `responderInst`.\n * - Some negotiation happens: See the timing diagram below.\n * - Scrolled views automatically become responder. The reasoning is that a\n *   platform scroll view that isn't built on top of the responder system has\n *   began scrolling, and the active responder must now be notified that the\n *   interaction is no longer locked to it - the system has taken over.\n *\n * - Responder being released:\n *   As soon as no more touches that *started* inside of descendants of the\n *   *current* responderInst, an `onResponderRelease` event is dispatched to the\n *   current responder, and the responder lock is released.\n *\n * TODO:\n * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\n *   determines if the responder lock should remain.\n * - If a view shouldn't \"remain\" the responder, any active touches should by\n *   default be considered \"dead\" and do not influence future negotiations or\n *   bubble paths. It should be as if those touches do not exist.\n * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\n *  after one out of many touches ended. For translate-y, usually the view\n *  doesn't wish to \"remain\" responder after one of many touches end.\n * - Consider building this on top of a `stopPropagation` model similar to\n *   `W3C` events.\n * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\n *   not `onResponderTerminationRequest` returns `true` or `false`.\n *\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchStart|           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderRejec|\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\n/**\n * A note about event ordering in the `EventPluginHub`.\n *\n * Suppose plugins are injected in the following order:\n *\n * `[R, S, C]`\n *\n * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\n * `onClick` etc) and `R` is `ResponderEventPlugin`.\n *\n * \"Deferred-Dispatched Events\":\n *\n * - The current event plugin system will traverse the list of injected plugins,\n *   in order, and extract events by collecting the plugin's return value of\n *   `extractEvents()`.\n * - These events that are returned from `extractEvents` are \"deferred\n *   dispatched events\".\n * - When returned from `extractEvents`, deferred-dispatched events contain an\n *   \"accumulation\" of deferred dispatches.\n * - These deferred dispatches are accumulated/collected before they are\n *   returned, but processed at a later time by the `EventPluginHub` (hence the\n *   name deferred).\n *\n * In the process of returning their deferred-dispatched events, event plugins\n * themselves can dispatch events on-demand without returning them from\n * `extractEvents`. Plugins might want to do this, so that they can use event\n * dispatching as a tool that helps them decide which events should be extracted\n * in the first place.\n *\n * \"On-Demand-Dispatched Events\":\n *\n * - On-demand-dispatched events are not returned from `extractEvents`.\n * - On-demand-dispatched events are dispatched during the process of returning\n *   the deferred-dispatched events.\n * - They should not have side effects.\n * - They should be avoided, and/or eventually be replaced with another\n *   abstraction that allows event plugins to perform multiple \"rounds\" of event\n *   extraction.\n *\n * Therefore, the sequence of event dispatches becomes:\n *\n * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\n * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\n * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\n * - `R`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `S`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `C`s extracted events (if any)   (dispatched by `EventPluginHub`)\n *\n * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\n * on-demand dispatch returns `true` (and some other details are satisfied) the\n * `onResponderGrant` deferred dispatched event is returned from\n * `extractEvents`. The sequence of dispatch executions in this case\n * will appear as follows:\n *\n * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\n * - `touchStartCapture`       (`EventPluginHub` dispatches as usual)\n * - `touchStart`              (`EventPluginHub` dispatches as usual)\n * - `responderGrant/Reject`   (`EventPluginHub` dispatches as usual)\n */\n\nfunction setResponderAndExtractTransfer(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var shouldSetEventType = isStartish(topLevelType)\n    ? eventTypes.startShouldSetResponder\n    : isMoveish(topLevelType)\n      ? eventTypes.moveShouldSetResponder\n      : topLevelType === \"topSelectionChange\"\n        ? eventTypes.selectionChangeShouldSetResponder\n        : eventTypes.scrollShouldSetResponder;\n\n  // TODO: stop one short of the current responder.\n  var bubbleShouldSetFrom = !responderInst\n    ? targetInst\n    : getLowestCommonAncestor(responderInst, targetInst);\n\n  // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n  // (deepest ID) if it happens to be the current responder. The reasoning:\n  // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n  // the responder.\n  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n  var shouldSetEvent = ResponderSyntheticEvent.getPooled(\n    shouldSetEventType,\n    bubbleShouldSetFrom,\n    nativeEvent,\n    nativeEventTarget\n  );\n  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n  if (skipOverBubbleShouldSetFrom) {\n    accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n  } else {\n    accumulateTwoPhaseDispatches(shouldSetEvent);\n  }\n  var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n  if (!shouldSetEvent.isPersistent()) {\n    shouldSetEvent.constructor.release(shouldSetEvent);\n  }\n\n  if (!wantsResponderInst || wantsResponderInst === responderInst) {\n    return null;\n  }\n  var extracted;\n  var grantEvent = ResponderSyntheticEvent.getPooled(\n    eventTypes.responderGrant,\n    wantsResponderInst,\n    nativeEvent,\n    nativeEventTarget\n  );\n  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n  accumulateDirectDispatches(grantEvent);\n  var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n  if (responderInst) {\n    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(\n      eventTypes.responderTerminationRequest,\n      responderInst,\n      nativeEvent,\n      nativeEventTarget\n    );\n    terminationRequestEvent.touchHistory =\n      ResponderTouchHistoryStore.touchHistory;\n    accumulateDirectDispatches(terminationRequestEvent);\n    var shouldSwitch =\n      !hasDispatches(terminationRequestEvent) ||\n      executeDirectDispatch(terminationRequestEvent);\n    if (!terminationRequestEvent.isPersistent()) {\n      terminationRequestEvent.constructor.release(terminationRequestEvent);\n    }\n\n    if (shouldSwitch) {\n      var terminateEvent = ResponderSyntheticEvent.getPooled(\n        eventTypes.responderTerminate,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(terminateEvent);\n      extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n      changeResponder(wantsResponderInst, blockHostResponder);\n    } else {\n      var rejectEvent = ResponderSyntheticEvent.getPooled(\n        eventTypes.responderReject,\n        wantsResponderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(rejectEvent);\n      extracted = accumulate(extracted, rejectEvent);\n    }\n  } else {\n    extracted = accumulate(extracted, grantEvent);\n    changeResponder(wantsResponderInst, blockHostResponder);\n  }\n  return extracted;\n}\n\n/**\n * A transfer is a negotiation between a currently set responder and the next\n * element to claim responder status. Any start event could trigger a transfer\n * of responderInst. Any move event could trigger a transfer.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @return {boolean} True if a transfer of responder could possibly occur.\n */\nfunction canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n  return (\n    topLevelInst &&\n    // responderIgnoreScroll: We are trying to migrate away from specifically\n    // tracking native scroll events here and responderIgnoreScroll indicates we\n    // will send topTouchCancel to handle canceling touch events instead\n    ((topLevelType === \"topScroll\" && !nativeEvent.responderIgnoreScroll) ||\n      (trackedTouchCount > 0 && topLevelType === \"topSelectionChange\") ||\n      isStartish(topLevelType) ||\n      isMoveish(topLevelType))\n  );\n}\n\n/**\n * Returns whether or not this touch end event makes it such that there are no\n * longer any touches that started inside of the current `responderInst`.\n *\n * @param {NativeEvent} nativeEvent Native touch end event.\n * @return {boolean} Whether or not this touch end event ends the responder.\n */\nfunction noResponderTouches(nativeEvent) {\n  var touches = nativeEvent.touches;\n  if (!touches || touches.length === 0) {\n    return true;\n  }\n  for (var i = 0; i < touches.length; i++) {\n    var activeTouch = touches[i];\n    var target = activeTouch.target;\n    if (target !== null && target !== undefined && target !== 0) {\n      // Is the original touch location inside of the current responder?\n      var targetInst = getInstanceFromNode(target);\n      if (isAncestor(responderInst, targetInst)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvar ResponderEventPlugin = {\n  /* For unit testing only */\n  _getResponder: function() {\n    return responderInst;\n  },\n\n  eventTypes: eventTypes,\n\n  /**\n   * We must be resilient to `targetInst` being `null` on `touchMove` or\n   * `touchEnd`. On certain platforms, this means that a native scroll has\n   * assumed control and the original touch targets are destroyed.\n   */\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    if (isStartish(topLevelType)) {\n      trackedTouchCount += 1;\n    } else if (isEndish(topLevelType)) {\n      if (trackedTouchCount >= 0) {\n        trackedTouchCount -= 1;\n      } else {\n        console.error(\n          \"Ended a touch event which was not counted in `trackedTouchCount`.\"\n        );\n        return null;\n      }\n    }\n\n    ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n\n    var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent)\n      ? setResponderAndExtractTransfer(\n          topLevelType,\n          targetInst,\n          nativeEvent,\n          nativeEventTarget\n        )\n      : null;\n    // Responder may or may not have transferred on a new touch start/move.\n    // Regardless, whoever is the responder after any potential transfer, we\n    // direct all touch start/move/ends to them in the form of\n    // `onResponderMove/Start/End`. These will be called for *every* additional\n    // finger that move/start/end, dispatched directly to whoever is the\n    // current responder at that moment, until the responder is \"released\".\n    //\n    // These multiple individual change touch events are are always bookended\n    // by `onResponderGrant`, and one of\n    // (`onResponderRelease/onResponderTerminate`).\n    var isResponderTouchStart = responderInst && isStartish(topLevelType);\n    var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n    var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n    var incrementalTouch = isResponderTouchStart\n      ? eventTypes.responderStart\n      : isResponderTouchMove\n        ? eventTypes.responderMove\n        : isResponderTouchEnd ? eventTypes.responderEnd : null;\n\n    if (incrementalTouch) {\n      var gesture = ResponderSyntheticEvent.getPooled(\n        incrementalTouch,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(gesture);\n      extracted = accumulate(extracted, gesture);\n    }\n\n    var isResponderTerminate =\n      responderInst && topLevelType === \"topTouchCancel\";\n    var isResponderRelease =\n      responderInst &&\n      !isResponderTerminate &&\n      isEndish(topLevelType) &&\n      noResponderTouches(nativeEvent);\n    var finalTouch = isResponderTerminate\n      ? eventTypes.responderTerminate\n      : isResponderRelease ? eventTypes.responderRelease : null;\n    if (finalTouch) {\n      var finalEvent = ResponderSyntheticEvent.getPooled(\n        finalTouch,\n        responderInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n      finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(finalEvent);\n      extracted = accumulate(extracted, finalEvent);\n      changeResponder(null);\n    }\n\n    var numberActiveTouches =\n      ResponderTouchHistoryStore.touchHistory.numberActiveTouches;\n    if (\n      ResponderEventPlugin.GlobalInteractionHandler &&\n      numberActiveTouches !== previousActiveTouches\n    ) {\n      ResponderEventPlugin.GlobalInteractionHandler.onChange(\n        numberActiveTouches\n      );\n    }\n    previousActiveTouches = numberActiveTouches;\n\n    return extracted;\n  },\n\n  GlobalResponderHandler: null,\n  GlobalInteractionHandler: null,\n\n  injection: {\n    /**\n     * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\n     * Object that handles any change in responder. Use this to inject\n     * integration with an existing touch handling system etc.\n     */\n    injectGlobalResponderHandler: function(GlobalResponderHandler) {\n      ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n    },\n\n    /**\n     * @param {{onChange: (numberActiveTouches) => void} GlobalInteractionHandler\n     * Object that handles any change in the number of active touches.\n     */\n    injectGlobalInteractionHandler: function(GlobalInteractionHandler) {\n      ResponderEventPlugin.GlobalInteractionHandler = GlobalInteractionHandler;\n    }\n  }\n};\n\nvar customBubblingEventTypes = {};\nvar customDirectEventTypes = {};\n\nvar ReactNativeBridgeEventPlugin = {\n  eventTypes: {},\n\n  /**\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    var bubbleDispatchConfig = customBubblingEventTypes[topLevelType];\n    var directDispatchConfig = customDirectEventTypes[topLevelType];\n    invariant(\n      bubbleDispatchConfig || directDispatchConfig,\n      'Unsupported top level event type \"%s\" dispatched',\n      topLevelType\n    );\n    var event = SyntheticEvent$1.getPooled(\n      bubbleDispatchConfig || directDispatchConfig,\n      targetInst,\n      nativeEvent,\n      nativeEventTarget\n    );\n    if (bubbleDispatchConfig) {\n      accumulateTwoPhaseDispatches(event);\n    } else if (directDispatchConfig) {\n      accumulateDirectDispatches(event);\n    } else {\n      return null;\n    }\n    return event;\n  },\n\n  processEventTypes: function(viewConfig) {\n    var bubblingEventTypes = viewConfig.bubblingEventTypes,\n      directEventTypes = viewConfig.directEventTypes;\n\n    {\n      if (bubblingEventTypes != null && directEventTypes != null) {\n        for (var topLevelType in directEventTypes) {\n          invariant(\n            bubblingEventTypes[topLevelType] == null,\n            \"Event cannot be both direct and bubbling: %s\",\n            topLevelType\n          );\n        }\n      }\n    }\n\n    if (bubblingEventTypes != null) {\n      for (var _topLevelType in bubblingEventTypes) {\n        if (customBubblingEventTypes[_topLevelType] == null) {\n          ReactNativeBridgeEventPlugin.eventTypes[\n            _topLevelType\n          ] = customBubblingEventTypes[_topLevelType] =\n            bubblingEventTypes[_topLevelType];\n        }\n      }\n    }\n\n    if (directEventTypes != null) {\n      for (var _topLevelType2 in directEventTypes) {\n        if (customDirectEventTypes[_topLevelType2] == null) {\n          ReactNativeBridgeEventPlugin.eventTypes[\n            _topLevelType2\n          ] = customDirectEventTypes[_topLevelType2] =\n            directEventTypes[_topLevelType2];\n        }\n      }\n    }\n  }\n};\n\nvar instanceCache = {};\nvar instanceProps = {};\n\nfunction precacheFiberNode(hostInst, tag) {\n  instanceCache[tag] = hostInst;\n}\n\nfunction uncacheFiberNode(tag) {\n  delete instanceCache[tag];\n  delete instanceProps[tag];\n}\n\nfunction getInstanceFromTag(tag) {\n  return instanceCache[tag] || null;\n}\n\nfunction getTagFromInstance(inst) {\n  var tag = inst.stateNode._nativeTag;\n  invariant(tag, \"All native instances should have a tag.\");\n  return tag;\n}\n\nfunction getFiberCurrentPropsFromNode$1(stateNode) {\n  return instanceProps[stateNode._nativeTag] || null;\n}\n\nfunction updateFiberProps(tag, props) {\n  instanceProps[tag] = props;\n}\n\nvar ReactNativeComponentTree = Object.freeze({\n  precacheFiberNode: precacheFiberNode,\n  uncacheFiberNode: uncacheFiberNode,\n  getClosestInstanceFromNode: getInstanceFromTag,\n  getInstanceFromNode: getInstanceFromTag,\n  getNodeFromInstance: getTagFromInstance,\n  getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,\n  updateFiberProps: updateFiberProps\n});\n\n// Use to restore controlled state after a change event has fired.\n\nvar fiberHostComponent = null;\n\nvar restoreTarget = null;\nvar restoreQueue = null;\n\nfunction restoreStateOfTarget(target) {\n  // We perform this translation at the end of the event loop so that we\n  // always receive the correct fiber here\n  var internalInstance = getInstanceFromNode(target);\n  if (!internalInstance) {\n    // Unmounted\n    return;\n  }\n  invariant(\n    fiberHostComponent &&\n      typeof fiberHostComponent.restoreControlledState === \"function\",\n    \"Fiber needs to be injected to handle a fiber target for controlled \" +\n      \"events. This error is likely caused by a bug in React. Please file an issue.\"\n  );\n  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n  fiberHostComponent.restoreControlledState(\n    internalInstance.stateNode,\n    internalInstance.type,\n    props\n  );\n}\n\nfunction restoreStateIfNeeded() {\n  if (!restoreTarget) {\n    return;\n  }\n  var target = restoreTarget;\n  var queuedTargets = restoreQueue;\n  restoreTarget = null;\n  restoreQueue = null;\n\n  restoreStateOfTarget(target);\n  if (queuedTargets) {\n    for (var i = 0; i < queuedTargets.length; i++) {\n      restoreStateOfTarget(queuedTargets[i]);\n    }\n  }\n}\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nvar fiberBatchedUpdates = function(fn, bookkeeping) {\n  return fn(bookkeeping);\n};\n\nvar isNestingBatched = false;\nfunction batchedUpdates(fn, bookkeeping) {\n  if (isNestingBatched) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state. Therefore, we add the target to\n    // a queue of work.\n    return fiberBatchedUpdates(fn, bookkeeping);\n  }\n  isNestingBatched = true;\n  try {\n    return fiberBatchedUpdates(fn, bookkeeping);\n  } finally {\n    // Here we wait until all updates have propagated, which is important\n    // when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    // Then we restore state of any controlled component.\n    isNestingBatched = false;\n    restoreStateIfNeeded();\n  }\n}\n\nvar ReactGenericBatchingInjection = {\n  injectFiberBatchedUpdates: function(_batchedUpdates) {\n    fiberBatchedUpdates = _batchedUpdates;\n  }\n};\n\nvar injection$2 = ReactGenericBatchingInjection;\n\nfunction runEventQueueInBatch(events) {\n  enqueueEvents(events);\n  processEventQueue(false);\n}\n\n/**\n * Streams a fired top-level event to `EventPluginHub` where plugins have the\n * opportunity to create `ReactEvent`s to be dispatched.\n */\nfunction handleTopLevel(\n  topLevelType,\n  targetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  var events = extractEvents(\n    topLevelType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  );\n  runEventQueueInBatch(events);\n}\n\n/**\n * Keeps track of allocating and associating native \"tags\" which are numeric,\n * unique view IDs. All the native tags are negative numbers, to avoid\n * collisions, but in the JS we keep track of them as positive integers to store\n * them effectively in Arrays. So we must refer to them as \"inverses\" of the\n * native tags (that are * normally negative).\n *\n * It *must* be the case that every `rootNodeID` always maps to the exact same\n * `tag` forever. The easiest way to accomplish this is to never delete\n * anything from this table.\n * Why: Because `dangerouslyReplaceNodeWithMarkupByID` relies on being able to\n * unmount a component with a `rootNodeID`, then mount a new one in its place,\n */\nvar INITIAL_TAG_COUNT = 1;\nvar ReactNativeTagHandles = {\n  tagsStartAt: INITIAL_TAG_COUNT,\n  tagCount: INITIAL_TAG_COUNT,\n\n  allocateTag: function() {\n    // Skip over root IDs as those are reserved for native\n    while (this.reactTagIsNativeTopRootID(ReactNativeTagHandles.tagCount)) {\n      ReactNativeTagHandles.tagCount++;\n    }\n    var tag = ReactNativeTagHandles.tagCount;\n    ReactNativeTagHandles.tagCount++;\n    return tag;\n  },\n\n  assertRootTag: function(tag) {\n    invariant(\n      this.reactTagIsNativeTopRootID(tag),\n      \"Expect a native root tag, instead got %s\",\n      tag\n    );\n  },\n\n  reactTagIsNativeTopRootID: function(reactTag) {\n    // We reserve all tags that are 1 mod 10 for native root views\n    return reactTag % 10 === 1;\n  }\n};\n\n/**\n * Version of `ReactBrowserEventEmitter` that works on the receiving side of a\n * serialized worker boundary.\n */\n\n// Shared default empty native event - conserve memory.\nvar EMPTY_NATIVE_EVENT = {};\n\n/**\n * Selects a subsequence of `Touch`es, without destroying `touches`.\n *\n * @param {Array<Touch>} touches Deserialized touch objects.\n * @param {Array<number>} indices Indices by which to pull subsequence.\n * @return {Array<Touch>} Subsequence of touch objects.\n */\nvar touchSubsequence = function(touches, indices) {\n  var ret = [];\n  for (var i = 0; i < indices.length; i++) {\n    ret.push(touches[indices[i]]);\n  }\n  return ret;\n};\n\n/**\n * TODO: Pool all of this.\n *\n * Destroys `touches` by removing touch objects at indices `indices`. This is\n * to maintain compatibility with W3C touch \"end\" events, where the active\n * touches don't include the set that has just been \"ended\".\n *\n * @param {Array<Touch>} touches Deserialized touch objects.\n * @param {Array<number>} indices Indices to remove from `touches`.\n * @return {Array<Touch>} Subsequence of removed touch objects.\n */\nvar removeTouchesAtIndices = function(touches, indices) {\n  var rippedOut = [];\n  // use an unsafe downcast to alias to nullable elements,\n  // so we can delete and then compact.\n  var temp = touches;\n  for (var i = 0; i < indices.length; i++) {\n    var index = indices[i];\n    rippedOut.push(touches[index]);\n    temp[index] = null;\n  }\n  var fillAt = 0;\n  for (var j = 0; j < temp.length; j++) {\n    var cur = temp[j];\n    if (cur !== null) {\n      temp[fillAt++] = cur;\n    }\n  }\n  temp.length = fillAt;\n  return rippedOut;\n};\n\n/**\n * Internal version of `receiveEvent` in terms of normalized (non-tag)\n * `rootNodeID`.\n *\n * @see receiveEvent.\n *\n * @param {rootNodeID} rootNodeID React root node ID that event occurred on.\n * @param {TopLevelType} topLevelType Top level type of event.\n * @param {?object} nativeEventParam Object passed from native.\n */\nfunction _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {\n  var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT;\n  var inst = getInstanceFromTag(rootNodeID);\n  batchedUpdates(function() {\n    handleTopLevel(topLevelType, inst, nativeEvent, nativeEvent.target);\n  });\n  // React Native doesn't use ReactControlledComponent but if it did, here's\n  // where it would do it.\n}\n\n/**\n * Publicly exposed method on module for native objc to invoke when a top\n * level event is extracted.\n * @param {rootNodeID} rootNodeID React root node ID that event occurred on.\n * @param {TopLevelType} topLevelType Top level type of event.\n * @param {object} nativeEventParam Object passed from native.\n */\nfunction receiveEvent(rootNodeID, topLevelType, nativeEventParam) {\n  _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);\n}\n\n/**\n * Simple multi-wrapper around `receiveEvent` that is intended to receive an\n * efficient representation of `Touch` objects, and other information that\n * can be used to construct W3C compliant `Event` and `Touch` lists.\n *\n * This may create dispatch behavior that differs than web touch handling. We\n * loop through each of the changed touches and receive it as a single event.\n * So two `touchStart`/`touchMove`s that occur simultaneously are received as\n * two separate touch event dispatches - when they arguably should be one.\n *\n * This implementation reuses the `Touch` objects themselves as the `Event`s\n * since we dispatch an event for each touch (though that might not be spec\n * compliant). The main purpose of reusing them is to save allocations.\n *\n * TODO: Dispatch multiple changed touches in one event. The bubble path\n * could be the first common ancestor of all the `changedTouches`.\n *\n * One difference between this behavior and W3C spec: cancelled touches will\n * not appear in `.touches`, or in any future `.touches`, though they may\n * still be \"actively touching the surface\".\n *\n * Web desktop polyfills only need to construct a fake touch event with\n * identifier 0, also abandoning traditional click handlers.\n */\nfunction receiveTouches(eventTopLevelType, touches, changedIndices) {\n  var changedTouches =\n    eventTopLevelType === \"topTouchEnd\" ||\n    eventTopLevelType === \"topTouchCancel\"\n      ? removeTouchesAtIndices(touches, changedIndices)\n      : touchSubsequence(touches, changedIndices);\n\n  for (var jj = 0; jj < changedTouches.length; jj++) {\n    var touch = changedTouches[jj];\n    // Touch objects can fulfill the role of `DOM` `Event` objects if we set\n    // the `changedTouches`/`touches`. This saves allocations.\n    touch.changedTouches = changedTouches;\n    touch.touches = touches;\n    var nativeEvent = touch;\n    var rootNodeID = null;\n    var target = nativeEvent.target;\n    if (target !== null && target !== undefined) {\n      if (target < ReactNativeTagHandles.tagsStartAt) {\n        {\n          warning(\n            false,\n            \"A view is reporting that a touch occurred on tag zero.\"\n          );\n        }\n      } else {\n        rootNodeID = target;\n      }\n    }\n    // $FlowFixMe Shouldn't we *not* call it if rootNodeID is null?\n    _receiveRootNodeIDEvent(rootNodeID, eventTopLevelType, nativeEvent);\n  }\n}\n\nvar ReactNativeEventEmitter = Object.freeze({\n  getListener: getListener,\n  registrationNames: registrationNameModules,\n  _receiveRootNodeIDEvent: _receiveRootNodeIDEvent,\n  receiveEvent: receiveEvent,\n  receiveTouches: receiveTouches,\n  handleTopLevel: handleTopLevel\n});\n\nvar ReactNativeEventPluginOrder = [\n  \"ResponderEventPlugin\",\n  \"ReactNativeBridgeEventPlugin\"\n];\n\n// Module provided by RN:\nvar ReactNativeGlobalResponderHandler = {\n  onChange: function(from, to, blockNativeResponder) {\n    if (to !== null) {\n      var tag = to.stateNode._nativeTag;\n      UIManager.setJSResponder(tag, blockNativeResponder);\n    } else {\n      UIManager.clearJSResponder();\n    }\n  }\n};\n\n/**\n * Make sure essential globals are available and are patched correctly. Please don't remove this\n * line. Bundles created by react-packager `require` it before executing any application code. This\n * ensures it exists in the dependency graph and can be `require`d.\n * TODO: require this in packager, not in React #10932517\n */\n// Module provided by RN:\n// Module provided by RN:\n/**\n * Register the event emitter with the native bridge\n */\nRCTEventEmitter.register(ReactNativeEventEmitter);\n\n/**\n * Inject module for resolving DOM hierarchy and plugin ordering.\n */\ninjection.injectEventPluginOrder(ReactNativeEventPluginOrder);\ninjection$1.injectComponentTree(ReactNativeComponentTree);\n\nResponderEventPlugin.injection.injectGlobalResponderHandler(\n  ReactNativeGlobalResponderHandler\n);\n\n/**\n * Some important event plugins included by default (without having to require\n * them).\n */\ninjection.injectEventPluginsByName({\n  ResponderEventPlugin: ResponderEventPlugin,\n  ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin\n});\n\nvar defaultShowDialog = function(capturedError) {\n  return true;\n};\n\nvar showDialog = defaultShowDialog;\n\nfunction logCapturedError(capturedError) {\n  var logError = showDialog(capturedError);\n\n  // Allow injected showDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  var error = capturedError.error;\n  var suppressLogging = error && error.suppressReactErrorLogging;\n  if (suppressLogging) {\n    return;\n  }\n\n  {\n    var componentName = capturedError.componentName,\n      componentStack = capturedError.componentStack,\n      errorBoundaryName = capturedError.errorBoundaryName,\n      errorBoundaryFound = capturedError.errorBoundaryFound,\n      willRetry = capturedError.willRetry;\n\n    var componentNameMessage = componentName\n      ? \"The above error occurred in the <\" + componentName + \"> component:\"\n      : \"The above error occurred in one of your React components:\";\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage =\n          \"React will try to recreate this component tree from scratch \" +\n          (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n      } else {\n        errorBoundaryMessage =\n          \"This error was initially handled by the error boundary \" +\n          errorBoundaryName +\n          \".\\n\" +\n          \"Recreating the tree from scratch failed so React will unmount the tree.\";\n      }\n    } else {\n      errorBoundaryMessage =\n        \"Consider adding an error boundary to your tree to customize error handling behavior.\\n\" +\n        \"Visit https://fb.me/react-error-boundaries to learn more about error boundaries.\";\n    }\n    var combinedMessage =\n      \"\" +\n      componentNameMessage +\n      componentStack +\n      \"\\n\\n\" +\n      (\"\" + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar injection$4 = {\n  /**\n   * Display custom dialog for lifecycle errors.\n   * Return false to prevent default behavior of logging to console.error.\n   */\n  injectDialog: function(fn) {\n    invariant(\n      showDialog === defaultShowDialog,\n      \"The custom dialog was already injected.\"\n    );\n    invariant(\n      typeof fn === \"function\",\n      \"Injected showDialog() must be a function.\"\n    );\n    showDialog = fn;\n  }\n};\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === \"function\" && Symbol[\"for\"];\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol[\"for\"](\"react.element\") : 0xeac7;\nvar REACT_CALL_TYPE = hasSymbol ? Symbol[\"for\"](\"react.call\") : 0xeac8;\nvar REACT_RETURN_TYPE = hasSymbol ? Symbol[\"for\"](\"react.return\") : 0xeac9;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol[\"for\"](\"react.portal\") : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol[\"for\"](\"react.fragment\") : 0xeacb;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === \"undefined\") {\n    return null;\n  }\n  var maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === \"function\") {\n    return maybeIterator;\n  }\n  return null;\n}\n\nfunction createPortal(\n  children,\n  containerInfo,\n  // TODO: figure out the API for cross-renderer implementation.\n  implementation\n) {\n  var key =\n    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : \"\" + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\nvar TouchHistoryMath = {\n  /**\n   * This code is optimized and not intended to look beautiful. This allows\n   * computing of touch centroids that have moved after `touchesChangedAfter`\n   * timeStamp. You can compute the current centroid involving all touches\n   * moves after `touchesChangedAfter`, or you can compute the previous\n   * centroid of all touches that were moved after `touchesChangedAfter`.\n   *\n   * @param {TouchHistoryMath} touchHistory Standard Responder touch track\n   * data.\n   * @param {number} touchesChangedAfter timeStamp after which moved touches\n   * are considered \"actively moving\" - not just \"active\".\n   * @param {boolean} isXAxis Consider `x` dimension vs. `y` dimension.\n   * @param {boolean} ofCurrent Compute current centroid for actively moving\n   * touches vs. previous centroid of now actively moving touches.\n   * @return {number} value of centroid in specified dimension.\n   */\n  centroidDimension: function(\n    touchHistory,\n    touchesChangedAfter,\n    isXAxis,\n    ofCurrent\n  ) {\n    var touchBank = touchHistory.touchBank;\n    var total = 0;\n    var count = 0;\n\n    var oneTouchData =\n      touchHistory.numberActiveTouches === 1\n        ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch]\n        : null;\n\n    if (oneTouchData !== null) {\n      if (\n        oneTouchData.touchActive &&\n        oneTouchData.currentTimeStamp > touchesChangedAfter\n      ) {\n        total +=\n          ofCurrent && isXAxis\n            ? oneTouchData.currentPageX\n            : ofCurrent && !isXAxis\n              ? oneTouchData.currentPageY\n              : !ofCurrent && isXAxis\n                ? oneTouchData.previousPageX\n                : oneTouchData.previousPageY;\n        count = 1;\n      }\n    } else {\n      for (var i = 0; i < touchBank.length; i++) {\n        var touchTrack = touchBank[i];\n        if (\n          touchTrack !== null &&\n          touchTrack !== undefined &&\n          touchTrack.touchActive &&\n          touchTrack.currentTimeStamp >= touchesChangedAfter\n        ) {\n          var toAdd; // Yuck, program temporarily in invalid state.\n          if (ofCurrent && isXAxis) {\n            toAdd = touchTrack.currentPageX;\n          } else if (ofCurrent && !isXAxis) {\n            toAdd = touchTrack.currentPageY;\n          } else if (!ofCurrent && isXAxis) {\n            toAdd = touchTrack.previousPageX;\n          } else {\n            toAdd = touchTrack.previousPageY;\n          }\n          total += toAdd;\n          count++;\n        }\n      }\n    }\n    return count > 0 ? total / count : TouchHistoryMath.noCentroid;\n  },\n\n  currentCentroidXOfTouchesChangedAfter: function(\n    touchHistory,\n    touchesChangedAfter\n  ) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      touchesChangedAfter,\n      true, // isXAxis\n      true\n    );\n  },\n\n  currentCentroidYOfTouchesChangedAfter: function(\n    touchHistory,\n    touchesChangedAfter\n  ) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      touchesChangedAfter,\n      false, // isXAxis\n      true\n    );\n  },\n\n  previousCentroidXOfTouchesChangedAfter: function(\n    touchHistory,\n    touchesChangedAfter\n  ) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      touchesChangedAfter,\n      true, // isXAxis\n      false\n    );\n  },\n\n  previousCentroidYOfTouchesChangedAfter: function(\n    touchHistory,\n    touchesChangedAfter\n  ) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      touchesChangedAfter,\n      false, // isXAxis\n      false\n    );\n  },\n\n  currentCentroidX: function(touchHistory) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      0, // touchesChangedAfter\n      true, // isXAxis\n      true\n    );\n  },\n\n  currentCentroidY: function(touchHistory) {\n    return TouchHistoryMath.centroidDimension(\n      touchHistory,\n      0, // touchesChangedAfter\n      false, // isXAxis\n      true\n    );\n  },\n\n  noCentroid: -1\n};\n\nvar ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n\nvar ReactGlobalSharedState = Object.freeze({\n  ReactCurrentOwner: ReactCurrentOwner,\n  ReactDebugCurrentFrame: ReactDebugCurrentFrame\n});\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = \"16.2.0\";\n\n// Module provided by RN:\n/**\n * Intercept lifecycle errors and ensure they are shown with the correct stack\n * trace within the native redbox component.\n */\nfunction showDialog$1(capturedError) {\n  var componentStack = capturedError.componentStack,\n    error = capturedError.error;\n\n  var errorToHandle = void 0;\n\n  // Typically Errors are thrown but eg strings or null can be thrown as well.\n  if (error instanceof Error) {\n    var message = error.message,\n      name = error.name;\n\n    var summary = message ? name + \": \" + message : name;\n\n    errorToHandle = error;\n\n    try {\n      errorToHandle.message =\n        summary + \"\\n\\nThis error is located at:\" + componentStack;\n    } catch (e) {}\n  } else if (typeof error === \"string\") {\n    errorToHandle = new Error(\n      error + \"\\n\\nThis error is located at:\" + componentStack\n    );\n  } else {\n    errorToHandle = new Error(\"Unspecified error at:\" + componentStack);\n  }\n\n  ExceptionsManager.handleException(errorToHandle, false);\n\n  // Return false here to prevent ReactFiberErrorLogger default behavior of\n  // logging error details to console.error. Calls to console.error are\n  // automatically routed to the native redbox controller, which we've already\n  // done above by calling ExceptionsManager.\n  return false;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar objects = {};\nvar uniqueID = 1;\nvar emptyObject$2 = {};\n\nvar ReactNativePropRegistry = (function() {\n  function ReactNativePropRegistry() {\n    _classCallCheck(this, ReactNativePropRegistry);\n  }\n\n  ReactNativePropRegistry.register = function register(object) {\n    var id = ++uniqueID;\n    {\n      Object.freeze(object);\n    }\n    objects[id] = object;\n    return id;\n  };\n\n  ReactNativePropRegistry.getByID = function getByID(id) {\n    if (!id) {\n      // Used in the style={[condition && id]} pattern,\n      // we want it to be a no-op when the value is false or null\n      return emptyObject$2;\n    }\n\n    var object = objects[id];\n    if (!object) {\n      console.warn(\"Invalid style with id `\" + id + \"`. Skipping ...\");\n      return emptyObject$2;\n    }\n    return object;\n  };\n\n  return ReactNativePropRegistry;\n})();\n\n// Modules provided by RN:\nvar emptyObject$1 = {};\n\n/**\n * Create a payload that contains all the updates between two sets of props.\n *\n * These helpers are all encapsulated into a single module, because they use\n * mutation as a performance optimization which leads to subtle shared\n * dependencies between the code paths. To avoid this mutable state leaking\n * across modules, I've kept them isolated to this module.\n */\n\n// Tracks removed keys\nvar removedKeys = null;\nvar removedKeyCount = 0;\n\nfunction defaultDiffer(prevProp, nextProp) {\n  if (typeof nextProp !== \"object\" || nextProp === null) {\n    // Scalars have already been checked for equality\n    return true;\n  } else {\n    // For objects and arrays, the default diffing algorithm is a deep compare\n    return deepDiffer(prevProp, nextProp);\n  }\n}\n\nfunction resolveObject(idOrObject) {\n  if (typeof idOrObject === \"number\") {\n    return ReactNativePropRegistry.getByID(idOrObject);\n  }\n  return idOrObject;\n}\n\nfunction restoreDeletedValuesInNestedArray(\n  updatePayload,\n  node,\n  validAttributes\n) {\n  if (Array.isArray(node)) {\n    var i = node.length;\n    while (i-- && removedKeyCount > 0) {\n      restoreDeletedValuesInNestedArray(\n        updatePayload,\n        node[i],\n        validAttributes\n      );\n    }\n  } else if (node && removedKeyCount > 0) {\n    var obj = resolveObject(node);\n    for (var propKey in removedKeys) {\n      if (!removedKeys[propKey]) {\n        continue;\n      }\n      var nextProp = obj[propKey];\n      if (nextProp === undefined) {\n        continue;\n      }\n\n      var attributeConfig = validAttributes[propKey];\n      if (!attributeConfig) {\n        continue; // not a valid native prop\n      }\n\n      if (typeof nextProp === \"function\") {\n        nextProp = true;\n      }\n      if (typeof nextProp === \"undefined\") {\n        nextProp = null;\n      }\n\n      if (typeof attributeConfig !== \"object\") {\n        // case: !Object is the default case\n        updatePayload[propKey] = nextProp;\n      } else if (\n        typeof attributeConfig.diff === \"function\" ||\n        typeof attributeConfig.process === \"function\"\n      ) {\n        // case: CustomAttributeConfiguration\n        var nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      removedKeys[propKey] = false;\n      removedKeyCount--;\n    }\n  }\n}\n\nfunction diffNestedArrayProperty(\n  updatePayload,\n  prevArray,\n  nextArray,\n  validAttributes\n) {\n  var minLength =\n    prevArray.length < nextArray.length ? prevArray.length : nextArray.length;\n  var i;\n  for (i = 0; i < minLength; i++) {\n    // Diff any items in the array in the forward direction. Repeated keys\n    // will be overwritten by later values.\n    updatePayload = diffNestedProperty(\n      updatePayload,\n      prevArray[i],\n      nextArray[i],\n      validAttributes\n    );\n  }\n  for (; i < prevArray.length; i++) {\n    // Clear out all remaining properties.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevArray[i],\n      validAttributes\n    );\n  }\n  for (; i < nextArray.length; i++) {\n    // Add all remaining properties.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextArray[i],\n      validAttributes\n    );\n  }\n  return updatePayload;\n}\n\nfunction diffNestedProperty(\n  updatePayload,\n  prevProp,\n  nextProp,\n  validAttributes\n) {\n  if (!updatePayload && prevProp === nextProp) {\n    // If no properties have been added, then we can bail out quickly on object\n    // equality.\n    return updatePayload;\n  }\n\n  if (!prevProp || !nextProp) {\n    if (nextProp) {\n      return addNestedProperty(updatePayload, nextProp, validAttributes);\n    }\n    if (prevProp) {\n      return clearNestedProperty(updatePayload, prevProp, validAttributes);\n    }\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {\n    // Both are leaves, we can diff the leaves.\n    return diffProperties(\n      updatePayload,\n      resolveObject(prevProp),\n      resolveObject(nextProp),\n      validAttributes\n    );\n  }\n\n  if (Array.isArray(prevProp) && Array.isArray(nextProp)) {\n    // Both are arrays, we can diff the arrays.\n    return diffNestedArrayProperty(\n      updatePayload,\n      prevProp,\n      nextProp,\n      validAttributes\n    );\n  }\n\n  if (Array.isArray(prevProp)) {\n    return diffProperties(\n      updatePayload,\n      // $FlowFixMe - We know that this is always an object when the input is.\n      flattenStyle(prevProp),\n      // $FlowFixMe - We know that this isn't an array because of above flow.\n      resolveObject(nextProp),\n      validAttributes\n    );\n  }\n\n  return diffProperties(\n    updatePayload,\n    resolveObject(prevProp),\n    // $FlowFixMe - We know that this is always an object when the input is.\n    flattenStyle(nextProp),\n    validAttributes\n  );\n}\n\n/**\n * addNestedProperty takes a single set of props and valid attribute\n * attribute configurations. It processes each prop and adds it to the\n * updatePayload.\n */\nfunction addNestedProperty(updatePayload, nextProp, validAttributes) {\n  if (!nextProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(nextProp)) {\n    // Add each property of the leaf.\n    return addProperties(\n      updatePayload,\n      resolveObject(nextProp),\n      validAttributes\n    );\n  }\n\n  for (var i = 0; i < nextProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = addNestedProperty(\n      updatePayload,\n      nextProp[i],\n      validAttributes\n    );\n  }\n\n  return updatePayload;\n}\n\n/**\n * clearNestedProperty takes a single set of props and valid attributes. It\n * adds a null sentinel to the updatePayload, for each prop key.\n */\nfunction clearNestedProperty(updatePayload, prevProp, validAttributes) {\n  if (!prevProp) {\n    return updatePayload;\n  }\n\n  if (!Array.isArray(prevProp)) {\n    // Add each property of the leaf.\n    return clearProperties(\n      updatePayload,\n      resolveObject(prevProp),\n      validAttributes\n    );\n  }\n\n  for (var i = 0; i < prevProp.length; i++) {\n    // Add all the properties of the array.\n    updatePayload = clearNestedProperty(\n      updatePayload,\n      prevProp[i],\n      validAttributes\n    );\n  }\n  return updatePayload;\n}\n\n/**\n * diffProperties takes two sets of props and a set of valid attributes\n * and write to updatePayload the values that changed or were deleted.\n * If no updatePayload is provided, a new one is created and returned if\n * anything changed.\n */\nfunction diffProperties(updatePayload, prevProps, nextProps, validAttributes) {\n  var attributeConfig;\n  var nextProp;\n  var prevProp;\n\n  for (var propKey in nextProps) {\n    attributeConfig = validAttributes[propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    prevProp = prevProps[propKey];\n    nextProp = nextProps[propKey];\n\n    // functions are converted to booleans as markers that the associated\n    // events should be sent from native.\n    if (typeof nextProp === \"function\") {\n      nextProp = true;\n      // If nextProp is not a function, then don't bother changing prevProp\n      // since nextProp will win and go into the updatePayload regardless.\n      if (typeof prevProp === \"function\") {\n        prevProp = true;\n      }\n    }\n\n    // An explicit value of undefined is treated as a null because it overrides\n    // any other preceding value.\n    if (typeof nextProp === \"undefined\") {\n      nextProp = null;\n      if (typeof prevProp === \"undefined\") {\n        prevProp = null;\n      }\n    }\n\n    if (removedKeys) {\n      removedKeys[propKey] = false;\n    }\n\n    if (updatePayload && updatePayload[propKey] !== undefined) {\n      // Something else already triggered an update to this key because another\n      // value diffed. Since we're now later in the nested arrays our value is\n      // more important so we need to calculate it and override the existing\n      // value. It doesn't matter if nothing changed, we'll set it anyway.\n\n      // Pattern match on: attributeConfig\n      if (typeof attributeConfig !== \"object\") {\n        // case: !Object is the default case\n        updatePayload[propKey] = nextProp;\n      } else if (\n        typeof attributeConfig.diff === \"function\" ||\n        typeof attributeConfig.process === \"function\"\n      ) {\n        // case: CustomAttributeConfiguration\n        var nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        updatePayload[propKey] = nextValue;\n      }\n      continue;\n    }\n\n    if (prevProp === nextProp) {\n      continue; // nothing changed\n    }\n\n    // Pattern match on: attributeConfig\n    if (typeof attributeConfig !== \"object\") {\n      // case: !Object is the default case\n      if (defaultDiffer(prevProp, nextProp)) {\n        // a normal leaf has changed\n        (updatePayload || (updatePayload = {}))[propKey] = nextProp;\n      }\n    } else if (\n      typeof attributeConfig.diff === \"function\" ||\n      typeof attributeConfig.process === \"function\"\n    ) {\n      // case: CustomAttributeConfiguration\n      var shouldUpdate =\n        prevProp === undefined ||\n        (typeof attributeConfig.diff === \"function\"\n          ? attributeConfig.diff(prevProp, nextProp)\n          : defaultDiffer(prevProp, nextProp));\n      if (shouldUpdate) {\n        nextValue =\n          typeof attributeConfig.process === \"function\"\n            ? attributeConfig.process(nextProp)\n            : nextProp;\n        (updatePayload || (updatePayload = {}))[propKey] = nextValue;\n      }\n    } else {\n      // default: fallthrough case when nested properties are defined\n      removedKeys = null;\n      removedKeyCount = 0;\n      // We think that attributeConfig is not CustomAttributeConfiguration at\n      // this point so we assume it must be AttributeConfiguration.\n      updatePayload = diffNestedProperty(\n        updatePayload,\n        prevProp,\n        nextProp,\n        attributeConfig\n      );\n      if (removedKeyCount > 0 && updatePayload) {\n        restoreDeletedValuesInNestedArray(\n          updatePayload,\n          nextProp,\n          attributeConfig\n        );\n        removedKeys = null;\n      }\n    }\n  }\n\n  // Also iterate through all the previous props to catch any that have been\n  // removed and make sure native gets the signal so it can reset them to the\n  // default.\n  for (propKey in prevProps) {\n    if (nextProps[propKey] !== undefined) {\n      continue; // we've already covered this key in the previous pass\n    }\n    attributeConfig = validAttributes[propKey];\n    if (!attributeConfig) {\n      continue; // not a valid native prop\n    }\n\n    if (updatePayload && updatePayload[propKey] !== undefined) {\n      // This was already updated to a diff result earlier.\n      continue;\n    }\n\n    prevProp = prevProps[propKey];\n    if (prevProp === undefined) {\n      continue; // was already empty anyway\n    }\n    // Pattern match on: attributeConfig\n    if (\n      typeof attributeConfig !== \"object\" ||\n      typeof attributeConfig.diff === \"function\" ||\n      typeof attributeConfig.process === \"function\"\n    ) {\n      // case: CustomAttributeConfiguration | !Object\n      // Flag the leaf property for removal by sending a sentinel.\n      (updatePayload || (updatePayload = {}))[propKey] = null;\n      if (!removedKeys) {\n        removedKeys = {};\n      }\n      if (!removedKeys[propKey]) {\n        removedKeys[propKey] = true;\n        removedKeyCount++;\n      }\n    } else {\n      // default:\n      // This is a nested attribute configuration where all the properties\n      // were removed so we need to go through and clear out all of them.\n      updatePayload = clearNestedProperty(\n        updatePayload,\n        prevProp,\n        attributeConfig\n      );\n    }\n  }\n  return updatePayload;\n}\n\n/**\n * addProperties adds all the valid props to the payload after being processed.\n */\nfunction addProperties(updatePayload, props, validAttributes) {\n  // TODO: Fast path\n  return diffProperties(updatePayload, emptyObject$1, props, validAttributes);\n}\n\n/**\n * clearProperties clears all the previous props by adding a null sentinel\n * to the payload for each valid key.\n */\nfunction clearProperties(updatePayload, prevProps, validAttributes) {\n  // TODO: Fast path\n  return diffProperties(\n    updatePayload,\n    prevProps,\n    emptyObject$1,\n    validAttributes\n  );\n}\n\nfunction create(props, validAttributes) {\n  return addProperties(\n    null, // updatePayload\n    props,\n    validAttributes\n  );\n}\n\nfunction diff(prevProps, nextProps, validAttributes) {\n  return diffProperties(\n    null, // updatePayload\n    prevProps,\n    nextProps,\n    validAttributes\n  );\n}\n\n/**\n * In the future, we should cleanup callbacks by cancelling them instead of\n * using this.\n */\nfunction mountSafeCallback(context, callback) {\n  return function() {\n    if (!callback) {\n      return undefined;\n    }\n    if (typeof context.__isMounted === \"boolean\") {\n      // TODO(gaearon): this is gross and should be removed.\n      // It is currently necessary because View uses createClass,\n      // and so any measure() calls on View (which are done by React\n      // DevTools) trigger the isMounted() deprecation warning.\n      if (!context.__isMounted) {\n        return undefined;\n      }\n      // The else branch is important so that we don't\n      // trigger the deprecation warning by calling isMounted.\n    } else if (typeof context.isMounted === \"function\") {\n      if (!context.isMounted()) {\n        return undefined;\n      }\n    }\n    return callback.apply(context, arguments);\n  };\n}\n\nfunction throwOnStylesProp(component, props) {\n  if (props.styles !== undefined) {\n    var owner = component._owner || null;\n    var name = component.constructor.displayName;\n    var msg =\n      \"`styles` is not a supported property of `\" +\n      name +\n      \"`, did \" +\n      \"you mean `style` (singular)?\";\n    if (owner && owner.constructor && owner.constructor.displayName) {\n      msg +=\n        \"\\n\\nCheck the `\" +\n        owner.constructor.displayName +\n        \"` parent \" +\n        \" component.\";\n    }\n    throw new Error(msg);\n  }\n}\n\nfunction warnForStyleProps(props, validAttributes) {\n  for (var key in validAttributes.style) {\n    if (!(validAttributes[key] || props[key] === undefined)) {\n      console.error(\n        \"You are setting the style `{ \" +\n          key +\n          \": ... }` as a prop. You \" +\n          \"should nest it in a style object. \" +\n          \"E.g. `{ style: { \" +\n          key +\n          \": ... } }`\"\n      );\n    }\n  }\n}\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\n\nfunction get(key) {\n  return key._reactInternalFiber;\n}\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === \"string\") {\n    return type;\n  }\n  if (typeof type === \"function\") {\n    return type.displayName || type.name;\n  }\n  return null;\n}\n\n// Re-export dynamic flags from the fbsource version.\nvar _require = require(\"ReactFeatureFlags\");\n\nvar debugRenderPhaseSideEffects = _require.debugRenderPhaseSideEffects;\n\nvar enableAsyncSubtreeAPI = true;\n\nvar enableUserTimingAPI = true;\nvar enableMutatingReconciler = true;\nvar enableNoopReconciler = false;\nvar enablePersistentReconciler = false;\n\n// Only used in www builds.\n\n// Don't change these two values:\nvar NoEffect = 0; //           0b00000000\nvar PerformedWork = 1; //      0b00000001\n\n// You can change the rest (and add more).\nvar Placement = 2; //          0b00000010\nvar Update = 4; //             0b00000100\nvar PlacementAndUpdate = 6; // 0b00000110\nvar Deletion = 8; //           0b00001000\nvar ContentReset = 16; //      0b00010000\nvar Callback = 32; //          0b00100000\nvar Err = 64; //               0b01000000\nvar Ref = 128; //              0b10000000\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node[\"return\"]) {\n      node = node[\"return\"];\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node[\"return\"]) {\n      node = node[\"return\"];\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      warning(\n        instance._warnedAboutRefsInRender,\n        \"%s is accessing isMounted inside its render() function. \" +\n          \"render() should be a pure function of props and state. It should \" +\n          \"never access something that requires stale data from the previous \" +\n          \"render, such as refs. Move this logic to componentDidMount and \" +\n          \"componentDidUpdate instead.\",\n        getComponentName(ownerFiber) || \"A component\"\n      );\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  invariant(\n    isFiberMountedImpl(fiber) === MOUNTED,\n    \"Unable to find node on an unmounted component.\"\n  );\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    invariant(\n      state !== UNMOUNTED,\n      \"Unable to find node on an unmounted component.\"\n    );\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a[\"return\"];\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, \"Unable to find node on an unmounted component.\");\n    }\n\n    if (a[\"return\"] !== b[\"return\"]) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        invariant(\n          didFindChild,\n          \"Child was not found in either parent set. This indicates a bug \" +\n            \"in React related to the return pointer. Please file an issue.\"\n        );\n      }\n    }\n\n    invariant(\n      a.alternate === b,\n      \"Return fibers should always be each others' alternates. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  invariant(\n    a.tag === HostRoot,\n    \"Unable to find node on an unmounted component.\"\n  );\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child[\"return\"] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node[\"return\"] || node[\"return\"] === currentParent) {\n        return null;\n      }\n      node = node[\"return\"];\n    }\n    node.sibling[\"return\"] = node[\"return\"];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child[\"return\"] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node[\"return\"] || node[\"return\"] === currentParent) {\n        return null;\n      }\n      node = node[\"return\"];\n    }\n    node.sibling[\"return\"] = node[\"return\"];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nvar valueStack = [];\n\n{\n  var fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      warning(false, \"Unexpected pop.\");\n    }\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      warning(false, \"Unexpected Fiber popped.\");\n    }\n  }\n\n  cursor.current = valueStack[index];\n\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nfunction reset() {\n  while (index > -1) {\n    valueStack[index] = null;\n\n    {\n      fiberStack[index] = null;\n    }\n\n    index--;\n  }\n}\n\nvar describeComponentFrame = function(name, source, ownerName) {\n  return (\n    \"\\n    in \" +\n    (name || \"Unknown\") +\n    (source\n      ? \" (at \" +\n        source.fileName.replace(/^.*[\\\\\\/]/, \"\") +\n        \":\" +\n        source.lineNumber +\n        \")\"\n      : ownerName ? \" (created by \" + ownerName + \")\" : \"\")\n  );\n};\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case ClassComponent:\n    case HostComponent:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return \"\";\n  }\n}\n\n// This function can only be called with a work-in-progress fiber and\n// only during begin or complete phase. Do not call it under any other\n// circumstances.\nfunction getStackAddendumByWorkInProgressFiber(workInProgress) {\n  var info = \"\";\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    // Otherwise this return pointer might point to the wrong tree:\n    node = node[\"return\"];\n  } while (node);\n  return info;\n}\n\nfunction getCurrentFiberOwnerName() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    var owner = fiber._debugOwner;\n    if (owner !== null && typeof owner !== \"undefined\") {\n      return getComponentName(owner);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackAddendum() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackAddendumByWorkInProgressFiber(fiber);\n  }\n  return null;\n}\n\nfunction resetCurrentFiber() {\n  ReactDebugCurrentFrame.getCurrentStack = null;\n  ReactDebugCurrentFiber.current = null;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentFiber(fiber) {\n  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;\n  ReactDebugCurrentFiber.current = fiber;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentPhase(phase) {\n  ReactDebugCurrentFiber.phase = phase;\n}\n\nvar ReactDebugCurrentFiber = {\n  current: null,\n  phase: null,\n  resetCurrentFiber: resetCurrentFiber,\n  setCurrentFiber: setCurrentFiber,\n  setCurrentPhase: setCurrentPhase,\n  getCurrentFiberOwnerName: getCurrentFiberOwnerName,\n  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum\n};\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji = \"\\u269B\";\nvar warningEmoji = \"\\u26D4\";\nvar supportsUserTiming =\n  typeof performance !== \"undefined\" &&\n  typeof performance.mark === \"function\" &&\n  typeof performance.clearMarks === \"function\" &&\n  typeof performance.measure === \"function\" &&\n  typeof performance.clearMeasures === \"function\";\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase = null;\nvar currentPhaseFiber = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting = false;\nvar hasScheduledUpdateInCurrentCommit = false;\nvar hasScheduledUpdateInCurrentPhase = false;\nvar commitCountInCurrentWorkLoop = 0;\nvar effectCountInCurrentCommit = 0;\nvar isWaitingForCallback = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit = new Set();\n\nvar formatMarkName = function(markName) {\n  return reactEmoji + \" \" + markName;\n};\n\nvar formatLabel = function(label, warning$$1) {\n  var prefix = warning$$1 ? warningEmoji + \" \" : reactEmoji + \" \";\n  var suffix = warning$$1 ? \" Warning: \" + warning$$1 : \"\";\n  return \"\" + prefix + label + suffix;\n};\n\nvar beginMark = function(markName) {\n  performance.mark(formatMarkName(markName));\n};\n\nvar clearMark = function(markName) {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nvar endMark = function(label, markName, warning$$1) {\n  var formattedMarkName = formatMarkName(markName);\n  var formattedLabel = formatLabel(label, warning$$1);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {}\n  // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nvar getFiberMarkName = function(label, debugID) {\n  return label + \" (#\" + debugID + \")\";\n};\n\nvar getFiberLabel = function(componentName, isMounted, phase) {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return componentName + \" [\" + (isMounted ? \"update\" : \"mount\") + \"]\";\n  } else {\n    // Composite component methods.\n    return componentName + \".\" + phase;\n  }\n};\n\nvar beginFiberMark = function(fiber, phase) {\n  var componentName = getComponentName(fiber) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  var markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nvar clearFiberMark = function(fiber, phase) {\n  var componentName = getComponentName(fiber) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nvar endFiberMark = function(fiber, phase, warning$$1) {\n  var componentName = getComponentName(fiber) || \"Unknown\";\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning$$1);\n};\n\nvar shouldIgnoreFiber = function(fiber) {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case ReturnComponent:\n    case Fragment:\n      return true;\n    default:\n      return false;\n  }\n};\n\nvar clearPendingPhaseMeasurement = function() {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nvar pauseTimers = function() {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  var fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber[\"return\"];\n  }\n};\n\nvar resumeTimersRecursively = function(fiber) {\n  if (fiber[\"return\"] !== null) {\n    resumeTimersRecursively(fiber[\"return\"]);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nvar resumeTimers = function() {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nfunction recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nfunction recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (\n      currentPhase !== null &&\n      currentPhase !== \"componentWillMount\" &&\n      currentPhase !== \"componentWillReceiveProps\"\n    ) {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nfunction startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark(\"(Waiting for async callback...)\");\n    }\n  }\n}\n\nfunction stopRequestCallbackTimer(didExpire) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      var warning$$1 = didExpire ? \"React was blocked by main thread\" : null;\n      endMark(\n        \"(Waiting for async callback...)\",\n        \"(Waiting for async callback...)\",\n        warning$$1\n      );\n    }\n  }\n}\n\nfunction startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nfunction cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nfunction stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber[\"return\"];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nfunction stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber[\"return\"];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    var warning$$1 = \"An error was thrown inside this error boundary\";\n    endFiberMark(fiber, null, warning$$1);\n  }\n}\n\nfunction startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nfunction stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      var warning$$1 = hasScheduledUpdateInCurrentPhase\n        ? \"Scheduled a cascading update\"\n        : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nfunction startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark(\"(React Tree Reconciliation)\");\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nfunction stopWorkLoopTimer(interruptedBy) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var warning$$1 = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning$$1 = \"A top-level update interrupted the previous render\";\n      } else {\n        var componentName = getComponentName(interruptedBy) || \"Unknown\";\n        warning$$1 =\n          \"An update to \" + componentName + \" interrupted the previous render\";\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning$$1 = \"There were cascading updates\";\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark(\n      \"(React Tree Reconciliation)\",\n      \"(React Tree Reconciliation)\",\n      warning$$1\n    );\n  }\n}\n\nfunction startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark(\"(Committing Changes)\");\n  }\n}\n\nfunction stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    var warning$$1 = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning$$1 = \"Lifecycle hook scheduled a cascading update\";\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning$$1 = \"Caused by a cascading update in earlier commit\";\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark(\"(Committing Changes)\", \"(Committing Changes)\", warning$$1);\n  }\n}\n\nfunction startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Committing Host Effects)\");\n  }\n}\n\nfunction stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Committing Host Effects: \" + count + \" Total)\",\n      \"(Committing Host Effects)\",\n      null\n    );\n  }\n}\n\nfunction startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark(\"(Calling Lifecycle Methods)\");\n  }\n}\n\nfunction stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark(\n      \"(Calling Lifecycle Methods: \" + count + \" Total)\",\n      \"(Calling Lifecycle Methods)\",\n      null\n    );\n  }\n}\n\n{\n  var warnedAboutMissingGetChildContext = {};\n}\n\n// A cursor to the current merged context object on the stack.\nvar contextStackCursor = createCursor(emptyObject);\n// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext = emptyObject;\n\nfunction getUnmaskedContext(workInProgress) {\n  var hasOwnContext = isContextProvider(workInProgress);\n  if (hasOwnContext) {\n    // If the fiber is a context provider itself, when we read its context\n    // we have already pushed its own child context on the stack. A context\n    // provider should not \"see\" its own child context. Therefore we read the\n    // previous (parent) context instead for a context provider.\n    return previousContext;\n  }\n  return contextStackCursor.current;\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  var instance = workInProgress.stateNode;\n  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  var type = workInProgress.type;\n  var contextTypes = type.contextTypes;\n  if (!contextTypes) {\n    return emptyObject;\n  }\n\n  // Avoid recreating masked context unless unmasked context has changed.\n  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n  // This may trigger infinite loops if componentWillReceiveProps calls setState.\n  var instance = workInProgress.stateNode;\n  if (\n    instance &&\n    instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext\n  ) {\n    return instance.__reactInternalMemoizedMaskedChildContext;\n  }\n\n  var context = {};\n  for (var key in contextTypes) {\n    context[key] = unmaskedContext[key];\n  }\n\n  {\n    var name = getComponentName(workInProgress) || \"Unknown\";\n    checkPropTypes(\n      contextTypes,\n      context,\n      \"context\",\n      name,\n      ReactDebugCurrentFiber.getCurrentFiberStackAddendum\n    );\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // Context is created before the class component is instantiated so check for instance.\n  if (instance) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return context;\n}\n\nfunction hasContextChanged() {\n  return didPerformWorkStackCursor.current;\n}\n\nfunction isContextConsumer(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n}\n\nfunction isContextProvider(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n}\n\nfunction popContextProvider(fiber) {\n  if (!isContextProvider(fiber)) {\n    return;\n  }\n\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction popTopLevelContextObject(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  invariant(\n    contextStackCursor.cursor == null,\n    \"Unexpected context found on stack. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n\n  push(contextStackCursor, context, fiber);\n  push(didPerformWorkStackCursor, didChange, fiber);\n}\n\nfunction processChildContext(fiber, parentContext) {\n  var instance = fiber.stateNode;\n  var childContextTypes = fiber.type.childContextTypes;\n\n  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n  if (typeof instance.getChildContext !== \"function\") {\n    {\n      var componentName = getComponentName(fiber) || \"Unknown\";\n\n      if (!warnedAboutMissingGetChildContext[componentName]) {\n        warnedAboutMissingGetChildContext[componentName] = true;\n        warning(\n          false,\n          \"%s.childContextTypes is specified but there is no getChildContext() method \" +\n            \"on the instance. You can either define getChildContext() on %s or remove \" +\n            \"childContextTypes from it.\",\n          componentName,\n          componentName\n        );\n      }\n    }\n    return parentContext;\n  }\n\n  var childContext = void 0;\n  {\n    ReactDebugCurrentFiber.setCurrentPhase(\"getChildContext\");\n  }\n  startPhaseTimer(fiber, \"getChildContext\");\n  childContext = instance.getChildContext();\n  stopPhaseTimer();\n  {\n    ReactDebugCurrentFiber.setCurrentPhase(null);\n  }\n  for (var contextKey in childContext) {\n    invariant(\n      contextKey in childContextTypes,\n      '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.',\n      getComponentName(fiber) || \"Unknown\",\n      contextKey\n    );\n  }\n  {\n    var name = getComponentName(fiber) || \"Unknown\";\n    checkPropTypes(\n      childContextTypes,\n      childContext,\n      \"child context\",\n      name,\n      // In practice, there is one case in which we won't get a stack. It's when\n      // somebody calls unstable_renderSubtreeIntoContainer() and we process\n      // context from the parent component instance. The stack will be missing\n      // because it's outside of the reconciliation, and so the pointer has not\n      // been set. This is rare and doesn't matter. We'll also remove that API.\n      ReactDebugCurrentFiber.getCurrentFiberStackAddendum\n    );\n  }\n\n  return Object.assign({}, parentContext, childContext);\n}\n\nfunction pushContextProvider(workInProgress) {\n  if (!isContextProvider(workInProgress)) {\n    return false;\n  }\n\n  var instance = workInProgress.stateNode;\n  // We push the context as early as possible to ensure stack integrity.\n  // If the instance does not exist yet, we will push null at first,\n  // and replace it on the stack later when invalidating the context.\n  var memoizedMergedChildContext =\n    (instance && instance.__reactInternalMemoizedMergedChildContext) ||\n    emptyObject;\n\n  // Remember the parent context so we can merge with it later.\n  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n  previousContext = contextStackCursor.current;\n  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n  push(\n    didPerformWorkStackCursor,\n    didPerformWorkStackCursor.current,\n    workInProgress\n  );\n\n  return true;\n}\n\nfunction invalidateContextProvider(workInProgress, didChange) {\n  var instance = workInProgress.stateNode;\n  invariant(\n    instance,\n    \"Expected to have an instance by this point. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n\n  if (didChange) {\n    // Merge parent and own context.\n    // Skip this if we're not updating due to sCU.\n    // This avoids unnecessarily recomputing memoized values.\n    var mergedContext = processChildContext(workInProgress, previousContext);\n    instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n    // Replace the old (or empty) context with the new one.\n    // It is important to unwind the context in the reverse order.\n    pop(didPerformWorkStackCursor, workInProgress);\n    pop(contextStackCursor, workInProgress);\n    // Now push the new context and mark that it has changed.\n    push(contextStackCursor, mergedContext, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  } else {\n    pop(didPerformWorkStackCursor, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  }\n}\n\nfunction resetContext() {\n  previousContext = emptyObject;\n  contextStackCursor.current = emptyObject;\n  didPerformWorkStackCursor.current = false;\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n  // makes sense elsewhere\n  invariant(\n    isFiberMounted(fiber) && fiber.tag === ClassComponent,\n    \"Expected subtree parent to be a mounted class component. \" +\n      \"This error is likely caused by a bug in React. Please file an issue.\"\n  );\n\n  var node = fiber;\n  while (node.tag !== HostRoot) {\n    if (isContextProvider(node)) {\n      return node.stateNode.__reactInternalMemoizedMergedChildContext;\n    }\n    var parent = node[\"return\"];\n    invariant(\n      parent,\n      \"Found unexpected detached subtree parent. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n    node = parent;\n  }\n  return node.stateNode.context;\n}\n\nvar NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax\n\nvar Sync = 1;\nvar Never = 2147483647; // Max int32: Math.pow(2, 31) - 1\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return ((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction expirationTimeToMs(expirationTime) {\n  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n}\n\nfunction ceiling(num, precision) {\n  return (((num / precision) | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return ceiling(\n    currentTime + expirationInMs / UNIT_SIZE,\n    bucketSizeMs / UNIT_SIZE\n  );\n}\n\nvar NoContext = 0;\nvar AsyncUpdates = 1;\n\n{\n  var hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    /* eslint-disable no-new */\n    new Map([[nonExtensibleObject, null]]);\n    new Set([nonExtensibleObject]);\n    /* eslint-enable no-new */\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\n{\n  var debugCounter = 1;\n}\n\nfunction FiberNode(tag, pendingProps, key, internalContextTag) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this[\"return\"] = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n\n  this.internalContextTag = internalContextTag;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n\n  this.alternate = null;\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === \"function\") {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function(tag, pendingProps, key, internalContextTag) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, internalContextTag);\n};\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(\n      current.tag,\n      pendingProps,\n      current.key,\n      current.internalContextTag\n    );\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps;\n\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n  }\n\n  workInProgress.expirationTime = expirationTime;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber() {\n  var fiber = createFiber(HostRoot, null, NoContext);\n  return fiber;\n}\n\nfunction createFiberFromElement(element, internalContextTag, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type;\n  var key = element.key;\n  var pendingProps = element.props;\n  if (typeof type === \"function\") {\n    fiber = shouldConstruct(type)\n      ? createFiber(ClassComponent, pendingProps, key, internalContextTag)\n      : createFiber(\n          IndeterminateComponent,\n          pendingProps,\n          key,\n          internalContextTag\n        );\n    fiber.type = type;\n  } else if (typeof type === \"string\") {\n    fiber = createFiber(HostComponent, pendingProps, key, internalContextTag);\n    fiber.type = type;\n  } else if (\n    typeof type === \"object\" &&\n    type !== null &&\n    typeof type.tag === \"number\"\n  ) {\n    // Currently assumed to be a continuation and therefore is a fiber already.\n    // TODO: The yield system is currently broken for updates in some cases.\n    // The reified yield stores a fiber, but we don't know which fiber that is;\n    // the current or a workInProgress? When the continuation gets rendered here\n    // we don't know if we can reuse that fiber or if we need to clone it.\n    // There is probably a clever way to restructure this.\n    fiber = type;\n    fiber.pendingProps = pendingProps;\n  } else {\n    var info = \"\";\n    {\n      if (\n        type === undefined ||\n        (typeof type === \"object\" &&\n          type !== null &&\n          Object.keys(type).length === 0)\n      ) {\n        info +=\n          \" You likely forgot to export your component from the file \" +\n          \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n      var ownerName = owner ? getComponentName(owner) : null;\n      if (ownerName) {\n        info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n      }\n    }\n    invariant(\n      false,\n      \"Element type is invalid: expected a string (for built-in components) \" +\n        \"or a class/function (for composite components) but got: %s.%s\",\n      type == null ? type : typeof type,\n      info\n    );\n  }\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  fiber.expirationTime = expirationTime;\n\n  return fiber;\n}\n\nfunction createFiberFromFragment(\n  elements,\n  internalContextTag,\n  expirationTime,\n  key\n) {\n  var fiber = createFiber(Fragment, elements, key, internalContextTag);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromText(content, internalContextTag, expirationTime) {\n  var fiber = createFiber(HostText, content, null, internalContextTag);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, null, NoContext);\n  fiber.type = \"DELETED\";\n  return fiber;\n}\n\nfunction createFiberFromCall(call, internalContextTag, expirationTime) {\n  var fiber = createFiber(CallComponent, call, call.key, internalContextTag);\n  fiber.type = call.handler;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromReturn(returnNode, internalContextTag, expirationTime) {\n  var fiber = createFiber(ReturnComponent, null, null, internalContextTag);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, internalContextTag, expirationTime) {\n  var pendingProps = portal.children !== null ? portal.children : [];\n  var fiber = createFiber(\n    HostPortal,\n    pendingProps,\n    portal.key,\n    internalContextTag\n  );\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\n// TODO: This should be lifted into the renderer.\n\nfunction createFiberRoot(containerInfo, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber();\n  var root = {\n    current: uninitializedFiber,\n    containerInfo: containerInfo,\n    pendingChildren: null,\n    remainingExpirationTime: NoWork,\n    isReadyForCommit: false,\n    finishedWork: null,\n    context: null,\n    pendingContext: null,\n    hydrate: hydrate,\n    firstBatch: null,\n    nextScheduledRoot: null\n  };\n  uninitializedFiber.stateNode = root;\n  return root;\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function(arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warning(false, \"React DevTools encountered an error: %s\", err);\n      }\n    }\n  };\n}\n\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\") {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n  if (!hook.supportsFiber) {\n    {\n      warning(\n        false,\n        \"The installed version of React DevTools is too old and will not work \" +\n          \"with the current version of React. Please update React DevTools. \" +\n          \"https://fb.me/react-devtools\"\n      );\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function(root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function(fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warning(false, \"React DevTools encountered an error: %s.\", err);\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === \"function\") {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === \"function\") {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\n{\n  var didWarnUpdateInsideUpdate = false;\n}\n\n// Callbacks are not validated until invocation\n\n// Singly linked-list of updates. When an update is scheduled, it is added to\n// the queue of the current fiber and the work-in-progress fiber. The two queues\n// are separate but they share a persistent structure.\n//\n// During reconciliation, updates are removed from the work-in-progress fiber,\n// but they remain on the current fiber. That ensures that if a work-in-progress\n// is aborted, the aborted updates are recovered by cloning from current.\n//\n// The work-in-progress queue is always a subset of the current queue.\n//\n// When the tree is committed, the work-in-progress becomes the current.\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    baseState: baseState,\n    expirationTime: NoWork,\n    first: null,\n    last: null,\n    callbackList: null,\n    hasForceUpdate: false,\n    isInitialized: false\n  };\n  {\n    queue.isProcessing = false;\n  }\n  return queue;\n}\n\nfunction insertUpdateIntoQueue(queue, update) {\n  // Append the update to the end of the list.\n  if (queue.last === null) {\n    // Queue is empty\n    queue.first = queue.last = update;\n  } else {\n    queue.last.next = update;\n    queue.last = update;\n  }\n  if (\n    queue.expirationTime === NoWork ||\n    queue.expirationTime > update.expirationTime\n  ) {\n    queue.expirationTime = update.expirationTime;\n  }\n}\n\nfunction insertUpdateIntoFiber(fiber, update) {\n  // We'll have at least one and at most two distinct update queues.\n  var alternateFiber = fiber.alternate;\n  var queue1 = fiber.updateQueue;\n  if (queue1 === null) {\n    // TODO: We don't know what the base state will be until we begin work.\n    // It depends on which fiber is the next current. Initialize with an empty\n    // base state, then set to the memoizedState when rendering. Not super\n    // happy with this approach.\n    queue1 = fiber.updateQueue = createUpdateQueue(null);\n  }\n\n  var queue2 = void 0;\n  if (alternateFiber !== null) {\n    queue2 = alternateFiber.updateQueue;\n    if (queue2 === null) {\n      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);\n    }\n  } else {\n    queue2 = null;\n  }\n  queue2 = queue2 !== queue1 ? queue2 : null;\n\n  // Warn if an update is scheduled from inside an updater function.\n  {\n    if (\n      (queue1.isProcessing || (queue2 !== null && queue2.isProcessing)) &&\n      !didWarnUpdateInsideUpdate\n    ) {\n      warning(\n        false,\n        \"An update (setState, replaceState, or forceUpdate) was scheduled \" +\n          \"from inside an update function. Update functions should be pure, \" +\n          \"with zero side-effects. Consider using componentDidUpdate or a \" +\n          \"callback.\"\n      );\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n\n  // If there's only one queue, add the update to that queue and exit.\n  if (queue2 === null) {\n    insertUpdateIntoQueue(queue1, update);\n    return;\n  }\n\n  // If either queue is empty, we need to add to both queues.\n  if (queue1.last === null || queue2.last === null) {\n    insertUpdateIntoQueue(queue1, update);\n    insertUpdateIntoQueue(queue2, update);\n    return;\n  }\n\n  // If both lists are not empty, the last update is the same for both lists\n  // because of structural sharing. So, we should only append to one of\n  // the lists.\n  insertUpdateIntoQueue(queue1, update);\n  // But we still need to update the `last` pointer of queue2.\n  queue2.last = update;\n}\n\nfunction getUpdateExpirationTime(fiber) {\n  if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {\n    return NoWork;\n  }\n  var updateQueue = fiber.updateQueue;\n  if (updateQueue === null) {\n    return NoWork;\n  }\n  return updateQueue.expirationTime;\n}\n\nfunction getStateFromUpdate(update, instance, prevState, props) {\n  var partialState = update.partialState;\n  if (typeof partialState === \"function\") {\n    var updateFn = partialState;\n\n    // Invoke setState callback an extra time to help detect side-effects.\n    if (debugRenderPhaseSideEffects) {\n      updateFn.call(instance, prevState, props);\n    }\n\n    return updateFn.call(instance, prevState, props);\n  } else {\n    return partialState;\n  }\n}\n\nfunction processUpdateQueue(\n  current,\n  workInProgress,\n  queue,\n  instance,\n  props,\n  renderExpirationTime\n) {\n  if (current !== null && current.updateQueue === queue) {\n    // We need to create a work-in-progress queue, by cloning the current queue.\n    var currentQueue = queue;\n    queue = workInProgress.updateQueue = {\n      baseState: currentQueue.baseState,\n      expirationTime: currentQueue.expirationTime,\n      first: currentQueue.first,\n      last: currentQueue.last,\n      isInitialized: currentQueue.isInitialized,\n      // These fields are no longer valid because they were already committed.\n      // Reset them.\n      callbackList: null,\n      hasForceUpdate: false\n    };\n  }\n\n  {\n    // Set this flag so we can warn if setState is called inside the update\n    // function of another setState.\n    queue.isProcessing = true;\n  }\n\n  // Reset the remaining expiration time. If we skip over any updates, we'll\n  // increase this accordingly.\n  queue.expirationTime = NoWork;\n\n  // TODO: We don't know what the base state will be until we begin work.\n  // It depends on which fiber is the next current. Initialize with an empty\n  // base state, then set to the memoizedState when rendering. Not super\n  // happy with this approach.\n  var state = void 0;\n  if (queue.isInitialized) {\n    state = queue.baseState;\n  } else {\n    state = queue.baseState = workInProgress.memoizedState;\n    queue.isInitialized = true;\n  }\n  var dontMutatePrevState = true;\n  var update = queue.first;\n  var didSkip = false;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      var remainingExpirationTime = queue.expirationTime;\n      if (\n        remainingExpirationTime === NoWork ||\n        remainingExpirationTime > updateExpirationTime\n      ) {\n        // Update the remaining expiration time.\n        queue.expirationTime = updateExpirationTime;\n      }\n      if (!didSkip) {\n        didSkip = true;\n        queue.baseState = state;\n      }\n      // Continue to the next update.\n      update = update.next;\n      continue;\n    }\n\n    // This update does have sufficient priority.\n\n    // If no previous updates were skipped, drop this update from the queue by\n    // advancing the head of the list.\n    if (!didSkip) {\n      queue.first = update.next;\n      if (queue.first === null) {\n        queue.last = null;\n      }\n    }\n\n    // Process the update\n    var _partialState = void 0;\n    if (update.isReplace) {\n      state = getStateFromUpdate(update, instance, state, props);\n      dontMutatePrevState = true;\n    } else {\n      _partialState = getStateFromUpdate(update, instance, state, props);\n      if (_partialState) {\n        if (dontMutatePrevState) {\n          // $FlowFixMe: Idk how to type this properly.\n          state = Object.assign({}, state, _partialState);\n        } else {\n          state = Object.assign(state, _partialState);\n        }\n        dontMutatePrevState = false;\n      }\n    }\n    if (update.isForced) {\n      queue.hasForceUpdate = true;\n    }\n    if (update.callback !== null) {\n      // Append to list of callbacks.\n      var _callbackList = queue.callbackList;\n      if (_callbackList === null) {\n        _callbackList = queue.callbackList = [];\n      }\n      _callbackList.push(update);\n    }\n    update = update.next;\n  }\n\n  if (queue.callbackList !== null) {\n    workInProgress.effectTag |= Callback;\n  } else if (queue.first === null && !queue.hasForceUpdate) {\n    // The queue is empty. We can reset it.\n    workInProgress.updateQueue = null;\n  }\n\n  if (!didSkip) {\n    didSkip = true;\n    queue.baseState = state;\n  }\n\n  {\n    // No longer processing.\n    queue.isProcessing = false;\n  }\n\n  return state;\n}\n\nfunction commitCallbacks(queue, context) {\n  var callbackList = queue.callbackList;\n  if (callbackList === null) {\n    return;\n  }\n  // Set the list to null to make sure they don't get called more than once.\n  queue.callbackList = null;\n  for (var i = 0; i < callbackList.length; i++) {\n    var update = callbackList[i];\n    var _callback = update.callback;\n    // This update might be processed again. Clear the callback so it's only\n    // called once.\n    update.callback = null;\n    invariant(\n      typeof _callback === \"function\",\n      \"Invalid argument passed as callback. Expected a function. Instead \" +\n        \"received: %s\",\n      _callback\n    );\n    _callback.call(context);\n  }\n}\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\n{\n  var didWarnAboutStateAssignmentForComponent = {};\n\n  var warnOnInvalidCallback = function(callback, callerName) {\n    warning(\n      callback === null || typeof callback === \"function\",\n      \"%s(...): Expected the last optional `callback` argument to be a \" +\n        \"function. Instead received: %s.\",\n      callerName,\n      callback\n    );\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, \"_processChildContext\", {\n    enumerable: false,\n    value: function() {\n      invariant(\n        false,\n        \"_processChildContext is not available in React 16+. This likely \" +\n          \"means you have multiple copies of React and are attempting to nest \" +\n          \"a React 15 tree inside a React 16 tree using \" +\n          \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" +\n          \"to make sure you have only one copy of React (and ideally, switch \" +\n          \"to ReactDOM.createPortal).\"\n      );\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nvar ReactFiberClassComponent = function(\n  scheduleWork,\n  computeExpirationForFiber,\n  memoizeProps,\n  memoizeState\n) {\n  // Class component state updater\n  var updater = {\n    isMounted: isMounted,\n    enqueueSetState: function(instance, partialState, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, \"setState\");\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: partialState,\n        callback: callback,\n        isReplace: false,\n        isForced: false,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueReplaceState: function(instance, state, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, \"replaceState\");\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: state,\n        callback: callback,\n        isReplace: true,\n        isForced: false,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueForceUpdate: function(instance, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, \"forceUpdate\");\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: null,\n        callback: callback,\n        isReplace: false,\n        isForced: true,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    }\n  };\n\n  function checkShouldComponentUpdate(\n    workInProgress,\n    oldProps,\n    newProps,\n    oldState,\n    newState,\n    newContext\n  ) {\n    if (\n      oldProps === null ||\n      (workInProgress.updateQueue !== null &&\n        workInProgress.updateQueue.hasForceUpdate)\n    ) {\n      // If the workInProgress already has an Update effect, return true\n      return true;\n    }\n\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    if (typeof instance.shouldComponentUpdate === \"function\") {\n      startPhaseTimer(workInProgress, \"shouldComponentUpdate\");\n      var shouldUpdate = instance.shouldComponentUpdate(\n        newProps,\n        newState,\n        newContext\n      );\n      stopPhaseTimer();\n\n      // Simulate an async bailout/interruption by invoking lifecycle twice.\n      if (debugRenderPhaseSideEffects) {\n        instance.shouldComponentUpdate(newProps, newState, newContext);\n      }\n\n      {\n        warning(\n          shouldUpdate !== undefined,\n          \"%s.shouldComponentUpdate(): Returned undefined instead of a \" +\n            \"boolean value. Make sure to return true or false.\",\n          getComponentName(workInProgress) || \"Unknown\"\n        );\n      }\n\n      return shouldUpdate;\n    }\n\n    if (type.prototype && type.prototype.isPureReactComponent) {\n      return (\n        !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n      );\n    }\n\n    return true;\n  }\n\n  function checkClassInstance(workInProgress) {\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    {\n      var name = getComponentName(workInProgress);\n      var renderPresent = instance.render;\n\n      if (!renderPresent) {\n        if (type.prototype && typeof type.prototype.render === \"function\") {\n          warning(\n            false,\n            \"%s(...): No `render` method found on the returned component \" +\n              \"instance: did you accidentally return an object from the constructor?\",\n            name\n          );\n        } else {\n          warning(\n            false,\n            \"%s(...): No `render` method found on the returned component \" +\n              \"instance: you may have forgotten to define `render`.\",\n            name\n          );\n        }\n      }\n\n      var noGetInitialStateOnES6 =\n        !instance.getInitialState ||\n        instance.getInitialState.isReactClassApproved ||\n        instance.state;\n      warning(\n        noGetInitialStateOnES6,\n        \"getInitialState was defined on %s, a plain JavaScript class. \" +\n          \"This is only supported for classes created using React.createClass. \" +\n          \"Did you mean to define a state property instead?\",\n        name\n      );\n      var noGetDefaultPropsOnES6 =\n        !instance.getDefaultProps ||\n        instance.getDefaultProps.isReactClassApproved;\n      warning(\n        noGetDefaultPropsOnES6,\n        \"getDefaultProps was defined on %s, a plain JavaScript class. \" +\n          \"This is only supported for classes created using React.createClass. \" +\n          \"Use a static property to define defaultProps instead.\",\n        name\n      );\n      var noInstancePropTypes = !instance.propTypes;\n      warning(\n        noInstancePropTypes,\n        \"propTypes was defined as an instance property on %s. Use a static \" +\n          \"property to define propTypes instead.\",\n        name\n      );\n      var noInstanceContextTypes = !instance.contextTypes;\n      warning(\n        noInstanceContextTypes,\n        \"contextTypes was defined as an instance property on %s. Use a static \" +\n          \"property to define contextTypes instead.\",\n        name\n      );\n      var noComponentShouldUpdate =\n        typeof instance.componentShouldUpdate !== \"function\";\n      warning(\n        noComponentShouldUpdate,\n        \"%s has a method called \" +\n          \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" +\n          \"The name is phrased as a question because the function is \" +\n          \"expected to return a value.\",\n        name\n      );\n      if (\n        type.prototype &&\n        type.prototype.isPureReactComponent &&\n        typeof instance.shouldComponentUpdate !== \"undefined\"\n      ) {\n        warning(\n          false,\n          \"%s has a method called shouldComponentUpdate(). \" +\n            \"shouldComponentUpdate should not be used when extending React.PureComponent. \" +\n            \"Please extend React.Component if shouldComponentUpdate is used.\",\n          getComponentName(workInProgress) || \"A pure component\"\n        );\n      }\n      var noComponentDidUnmount =\n        typeof instance.componentDidUnmount !== \"function\";\n      warning(\n        noComponentDidUnmount,\n        \"%s has a method called \" +\n          \"componentDidUnmount(). But there is no such lifecycle method. \" +\n          \"Did you mean componentWillUnmount()?\",\n        name\n      );\n      var noComponentDidReceiveProps =\n        typeof instance.componentDidReceiveProps !== \"function\";\n      warning(\n        noComponentDidReceiveProps,\n        \"%s has a method called \" +\n          \"componentDidReceiveProps(). But there is no such lifecycle method. \" +\n          \"If you meant to update the state in response to changing props, \" +\n          \"use componentWillReceiveProps(). If you meant to fetch data or \" +\n          \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\",\n        name\n      );\n      var noComponentWillRecieveProps =\n        typeof instance.componentWillRecieveProps !== \"function\";\n      warning(\n        noComponentWillRecieveProps,\n        \"%s has a method called \" +\n          \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\",\n        name\n      );\n      var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n      warning(\n        instance.props === undefined || !hasMutatedProps,\n        \"%s(...): When calling super() in `%s`, make sure to pass \" +\n          \"up the same props that your component's constructor was passed.\",\n        name,\n        name\n      );\n      var noInstanceDefaultProps = !instance.defaultProps;\n      warning(\n        noInstanceDefaultProps,\n        \"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" +\n          \" Instead, define defaultProps as a static property on %s.\",\n        name,\n        name\n      );\n    }\n\n    var state = instance.state;\n    if (state && (typeof state !== \"object\" || isArray(state))) {\n      warning(\n        false,\n        \"%s.state: must be set to an object or null\",\n        getComponentName(workInProgress)\n      );\n    }\n    if (typeof instance.getChildContext === \"function\") {\n      warning(\n        typeof workInProgress.type.childContextTypes === \"object\",\n        \"%s.getChildContext(): childContextTypes must be defined in order to \" +\n          \"use getChildContext().\",\n        getComponentName(workInProgress)\n      );\n    }\n  }\n\n  function resetInputPointers(workInProgress, instance) {\n    instance.props = workInProgress.memoizedProps;\n    instance.state = workInProgress.memoizedState;\n  }\n\n  function adoptClassInstance(workInProgress, instance) {\n    instance.updater = updater;\n    workInProgress.stateNode = instance;\n    // The instance needs access to the fiber so that it can schedule updates\n    set(instance, workInProgress);\n    {\n      instance._reactInternalInstance = fakeInternalInstance;\n    }\n  }\n\n  function constructClassInstance(workInProgress, props) {\n    var ctor = workInProgress.type;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var needsContext = isContextConsumer(workInProgress);\n    var context = needsContext\n      ? getMaskedContext(workInProgress, unmaskedContext)\n      : emptyObject;\n    var instance = new ctor(props, context);\n    adoptClassInstance(workInProgress, instance);\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // ReactFiberContext usually updates this cache but can't for newly-created instances.\n    if (needsContext) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return instance;\n  }\n\n  function callComponentWillMount(workInProgress, instance) {\n    startPhaseTimer(workInProgress, \"componentWillMount\");\n    var oldState = instance.state;\n    instance.componentWillMount();\n    stopPhaseTimer();\n\n    // Simulate an async bailout/interruption by invoking lifecycle twice.\n    if (debugRenderPhaseSideEffects) {\n      instance.componentWillMount();\n    }\n\n    if (oldState !== instance.state) {\n      {\n        warning(\n          false,\n          \"%s.componentWillMount(): Assigning directly to this.state is \" +\n            \"deprecated (except inside a component's \" +\n            \"constructor). Use setState instead.\",\n          getComponentName(workInProgress)\n        );\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  function callComponentWillReceiveProps(\n    workInProgress,\n    instance,\n    newProps,\n    newContext\n  ) {\n    startPhaseTimer(workInProgress, \"componentWillReceiveProps\");\n    var oldState = instance.state;\n    instance.componentWillReceiveProps(newProps, newContext);\n    stopPhaseTimer();\n\n    // Simulate an async bailout/interruption by invoking lifecycle twice.\n    if (debugRenderPhaseSideEffects) {\n      instance.componentWillReceiveProps(newProps, newContext);\n    }\n\n    if (instance.state !== oldState) {\n      {\n        var componentName = getComponentName(workInProgress) || \"Component\";\n        if (!didWarnAboutStateAssignmentForComponent[componentName]) {\n          warning(\n            false,\n            \"%s.componentWillReceiveProps(): Assigning directly to \" +\n              \"this.state is deprecated (except inside a component's \" +\n              \"constructor). Use setState instead.\",\n            componentName\n          );\n          didWarnAboutStateAssignmentForComponent[componentName] = true;\n        }\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  // Invokes the mount life-cycles on a previously never rendered instance.\n  function mountClassInstance(workInProgress, renderExpirationTime) {\n    var current = workInProgress.alternate;\n\n    {\n      checkClassInstance(workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n    var state = instance.state || null;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n\n    instance.props = props;\n    instance.state = workInProgress.memoizedState = state;\n    instance.refs = emptyObject;\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n    if (\n      enableAsyncSubtreeAPI &&\n      workInProgress.type != null &&\n      workInProgress.type.prototype != null &&\n      workInProgress.type.prototype.unstable_isAsyncReactComponent === true\n    ) {\n      workInProgress.internalContextTag |= AsyncUpdates;\n    }\n\n    if (typeof instance.componentWillMount === \"function\") {\n      callComponentWillMount(workInProgress, instance);\n      // If we had additional state updates during this life-cycle, let's\n      // process them now.\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null) {\n        instance.state = processUpdateQueue(\n          current,\n          workInProgress,\n          updateQueue,\n          instance,\n          props,\n          renderExpirationTime\n        );\n      }\n    }\n    if (typeof instance.componentDidMount === \"function\") {\n      workInProgress.effectTag |= Update;\n    }\n  }\n\n  // Called on a preexisting class instance. Returns false if a resumed render\n  // could be reused.\n  // function resumeMountClassInstance(\n  //   workInProgress: Fiber,\n  //   priorityLevel: PriorityLevel,\n  // ): boolean {\n  //   const instance = workInProgress.stateNode;\n  //   resetInputPointers(workInProgress, instance);\n\n  //   let newState = workInProgress.memoizedState;\n  //   let newProps = workInProgress.pendingProps;\n  //   if (!newProps) {\n  //     // If there isn't any new props, then we'll reuse the memoized props.\n  //     // This could be from already completed work.\n  //     newProps = workInProgress.memoizedProps;\n  //     invariant(\n  //       newProps != null,\n  //       'There should always be pending or memoized props. This error is ' +\n  //         'likely caused by a bug in React. Please file an issue.',\n  //     );\n  //   }\n  //   const newUnmaskedContext = getUnmaskedContext(workInProgress);\n  //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n  //   const oldContext = instance.context;\n  //   const oldProps = workInProgress.memoizedProps;\n\n  //   if (\n  //     typeof instance.componentWillReceiveProps === 'function' &&\n  //     (oldProps !== newProps || oldContext !== newContext)\n  //   ) {\n  //     callComponentWillReceiveProps(\n  //       workInProgress,\n  //       instance,\n  //       newProps,\n  //       newContext,\n  //     );\n  //   }\n\n  //   // Process the update queue before calling shouldComponentUpdate\n  //   const updateQueue = workInProgress.updateQueue;\n  //   if (updateQueue !== null) {\n  //     newState = processUpdateQueue(\n  //       workInProgress,\n  //       updateQueue,\n  //       instance,\n  //       newState,\n  //       newProps,\n  //       priorityLevel,\n  //     );\n  //   }\n\n  //   // TODO: Should we deal with a setState that happened after the last\n  //   // componentWillMount and before this componentWillMount? Probably\n  //   // unsupported anyway.\n\n  //   if (\n  //     !checkShouldComponentUpdate(\n  //       workInProgress,\n  //       workInProgress.memoizedProps,\n  //       newProps,\n  //       workInProgress.memoizedState,\n  //       newState,\n  //       newContext,\n  //     )\n  //   ) {\n  //     // Update the existing instance's state, props, and context pointers even\n  //     // though we're bailing out.\n  //     instance.props = newProps;\n  //     instance.state = newState;\n  //     instance.context = newContext;\n  //     return false;\n  //   }\n\n  //   // Update the input pointers now so that they are correct when we call\n  //   // componentWillMount\n  //   instance.props = newProps;\n  //   instance.state = newState;\n  //   instance.context = newContext;\n\n  //   if (typeof instance.componentWillMount === 'function') {\n  //     callComponentWillMount(workInProgress, instance);\n  //     // componentWillMount may have called setState. Process the update queue.\n  //     const newUpdateQueue = workInProgress.updateQueue;\n  //     if (newUpdateQueue !== null) {\n  //       newState = processUpdateQueue(\n  //         workInProgress,\n  //         newUpdateQueue,\n  //         instance,\n  //         newState,\n  //         newProps,\n  //         priorityLevel,\n  //       );\n  //     }\n  //   }\n\n  //   if (typeof instance.componentDidMount === 'function') {\n  //     workInProgress.effectTag |= Update;\n  //   }\n\n  //   instance.state = newState;\n\n  //   return true;\n  // }\n\n  // Invokes the update life-cycles and returns false if it shouldn't rerender.\n  function updateClassInstance(current, workInProgress, renderExpirationTime) {\n    var instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    var oldProps = workInProgress.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n    var oldContext = instance.context;\n    var newUnmaskedContext = getUnmaskedContext(workInProgress);\n    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    if (\n      typeof instance.componentWillReceiveProps === \"function\" &&\n      (oldProps !== newProps || oldContext !== newContext)\n    ) {\n      callComponentWillReceiveProps(\n        workInProgress,\n        instance,\n        newProps,\n        newContext\n      );\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    var oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    var newState = void 0;\n    if (workInProgress.updateQueue !== null) {\n      newState = processUpdateQueue(\n        current,\n        workInProgress,\n        workInProgress.updateQueue,\n        instance,\n        newProps,\n        renderExpirationTime\n      );\n    } else {\n      newState = oldState;\n    }\n\n    if (\n      oldProps === newProps &&\n      oldState === newState &&\n      !hasContextChanged() &&\n      !(\n        workInProgress.updateQueue !== null &&\n        workInProgress.updateQueue.hasForceUpdate\n      )\n    ) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === \"function\") {\n        if (\n          oldProps !== current.memoizedProps ||\n          oldState !== current.memoizedState\n        ) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n      return false;\n    }\n\n    var shouldUpdate = checkShouldComponentUpdate(\n      workInProgress,\n      oldProps,\n      newProps,\n      oldState,\n      newState,\n      newContext\n    );\n\n    if (shouldUpdate) {\n      if (typeof instance.componentWillUpdate === \"function\") {\n        startPhaseTimer(workInProgress, \"componentWillUpdate\");\n        instance.componentWillUpdate(newProps, newState, newContext);\n        stopPhaseTimer();\n\n        // Simulate an async bailout/interruption by invoking lifecycle twice.\n        if (debugRenderPhaseSideEffects) {\n          instance.componentWillUpdate(newProps, newState, newContext);\n        }\n      }\n      if (typeof instance.componentDidUpdate === \"function\") {\n        workInProgress.effectTag |= Update;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === \"function\") {\n        if (\n          oldProps !== current.memoizedProps ||\n          oldState !== current.memoizedState\n        ) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  return {\n    adoptClassInstance: adoptClassInstance,\n    constructClassInstance: constructClassInstance,\n    mountClassInstance: mountClassInstance,\n    // resumeMountClassInstance,\n    updateClassInstance: updateClassInstance\n  };\n};\n\nvar getCurrentFiberStackAddendum$1 =\n  ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n{\n  var didWarnAboutMaps = false;\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  var ownerHasKeyUseWarning = {};\n  var ownerHasFunctionTypeWarning = {};\n\n  var warnForMissingKey = function(child) {\n    if (child === null || typeof child !== \"object\") {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    invariant(\n      typeof child._store === \"object\",\n      \"React Component in warnForMissingKey should have a _store. \" +\n        \"This error is likely caused by a bug in React. Please file an issue.\"\n    );\n    child._store.validated = true;\n\n    var currentComponentErrorInfo =\n      \"Each child in an array or iterator should have a unique \" +\n      '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n      \"more information.\" +\n      (getCurrentFiberStackAddendum$1() || \"\");\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning(\n      false,\n      \"Each child in an array or iterator should have a unique \" +\n        '\"key\" prop. See https://fb.me/react-warning-keys for ' +\n        \"more information.%s\",\n      getCurrentFiberStackAddendum$1()\n    );\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nfunction coerceRef(current, element) {\n  var mixedRef = element.ref;\n  if (mixedRef !== null && typeof mixedRef !== \"function\") {\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        invariant(\n          ownerFiber.tag === ClassComponent,\n          \"Stateless function components cannot have refs.\"\n        );\n        inst = ownerFiber.stateNode;\n      }\n      invariant(\n        inst,\n        \"Missing owner for string ref %s. This error is likely caused by a \" +\n          \"bug in React. Please file an issue.\",\n        mixedRef\n      );\n      var stringRef = \"\" + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (\n        current !== null &&\n        current.ref !== null &&\n        current.ref._stringRef === stringRef\n      ) {\n        return current.ref;\n      }\n      var ref = function(value) {\n        var refs = inst.refs === emptyObject ? (inst.refs = {}) : inst.refs;\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      invariant(\n        typeof mixedRef === \"string\",\n        \"Expected ref to be a function or a string.\"\n      );\n      invariant(\n        element._owner,\n        \"Element ref was specified as a string (%s) but no owner was \" +\n          \"set. You may have multiple copies of React loaded. \" +\n          \"(details: https://fb.me/react-refs-must-have-owner).\",\n        mixedRef\n      );\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== \"textarea\") {\n    var addendum = \"\";\n    {\n      addendum =\n        \" If you meant to render a collection of children, use an array \" +\n        \"instead.\" +\n        (getCurrentFiberStackAddendum$1() || \"\");\n    }\n    invariant(\n      false,\n      \"Objects are not valid as a React child (found: %s).%s\",\n      Object.prototype.toString.call(newChild) === \"[object Object]\"\n        ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\"\n        : newChild,\n      addendum\n    );\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo =\n    \"Functions are not valid as a React child. This may happen if \" +\n    \"you return a Component instead of <Component /> from render. \" +\n    \"Or maybe you meant to call this function rather than return it.\" +\n    (getCurrentFiberStackAddendum$1() || \"\");\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning(\n    false,\n    \"Functions are not valid as a React child. This may happen if \" +\n      \"you return a Component instead of <Component /> from render. \" +\n      \"Or maybe you meant to call this function rather than return it.%s\",\n    getCurrentFiberStackAddendum$1() || \"\"\n  );\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current = newFiber.alternate;\n    if (current !== null) {\n      var oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, expirationTime) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(\n        textContent,\n        returnFiber.internalContextTag,\n        expirationTime\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, textContent, expirationTime);\n      existing[\"return\"] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, expirationTime) {\n    if (current !== null && current.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current, element.props, expirationTime);\n      existing.ref = coerceRef(current, element);\n      existing[\"return\"] = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(\n        element,\n        returnFiber.internalContextTag,\n        expirationTime\n      );\n      created.ref = coerceRef(current, element);\n      created[\"return\"] = returnFiber;\n      return created;\n    }\n  }\n\n  function updateCall(returnFiber, current, call, expirationTime) {\n    // TODO: Should this also compare handler to determine whether to reuse?\n    if (current === null || current.tag !== CallComponent) {\n      // Insert\n      var created = createFiberFromCall(\n        call,\n        returnFiber.internalContextTag,\n        expirationTime\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      var existing = useFiber(current, call, expirationTime);\n      existing[\"return\"] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateReturn(returnFiber, current, returnNode, expirationTime) {\n    if (current === null || current.tag !== ReturnComponent) {\n      // Insert\n      var created = createFiberFromReturn(\n        returnNode,\n        returnFiber.internalContextTag,\n        expirationTime\n      );\n      created.type = returnNode.value;\n      created[\"return\"] = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      var existing = useFiber(current, null, expirationTime);\n      existing.type = returnNode.value;\n      existing[\"return\"] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updatePortal(returnFiber, current, portal, expirationTime) {\n    if (\n      current === null ||\n      current.tag !== HostPortal ||\n      current.stateNode.containerInfo !== portal.containerInfo ||\n      current.stateNode.implementation !== portal.implementation\n    ) {\n      // Insert\n      var created = createFiberFromPortal(\n        portal,\n        returnFiber.internalContextTag,\n        expirationTime\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, portal.children || [], expirationTime);\n      existing[\"return\"] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(\n        fragment,\n        returnFiber.internalContextTag,\n        expirationTime,\n        key\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, fragment, expirationTime);\n      existing[\"return\"] = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText(\n        \"\" + newChild,\n        returnFiber.internalContextTag,\n        expirationTime\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          if (newChild.type === REACT_FRAGMENT_TYPE) {\n            var _created = createFiberFromFragment(\n              newChild.props.children,\n              returnFiber.internalContextTag,\n              expirationTime,\n              newChild.key\n            );\n            _created[\"return\"] = returnFiber;\n            return _created;\n          } else {\n            var _created2 = createFiberFromElement(\n              newChild,\n              returnFiber.internalContextTag,\n              expirationTime\n            );\n            _created2.ref = coerceRef(null, newChild);\n            _created2[\"return\"] = returnFiber;\n            return _created2;\n          }\n        }\n\n        case REACT_CALL_TYPE: {\n          var _created3 = createFiberFromCall(\n            newChild,\n            returnFiber.internalContextTag,\n            expirationTime\n          );\n          _created3[\"return\"] = returnFiber;\n          return _created3;\n        }\n\n        case REACT_RETURN_TYPE: {\n          var _created4 = createFiberFromReturn(\n            newChild,\n            returnFiber.internalContextTag,\n            expirationTime\n          );\n          _created4.type = newChild.value;\n          _created4[\"return\"] = returnFiber;\n          return _created4;\n        }\n\n        case REACT_PORTAL_TYPE: {\n          var _created5 = createFiberFromPortal(\n            newChild,\n            returnFiber.internalContextTag,\n            expirationTime\n          );\n          _created5[\"return\"] = returnFiber;\n          return _created5;\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created6 = createFiberFromFragment(\n          newChild,\n          returnFiber.internalContextTag,\n          expirationTime,\n          null\n        );\n        _created6[\"return\"] = returnFiber;\n        return _created6;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(\n        returnFiber,\n        oldFiber,\n        \"\" + newChild,\n        expirationTime\n      );\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          if (newChild.key === key) {\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(\n                returnFiber,\n                oldFiber,\n                newChild.props.children,\n                expirationTime,\n                key\n              );\n            }\n            return updateElement(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime\n            );\n          } else {\n            return null;\n          }\n        }\n\n        case REACT_CALL_TYPE: {\n          if (newChild.key === key) {\n            return updateCall(returnFiber, oldFiber, newChild, expirationTime);\n          } else {\n            return null;\n          }\n        }\n\n        case REACT_RETURN_TYPE: {\n          // Returns don't have keys. If the previous node is implicitly keyed\n          // we can continue to replace it without aborting even if it is not a\n          // yield.\n          if (key === null) {\n            return updateReturn(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime\n            );\n          } else {\n            return null;\n          }\n        }\n\n        case REACT_PORTAL_TYPE: {\n          if (newChild.key === key) {\n            return updatePortal(\n              returnFiber,\n              oldFiber,\n              newChild,\n              expirationTime\n            );\n          } else {\n            return null;\n          }\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(\n          returnFiber,\n          oldFiber,\n          newChild,\n          expirationTime,\n          null\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(\n    existingChildren,\n    returnFiber,\n    newIdx,\n    newChild,\n    expirationTime\n  ) {\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(\n        returnFiber,\n        matchedFiber,\n        \"\" + newChild,\n        expirationTime\n      );\n    }\n\n    if (typeof newChild === \"object\" && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          var _matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key\n            ) || null;\n          if (newChild.type === REACT_FRAGMENT_TYPE) {\n            return updateFragment(\n              returnFiber,\n              _matchedFiber,\n              newChild.props.children,\n              expirationTime,\n              newChild.key\n            );\n          }\n          return updateElement(\n            returnFiber,\n            _matchedFiber,\n            newChild,\n            expirationTime\n          );\n        }\n\n        case REACT_CALL_TYPE: {\n          var _matchedFiber2 =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key\n            ) || null;\n          return updateCall(\n            returnFiber,\n            _matchedFiber2,\n            newChild,\n            expirationTime\n          );\n        }\n\n        case REACT_RETURN_TYPE: {\n          // Returns don't have keys, so we neither have to check the old nor\n          // new node for the key. If both are returns, they match.\n          var _matchedFiber3 = existingChildren.get(newIdx) || null;\n          return updateReturn(\n            returnFiber,\n            _matchedFiber3,\n            newChild,\n            expirationTime\n          );\n        }\n\n        case REACT_PORTAL_TYPE: {\n          var _matchedFiber4 =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key\n            ) || null;\n          return updatePortal(\n            returnFiber,\n            _matchedFiber4,\n            newChild,\n            expirationTime\n          );\n        }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber5 = existingChildren.get(newIdx) || null;\n        return updateFragment(\n          returnFiber,\n          _matchedFiber5,\n          newChild,\n          expirationTime,\n          null\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== \"object\" || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_CALL_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== \"string\") {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning(\n            false,\n            \"Encountered two children with the same key, `%s`. \" +\n              \"Keys should be unique so that components maintain their identity \" +\n              \"across updates. Non-unique keys may cause children to be \" +\n              \"duplicated and/or omitted  the behavior is unsupported and \" +\n              \"could change in a future version.%s\",\n            key,\n            getCurrentFiberStackAddendum$1()\n          );\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(\n    returnFiber,\n    currentFirstChild,\n    newChildren,\n    expirationTime\n  ) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        expirationTime\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(\n          returnFiber,\n          newChildren[newIdx],\n          expirationTime\n        );\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        expirationTime\n      );\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren[\"delete\"](\n              _newFiber2.key === null ? newIdx : _newFiber2.key\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function(child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(\n    returnFiber,\n    currentFirstChild,\n    newChildrenIterable,\n    expirationTime\n  ) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    invariant(\n      typeof iteratorFn === \"function\",\n      \"An object is not an iterable. This error is likely caused by a bug in \" +\n        \"React. Please file an issue.\"\n    );\n\n    {\n      // Warn about using Maps as children\n      if (typeof newChildrenIterable.entries === \"function\") {\n        var possibleMap = newChildrenIterable;\n        if (possibleMap.entries === iteratorFn) {\n          warning(\n            didWarnAboutMaps,\n            \"Using Maps as children is unsupported and will likely yield \" +\n              \"unexpected results. Convert it to a sequence/iterable of keyed \" +\n              \"ReactElements instead.%s\",\n            getCurrentFiberStackAddendum$1()\n          );\n          didWarnAboutMaps = true;\n        }\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    invariant(newChildren != null, \"An iterable object provided no iterator.\");\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (\n      ;\n      oldFiber !== null && !step.done;\n      newIdx++, step = newChildren.next()\n    ) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        step.value,\n        expirationTime\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        step.value,\n        expirationTime\n      );\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren[\"delete\"](\n              _newFiber4.key === null ? newIdx : _newFiber4.key\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function(child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(\n    returnFiber,\n    currentFirstChild,\n    textContent,\n    expirationTime\n  ) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing[\"return\"] = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(\n      textContent,\n      returnFiber.internalContextTag,\n      expirationTime\n    );\n    created[\"return\"] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(\n    returnFiber,\n    currentFirstChild,\n    element,\n    expirationTime\n  ) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === Fragment\n            ? element.type === REACT_FRAGMENT_TYPE\n            : child.type === element.type\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(\n            child,\n            element.type === REACT_FRAGMENT_TYPE\n              ? element.props.children\n              : element.props,\n            expirationTime\n          );\n          existing.ref = coerceRef(child, element);\n          existing[\"return\"] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(\n        element.props.children,\n        returnFiber.internalContextTag,\n        expirationTime,\n        element.key\n      );\n      created[\"return\"] = returnFiber;\n      return created;\n    } else {\n      var _created7 = createFiberFromElement(\n        element,\n        returnFiber.internalContextTag,\n        expirationTime\n      );\n      _created7.ref = coerceRef(currentFirstChild, element);\n      _created7[\"return\"] = returnFiber;\n      return _created7;\n    }\n  }\n\n  function reconcileSingleCall(\n    returnFiber,\n    currentFirstChild,\n    call,\n    expirationTime\n  ) {\n    var key = call.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === CallComponent) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, call, expirationTime);\n          existing[\"return\"] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromCall(\n      call,\n      returnFiber.internalContextTag,\n      expirationTime\n    );\n    created[\"return\"] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleReturn(\n    returnFiber,\n    currentFirstChild,\n    returnNode,\n    expirationTime\n  ) {\n    // There's no need to check for keys on yields since they're stateless.\n    var child = currentFirstChild;\n    if (child !== null) {\n      if (child.tag === ReturnComponent) {\n        deleteRemainingChildren(returnFiber, child.sibling);\n        var existing = useFiber(child, null, expirationTime);\n        existing.type = returnNode.value;\n        existing[\"return\"] = returnFiber;\n        return existing;\n      } else {\n        deleteRemainingChildren(returnFiber, child);\n      }\n    }\n\n    var created = createFiberFromReturn(\n      returnNode,\n      returnFiber.internalContextTag,\n      expirationTime\n    );\n    created.type = returnNode.value;\n    created[\"return\"] = returnFiber;\n    return created;\n  }\n\n  function reconcileSinglePortal(\n    returnFiber,\n    currentFirstChild,\n    portal,\n    expirationTime\n  ) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === HostPortal &&\n          child.stateNode.containerInfo === portal.containerInfo &&\n          child.stateNode.implementation === portal.implementation\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing[\"return\"] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(\n      portal,\n      returnFiber.internalContextTag,\n      expirationTime\n    );\n    created[\"return\"] = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(\n    returnFiber,\n    currentFirstChild,\n    newChild,\n    expirationTime\n  ) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    if (\n      typeof newChild === \"object\" &&\n      newChild !== null &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      newChild.key === null\n    ) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === \"object\" && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(\n            reconcileSingleElement(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime\n            )\n          );\n\n        case REACT_CALL_TYPE:\n          return placeSingleChild(\n            reconcileSingleCall(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime\n            )\n          );\n        case REACT_RETURN_TYPE:\n          return placeSingleChild(\n            reconcileSingleReturn(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime\n            )\n          );\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(\n            reconcileSinglePortal(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              expirationTime\n            )\n          );\n      }\n    }\n\n    if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n      return placeSingleChild(\n        reconcileSingleTextNode(\n          returnFiber,\n          currentFirstChild,\n          \"\" + newChild,\n          expirationTime\n        )\n      );\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime\n      );\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        expirationTime\n      );\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === \"function\") {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === \"undefined\") {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent: {\n          {\n            var instance = returnFiber.stateNode;\n            if (instance.render._isMockFunction) {\n              // We allow auto-mocks to proceed as if they're returning null.\n              break;\n            }\n          }\n        }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent: {\n          var Component = returnFiber.type;\n          invariant(\n            false,\n            \"%s(...): Nothing was returned from render. This usually means a \" +\n              \"return statement is missing. Or, to render nothing, \" +\n              \"return null.\",\n            Component.displayName || Component.name || \"Component\"\n          );\n        }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\n\nfunction cloneChildFibers(current, workInProgress) {\n  invariant(\n    current === null || workInProgress.child === current.child,\n    \"Resuming work not yet implemented.\"\n  );\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(\n    currentChild,\n    currentChild.pendingProps,\n    currentChild.expirationTime\n  );\n  workInProgress.child = newChild;\n\n  newChild[\"return\"] = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(\n      currentChild,\n      currentChild.pendingProps,\n      currentChild.expirationTime\n    );\n    newChild[\"return\"] = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n{\n  var warnedAboutStatelessRefs = {};\n}\n\nvar ReactFiberBeginWork = function(\n  config,\n  hostContext,\n  hydrationContext,\n  scheduleWork,\n  computeExpirationForFiber\n) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n    useSyncScheduling = config.useSyncScheduling,\n    shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n  var pushHostContext = hostContext.pushHostContext,\n    pushHostContainer = hostContext.pushHostContainer;\n  var enterHydrationState = hydrationContext.enterHydrationState,\n    resetHydrationState = hydrationContext.resetHydrationState,\n    tryToClaimNextHydratableInstance =\n      hydrationContext.tryToClaimNextHydratableInstance;\n\n  var _ReactFiberClassCompo = ReactFiberClassComponent(\n      scheduleWork,\n      computeExpirationForFiber,\n      memoizeProps,\n      memoizeState\n    ),\n    adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n    constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n    mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n    updateClassInstance = _ReactFiberClassCompo.updateClassInstance;\n\n  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\n\n  function reconcileChildren(current, workInProgress, nextChildren) {\n    reconcileChildrenAtExpirationTime(\n      current,\n      workInProgress,\n      nextChildren,\n      workInProgress.expirationTime\n    );\n  }\n\n  function reconcileChildrenAtExpirationTime(\n    current,\n    workInProgress,\n    nextChildren,\n    renderExpirationTime\n  ) {\n    if (current === null) {\n      // If this is a fresh new component that hasn't been rendered yet, we\n      // won't update its child set by applying minimal side-effects. Instead,\n      // we will add them all to the child before it gets rendered. That means\n      // we can optimize this reconciliation pass by not tracking side-effects.\n      workInProgress.child = mountChildFibers(\n        workInProgress,\n        null,\n        nextChildren,\n        renderExpirationTime\n      );\n    } else {\n      // If the current child is the same as the work in progress, it means that\n      // we haven't yet started any work on these children. Therefore, we use\n      // the clone algorithm to create a copy of all the current children.\n\n      // If we had any progressed work already, that is invalid at this point so\n      // let's throw it out.\n      workInProgress.child = reconcileChildFibers(\n        workInProgress,\n        current.child,\n        nextChildren,\n        renderExpirationTime\n      );\n    }\n  }\n\n  function updateFragment(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (\n      nextChildren === null ||\n      workInProgress.memoizedProps === nextChildren\n    ) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function markRef(current, workInProgress) {\n    var ref = workInProgress.ref;\n    if (ref !== null && (!current || current.ref !== ref)) {\n      // Schedule a Ref effect\n      workInProgress.effectTag |= Ref;\n    }\n  }\n\n  function updateFunctionalComponent(current, workInProgress) {\n    var fn = workInProgress.type;\n    var nextProps = workInProgress.pendingProps;\n\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else {\n      if (workInProgress.memoizedProps === nextProps) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // TODO: consider bringing fn.shouldComponentUpdate() back.\n      // It used to be here.\n    }\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var nextChildren;\n\n    {\n      ReactCurrentOwner.current = workInProgress;\n      ReactDebugCurrentFiber.setCurrentPhase(\"render\");\n      nextChildren = fn(nextProps, context);\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateClassComponent(current, workInProgress, renderExpirationTime) {\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = pushContextProvider(workInProgress);\n\n    var shouldUpdate = void 0;\n    if (current === null) {\n      if (!workInProgress.stateNode) {\n        // In the initial pass we might need to construct the instance.\n        constructClassInstance(workInProgress, workInProgress.pendingProps);\n        mountClassInstance(workInProgress, renderExpirationTime);\n        shouldUpdate = true;\n      } else {\n        invariant(false, \"Resuming work not yet implemented.\");\n        // In a resume, we'll already have an instance we can reuse.\n        // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);\n      }\n    } else {\n      shouldUpdate = updateClassInstance(\n        current,\n        workInProgress,\n        renderExpirationTime\n      );\n    }\n    return finishClassComponent(\n      current,\n      workInProgress,\n      shouldUpdate,\n      hasContext\n    );\n  }\n\n  function finishClassComponent(\n    current,\n    workInProgress,\n    shouldUpdate,\n    hasContext\n  ) {\n    // Refs should update even if shouldComponentUpdate returns false\n    markRef(current, workInProgress);\n\n    if (!shouldUpdate) {\n      // Context providers should defer to sCU for rendering\n      if (hasContext) {\n        invalidateContextProvider(workInProgress, false);\n      }\n\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n\n    // Rerender\n    ReactCurrentOwner.current = workInProgress;\n    var nextChildren = void 0;\n    {\n      ReactDebugCurrentFiber.setCurrentPhase(\"render\");\n      nextChildren = instance.render();\n      if (debugRenderPhaseSideEffects) {\n        instance.render();\n      }\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    // Memoize props and state using the values we just used to render.\n    // TODO: Restructure so we never read values from the instance.\n    memoizeState(workInProgress, instance.state);\n    memoizeProps(workInProgress, instance.props);\n\n    // The context might have changed so we need to recalculate it.\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, true);\n    }\n\n    return workInProgress.child;\n  }\n\n  function pushHostRootContext(workInProgress) {\n    var root = workInProgress.stateNode;\n    if (root.pendingContext) {\n      pushTopLevelContextObject(\n        workInProgress,\n        root.pendingContext,\n        root.pendingContext !== root.context\n      );\n    } else if (root.context) {\n      // Should always be set\n      pushTopLevelContextObject(workInProgress, root.context, false);\n    }\n    pushHostContainer(workInProgress, root.containerInfo);\n  }\n\n  function updateHostRoot(current, workInProgress, renderExpirationTime) {\n    pushHostRootContext(workInProgress);\n    var updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      var prevState = workInProgress.memoizedState;\n      var state = processUpdateQueue(\n        current,\n        workInProgress,\n        updateQueue,\n        null,\n        null,\n        renderExpirationTime\n      );\n      if (prevState === state) {\n        // If the state is the same as before, that's a bailout because we had\n        // no work that expires at this time.\n        resetHydrationState();\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      var element = state.element;\n      var root = workInProgress.stateNode;\n      if (\n        (current === null || current.child === null) &&\n        root.hydrate &&\n        enterHydrationState(workInProgress)\n      ) {\n        // If we don't have any current children this might be the first pass.\n        // We always try to hydrate. If this isn't a hydration pass there won't\n        // be any children to hydrate which is effectively the same thing as\n        // not hydrating.\n\n        // This is a bit of a hack. We track the host root as a placement to\n        // know that we're currently in a mounting state. That way isMounted\n        // works as expected. We must reset this before committing.\n        // TODO: Delete this when we delete isMounted and findDOMNode.\n        workInProgress.effectTag |= Placement;\n\n        // Ensure that children mount into this root without tracking\n        // side-effects. This ensures that we don't store Placement effects on\n        // nodes that will be hydrated.\n        workInProgress.child = mountChildFibers(\n          workInProgress,\n          null,\n          element,\n          renderExpirationTime\n        );\n      } else {\n        // Otherwise reset hydration state in case we aborted and resumed another\n        // root.\n        resetHydrationState();\n        reconcileChildren(current, workInProgress, element);\n      }\n      memoizeState(workInProgress, state);\n      return workInProgress.child;\n    }\n    resetHydrationState();\n    // If there is no update queue, that's a bailout because the root has no props.\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  function updateHostComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContext(workInProgress);\n\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n\n    var type = workInProgress.type;\n    var memoizedProps = workInProgress.memoizedProps;\n    var nextProps = workInProgress.pendingProps;\n    var prevProps = current !== null ? current.memoizedProps : null;\n\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (memoizedProps === nextProps) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextProps.children;\n    var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n    if (isDirectTextChild) {\n      // We special case a direct text child of a host node. This is a common\n      // case. We won't handle it as a reified child. We will instead handle\n      // this in the host environment that also have access to this prop. That\n      // avoids allocating another HostText fiber and traversing it.\n      nextChildren = null;\n    } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n      // If we're switching from a direct text child to a normal child, or to\n      // empty, we need to schedule the text content to be reset.\n      workInProgress.effectTag |= ContentReset;\n    }\n\n    markRef(current, workInProgress);\n\n    // Check the host config to see if the children are offscreen/hidden.\n    if (\n      renderExpirationTime !== Never &&\n      !useSyncScheduling &&\n      shouldDeprioritizeSubtree(type, nextProps)\n    ) {\n      // Down-prioritize the children.\n      workInProgress.expirationTime = Never;\n      // Bailout and come back to this fiber later.\n      return null;\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateHostText(current, workInProgress) {\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n    var nextProps = workInProgress.pendingProps;\n    memoizeProps(workInProgress, nextProps);\n    // Nothing to do here. This is terminal. We'll do the completion step\n    // immediately after.\n    return null;\n  }\n\n  function mountIndeterminateComponent(\n    current,\n    workInProgress,\n    renderExpirationTime\n  ) {\n    invariant(\n      current === null,\n      \"An indeterminate component should never have mounted. This error is \" +\n        \"likely caused by a bug in React. Please file an issue.\"\n    );\n    var fn = workInProgress.type;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var value;\n\n    {\n      if (fn.prototype && typeof fn.prototype.render === \"function\") {\n        var componentName = getComponentName(workInProgress);\n        warning(\n          false,\n          \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" +\n            \"This is likely to cause errors. Change %s to extend React.Component instead.\",\n          componentName,\n          componentName\n        );\n      }\n      ReactCurrentOwner.current = workInProgress;\n      value = fn(props, context);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n\n    if (\n      typeof value === \"object\" &&\n      value !== null &&\n      typeof value.render === \"function\"\n    ) {\n      // Proceed under the assumption that this is a class instance\n      workInProgress.tag = ClassComponent;\n\n      // Push context providers early to prevent context stack mismatches.\n      // During mounting we don't know the child context yet as the instance doesn't exist.\n      // We will invalidate the child context in finishClassComponent() right after rendering.\n      var hasContext = pushContextProvider(workInProgress);\n      adoptClassInstance(workInProgress, value);\n      mountClassInstance(workInProgress, renderExpirationTime);\n      return finishClassComponent(current, workInProgress, true, hasContext);\n    } else {\n      // Proceed under the assumption that this is a functional component\n      workInProgress.tag = FunctionalComponent;\n      {\n        var Component = workInProgress.type;\n\n        if (Component) {\n          warning(\n            !Component.childContextTypes,\n            \"%s(...): childContextTypes cannot be defined on a functional component.\",\n            Component.displayName || Component.name || \"Component\"\n          );\n        }\n        if (workInProgress.ref !== null) {\n          var info = \"\";\n          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n          if (ownerName) {\n            info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n          }\n\n          var warningKey = ownerName || workInProgress._debugID || \"\";\n          var debugSource = workInProgress._debugSource;\n          if (debugSource) {\n            warningKey = debugSource.fileName + \":\" + debugSource.lineNumber;\n          }\n          if (!warnedAboutStatelessRefs[warningKey]) {\n            warnedAboutStatelessRefs[warningKey] = true;\n            warning(\n              false,\n              \"Stateless function components cannot be given refs. \" +\n                \"Attempts to access this ref will fail.%s%s\",\n              info,\n              ReactDebugCurrentFiber.getCurrentFiberStackAddendum()\n            );\n          }\n        }\n      }\n      reconcileChildren(current, workInProgress, value);\n      memoizeProps(workInProgress, props);\n      return workInProgress.child;\n    }\n  }\n\n  function updateCallComponent(current, workInProgress, renderExpirationTime) {\n    var nextCall = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (workInProgress.memoizedProps === nextCall) {\n      nextCall = workInProgress.memoizedProps;\n      // TODO: When bailing out, we might need to return the stateNode instead\n      // of the child. To check it for work.\n      // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextCall.children;\n\n    // The following is a fork of reconcileChildrenAtExpirationTime but using\n    // stateNode to store the child.\n    if (current === null) {\n      workInProgress.stateNode = mountChildFibers(\n        workInProgress,\n        workInProgress.stateNode,\n        nextChildren,\n        renderExpirationTime\n      );\n    } else {\n      workInProgress.stateNode = reconcileChildFibers(\n        workInProgress,\n        workInProgress.stateNode,\n        nextChildren,\n        renderExpirationTime\n      );\n    }\n\n    memoizeProps(workInProgress, nextCall);\n    // This doesn't take arbitrary time so we could synchronously just begin\n    // eagerly do the work of workInProgress.child as an optimization.\n    return workInProgress.stateNode;\n  }\n\n  function updatePortalComponent(\n    current,\n    workInProgress,\n    renderExpirationTime\n  ) {\n    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    if (current === null) {\n      // Portals are special because we don't append the children during mount\n      // but at commit. Therefore we need to track insertions which the normal\n      // flow doesn't do during mount. This doesn't happen at the root because\n      // the root always starts with a \"current\" with a null child.\n      // TODO: Consider unifying this with how the root works.\n      workInProgress.child = reconcileChildFibers(\n        workInProgress,\n        null,\n        nextChildren,\n        renderExpirationTime\n      );\n      memoizeProps(workInProgress, nextChildren);\n    } else {\n      reconcileChildren(current, workInProgress, nextChildren);\n      memoizeProps(workInProgress, nextChildren);\n    }\n    return workInProgress.child;\n  }\n\n  /*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\n  function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: We should ideally be able to bail out early if the children have no\n    // more work to do. However, since we don't have a separation of this\n    // Fiber's priority and its children yet - we don't know without doing lots\n    // of the same work we do anyway. Once we have that separation we can just\n    // bail out here if the children has no more work at this priority level.\n    // if (workInProgress.priorityOfChildren <= priorityLevel) {\n    //   // If there are side-effects in these children that have not yet been\n    //   // committed we need to ensure that they get properly transferred up.\n    //   if (current && current.child !== workInProgress.child) {\n    //     reuseChildrenEffects(workInProgress, child);\n    //   }\n    //   return null;\n    // }\n\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n  }\n\n  function bailoutOnLowPriority(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n    // See PR 8590 discussion for context\n    switch (workInProgress.tag) {\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      case ClassComponent:\n        pushContextProvider(workInProgress);\n        break;\n      case HostPortal:\n        pushHostContainer(\n          workInProgress,\n          workInProgress.stateNode.containerInfo\n        );\n        break;\n    }\n    // TODO: What if this is currently in progress?\n    // How can that happen? How is this not being cloned?\n    return null;\n  }\n\n  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n  function memoizeProps(workInProgress, nextProps) {\n    workInProgress.memoizedProps = nextProps;\n  }\n\n  function memoizeState(workInProgress, nextState) {\n    workInProgress.memoizedState = nextState;\n    // Don't reset the updateQueue, in case there are pending updates. Resetting\n    // is handled by processUpdateQueue.\n  }\n\n  function beginWork(current, workInProgress, renderExpirationTime) {\n    if (\n      workInProgress.expirationTime === NoWork ||\n      workInProgress.expirationTime > renderExpirationTime\n    ) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n        return mountIndeterminateComponent(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case FunctionalComponent:\n        return updateFunctionalComponent(current, workInProgress);\n      case ClassComponent:\n        return updateClassComponent(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case HostRoot:\n        return updateHostRoot(current, workInProgress, renderExpirationTime);\n      case HostComponent:\n        return updateHostComponent(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case HostText:\n        return updateHostText(current, workInProgress);\n      case CallHandlerPhase:\n        // This is a restart. Reset the tag to the initial phase.\n        workInProgress.tag = CallComponent;\n      // Intentionally fall through since this is now the same.\n      case CallComponent:\n        return updateCallComponent(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case ReturnComponent:\n        // A return component is just a placeholder, we can just run through the\n        // next one immediately.\n        return null;\n      case HostPortal:\n        return updatePortalComponent(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case Fragment:\n        return updateFragment(current, workInProgress);\n      default:\n        invariant(\n          false,\n          \"Unknown unit of work tag. This error is likely caused by a bug in \" +\n            \"React. Please file an issue.\"\n        );\n    }\n  }\n\n  function beginFailedWork(current, workInProgress, renderExpirationTime) {\n    // Push context providers here to avoid a push/pop context mismatch.\n    switch (workInProgress.tag) {\n      case ClassComponent:\n        pushContextProvider(workInProgress);\n        break;\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      default:\n        invariant(\n          false,\n          \"Invalid type of work. This error is likely caused by a bug in React. \" +\n            \"Please file an issue.\"\n        );\n    }\n\n    // Add an error effect so we can handle the error during the commit phase\n    workInProgress.effectTag |= Err;\n\n    // This is a weird case where we do \"resume\" work  work that failed on\n    // our first attempt. Because we no longer have a notion of \"progressed\n    // deletions,\" reset the child to the current child to make sure we delete\n    // it again. TODO: Find a better way to handle this, perhaps during a more\n    // general overhaul of error handling.\n    if (current === null) {\n      workInProgress.child = null;\n    } else if (workInProgress.child !== current.child) {\n      workInProgress.child = current.child;\n    }\n\n    if (\n      workInProgress.expirationTime === NoWork ||\n      workInProgress.expirationTime > renderExpirationTime\n    ) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    // If we don't bail out, we're going be recomputing our children so we need\n    // to drop our effect list.\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    // Unmount the current children as if the component rendered null\n    var nextChildren = null;\n    reconcileChildrenAtExpirationTime(\n      current,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime\n    );\n\n    if (workInProgress.tag === ClassComponent) {\n      var instance = workInProgress.stateNode;\n      workInProgress.memoizedProps = instance.props;\n      workInProgress.memoizedState = instance.state;\n    }\n\n    return workInProgress.child;\n  }\n\n  return {\n    beginWork: beginWork,\n    beginFailedWork: beginFailedWork\n  };\n};\n\nvar ReactFiberCompleteWork = function(config, hostContext, hydrationContext) {\n  var createInstance = config.createInstance,\n    createTextInstance = config.createTextInstance,\n    appendInitialChild = config.appendInitialChild,\n    finalizeInitialChildren = config.finalizeInitialChildren,\n    prepareUpdate = config.prepareUpdate,\n    mutation = config.mutation,\n    persistence = config.persistence;\n  var getRootHostContainer = hostContext.getRootHostContainer,\n    popHostContext = hostContext.popHostContext,\n    getHostContext = hostContext.getHostContext,\n    popHostContainer = hostContext.popHostContainer;\n  var prepareToHydrateHostInstance =\n      hydrationContext.prepareToHydrateHostInstance,\n    prepareToHydrateHostTextInstance =\n      hydrationContext.prepareToHydrateHostTextInstance,\n    popHydrationState = hydrationContext.popHydrationState;\n\n  function markUpdate(workInProgress) {\n    // Tag the fiber with an update effect. This turns a Placement into\n    // an UpdateAndPlacement.\n    workInProgress.effectTag |= Update;\n  }\n\n  function markRef(workInProgress) {\n    workInProgress.effectTag |= Ref;\n  }\n\n  function appendAllReturns(returns, workInProgress) {\n    var node = workInProgress.stateNode;\n    if (node) {\n      node[\"return\"] = workInProgress;\n    }\n    while (node !== null) {\n      if (\n        node.tag === HostComponent ||\n        node.tag === HostText ||\n        node.tag === HostPortal\n      ) {\n        invariant(false, \"A call cannot have host component children.\");\n      } else if (node.tag === ReturnComponent) {\n        returns.push(node.type);\n      } else if (node.child !== null) {\n        node.child[\"return\"] = node;\n        node = node.child;\n        continue;\n      }\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || node[\"return\"] === workInProgress) {\n          return;\n        }\n        node = node[\"return\"];\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n    }\n  }\n\n  function moveCallToHandlerPhase(\n    current,\n    workInProgress,\n    renderExpirationTime\n  ) {\n    var call = workInProgress.memoizedProps;\n    invariant(\n      call,\n      \"Should be resolved by now. This error is likely caused by a bug in \" +\n        \"React. Please file an issue.\"\n    );\n\n    // First step of the call has completed. Now we need to do the second.\n    // TODO: It would be nice to have a multi stage call represented by a\n    // single component, or at least tail call optimize nested ones. Currently\n    // that requires additional fields that we don't want to add to the fiber.\n    // So this requires nested handlers.\n    // Note: This doesn't mutate the alternate node. I don't think it needs to\n    // since this stage is reset for every pass.\n    workInProgress.tag = CallHandlerPhase;\n\n    // Build up the returns.\n    // TODO: Compare this to a generator or opaque helpers like Children.\n    var returns = [];\n    appendAllReturns(returns, workInProgress);\n    var fn = call.handler;\n    var props = call.props;\n    var nextChildren = fn(props, returns);\n\n    var currentFirstChild = current !== null ? current.child : null;\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      currentFirstChild,\n      nextChildren,\n      renderExpirationTime\n    );\n    return workInProgress.child;\n  }\n\n  function appendAllChildren(parent, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child[\"return\"] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || node[\"return\"] === workInProgress) {\n          return;\n        }\n        node = node[\"return\"];\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n    }\n  }\n\n  var updateHostContainer = void 0;\n  var updateHostComponent = void 0;\n  var updateHostText = void 0;\n  if (mutation) {\n    if (enableMutatingReconciler) {\n      // Mutation mode\n      updateHostContainer = function(workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function(\n        current,\n        workInProgress,\n        updatePayload,\n        type,\n        oldProps,\n        newProps,\n        rootContainerInstance\n      ) {\n        // TODO: Type this specific to this type of component.\n        workInProgress.updateQueue = updatePayload;\n        // If the update payload indicates that there is a change or if there\n        // is a new ref we mark this as an update. All the work is done in commitWork.\n        if (updatePayload) {\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostText = function(current, workInProgress, oldText, newText) {\n        // If the text differs, mark it as an update. All the work in done in commitWork.\n        if (oldText !== newText) {\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, \"Mutating reconciler is disabled.\");\n    }\n  } else if (persistence) {\n    if (enablePersistentReconciler) {\n      // Persistent host tree mode\n      var cloneInstance = persistence.cloneInstance,\n        createContainerChildSet = persistence.createContainerChildSet,\n        appendChildToContainerChildSet =\n          persistence.appendChildToContainerChildSet,\n        finalizeContainerChildren = persistence.finalizeContainerChildren;\n\n      // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n      var appendAllChildrenToContainer = function(\n        containerChildSet,\n        workInProgress\n      ) {\n        // We only have the top Fiber that was created but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = workInProgress.child;\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            appendChildToContainerChildSet(containerChildSet, node.stateNode);\n          } else if (node.tag === HostPortal) {\n            // If we have a portal child, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child[\"return\"] = node;\n            node = node.child;\n            continue;\n          }\n          if (node === workInProgress) {\n            return;\n          }\n          while (node.sibling === null) {\n            if (node[\"return\"] === null || node[\"return\"] === workInProgress) {\n              return;\n            }\n            node = node[\"return\"];\n          }\n          node.sibling[\"return\"] = node[\"return\"];\n          node = node.sibling;\n        }\n      };\n      updateHostContainer = function(workInProgress) {\n        var portalOrRoot = workInProgress.stateNode;\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        if (childrenUnchanged) {\n          // No changes, just reuse the existing instance.\n        } else {\n          var container = portalOrRoot.containerInfo;\n          var newChildSet = createContainerChildSet(container);\n          if (finalizeContainerChildren(container, newChildSet)) {\n            markUpdate(workInProgress);\n          }\n          portalOrRoot.pendingChildren = newChildSet;\n          // If children might have changed, we have to add them all to the set.\n          appendAllChildrenToContainer(newChildSet, workInProgress);\n          // Schedule an update on the container to swap out the container.\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostComponent = function(\n        current,\n        workInProgress,\n        updatePayload,\n        type,\n        oldProps,\n        newProps,\n        rootContainerInstance\n      ) {\n        // If there are no effects associated with this node, then none of our children had any updates.\n        // This guarantees that we can reuse all of them.\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        var currentInstance = current.stateNode;\n        if (childrenUnchanged && updatePayload === null) {\n          // No changes, just reuse the existing instance.\n          // Note that this might release a previous clone.\n          workInProgress.stateNode = currentInstance;\n        } else {\n          var recyclableInstance = workInProgress.stateNode;\n          var newInstance = cloneInstance(\n            currentInstance,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            workInProgress,\n            childrenUnchanged,\n            recyclableInstance\n          );\n          if (\n            finalizeInitialChildren(\n              newInstance,\n              type,\n              newProps,\n              rootContainerInstance\n            )\n          ) {\n            markUpdate(workInProgress);\n          }\n          workInProgress.stateNode = newInstance;\n          if (childrenUnchanged) {\n            // If there are no other effects in this tree, we need to flag this node as having one.\n            // Even though we're not going to use it for anything.\n            // Otherwise parents won't know that there are new children to propagate upwards.\n            markUpdate(workInProgress);\n          } else {\n            // If children might have changed, we have to add them all to the set.\n            appendAllChildren(newInstance, workInProgress);\n          }\n        }\n      };\n      updateHostText = function(current, workInProgress, oldText, newText) {\n        if (oldText !== newText) {\n          // If the text content differs, we'll create a new text instance for it.\n          var rootContainerInstance = getRootHostContainer();\n          var currentHostContext = getHostContext();\n          workInProgress.stateNode = createTextInstance(\n            newText,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress\n          );\n          // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n          // This lets the parents know that at least one of their children has changed.\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, \"Persistent reconciler is disabled.\");\n    }\n  } else {\n    if (enableNoopReconciler) {\n      // No host operations\n      updateHostContainer = function(workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function(\n        current,\n        workInProgress,\n        updatePayload,\n        type,\n        oldProps,\n        newProps,\n        rootContainerInstance\n      ) {\n        // Noop\n      };\n      updateHostText = function(current, workInProgress, oldText, newText) {\n        // Noop\n      };\n    } else {\n      invariant(false, \"Noop reconciler is disabled.\");\n    }\n  }\n\n  function completeWork(current, workInProgress, renderExpirationTime) {\n    var newProps = workInProgress.pendingProps;\n    switch (workInProgress.tag) {\n      case FunctionalComponent:\n        return null;\n      case ClassComponent: {\n        // We are leaving this subtree, so pop context if any.\n        popContextProvider(workInProgress);\n        return null;\n      }\n      case HostRoot: {\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        var fiberRoot = workInProgress.stateNode;\n        if (fiberRoot.pendingContext) {\n          fiberRoot.context = fiberRoot.pendingContext;\n          fiberRoot.pendingContext = null;\n        }\n\n        if (current === null || current.child === null) {\n          // If we hydrated, pop so that we can delete any remaining children\n          // that weren't hydrated.\n          popHydrationState(workInProgress);\n          // This resets the hacky state to fix isMounted before committing.\n          // TODO: Delete this when we delete isMounted and findDOMNode.\n          workInProgress.effectTag &= ~Placement;\n        }\n        updateHostContainer(workInProgress);\n        return null;\n      }\n      case HostComponent: {\n        popHostContext(workInProgress);\n        var rootContainerInstance = getRootHostContainer();\n        var type = workInProgress.type;\n        if (current !== null && workInProgress.stateNode != null) {\n          // If we have an alternate, that means this is an update and we need to\n          // schedule a side-effect to do the updates.\n          var oldProps = current.memoizedProps;\n          // If we get updated because one of our children updated, we don't\n          // have newProps so we'll have to reuse them.\n          // TODO: Split the update API as separate for the props vs. children.\n          // Even better would be if children weren't special cased at all tho.\n          var instance = workInProgress.stateNode;\n          var currentHostContext = getHostContext();\n          var updatePayload = prepareUpdate(\n            instance,\n            type,\n            oldProps,\n            newProps,\n            rootContainerInstance,\n            currentHostContext\n          );\n\n          updateHostComponent(\n            current,\n            workInProgress,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            rootContainerInstance\n          );\n\n          if (current.ref !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n        } else {\n          if (!newProps) {\n            invariant(\n              workInProgress.stateNode !== null,\n              \"We must have new props for new mounts. This error is likely \" +\n                \"caused by a bug in React. Please file an issue.\"\n            );\n            // This can happen when we abort work.\n            return null;\n          }\n\n          var _currentHostContext = getHostContext();\n          // TODO: Move createInstance to beginWork and keep it on a context\n          // \"stack\" as the parent. Then append children as we go in beginWork\n          // or completeWork depending on we want to add then top->down or\n          // bottom->up. Top->down is faster in IE11.\n          var wasHydrated = popHydrationState(workInProgress);\n          if (wasHydrated) {\n            // TODO: Move this and createInstance step into the beginPhase\n            // to consolidate.\n            if (\n              prepareToHydrateHostInstance(\n                workInProgress,\n                rootContainerInstance,\n                _currentHostContext\n              )\n            ) {\n              // If changes to the hydrated node needs to be applied at the\n              // commit-phase we mark this as such.\n              markUpdate(workInProgress);\n            }\n          } else {\n            var _instance = createInstance(\n              type,\n              newProps,\n              rootContainerInstance,\n              _currentHostContext,\n              workInProgress\n            );\n\n            appendAllChildren(_instance, workInProgress);\n\n            // Certain renderers require commit-time effects for initial mount.\n            // (eg DOM renderer supports auto-focus for certain elements).\n            // Make sure such renderers get scheduled for later work.\n            if (\n              finalizeInitialChildren(\n                _instance,\n                type,\n                newProps,\n                rootContainerInstance\n              )\n            ) {\n              markUpdate(workInProgress);\n            }\n            workInProgress.stateNode = _instance;\n          }\n\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef(workInProgress);\n          }\n        }\n        return null;\n      }\n      case HostText: {\n        var newText = newProps;\n        if (current && workInProgress.stateNode != null) {\n          var oldText = current.memoizedProps;\n          // If we have an alternate, that means this is an update and we need\n          // to schedule a side-effect to do the updates.\n          updateHostText(current, workInProgress, oldText, newText);\n        } else {\n          if (typeof newText !== \"string\") {\n            invariant(\n              workInProgress.stateNode !== null,\n              \"We must have new props for new mounts. This error is likely \" +\n                \"caused by a bug in React. Please file an issue.\"\n            );\n            // This can happen when we abort work.\n            return null;\n          }\n          var _rootContainerInstance = getRootHostContainer();\n          var _currentHostContext2 = getHostContext();\n          var _wasHydrated = popHydrationState(workInProgress);\n          if (_wasHydrated) {\n            if (prepareToHydrateHostTextInstance(workInProgress)) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            workInProgress.stateNode = createTextInstance(\n              newText,\n              _rootContainerInstance,\n              _currentHostContext2,\n              workInProgress\n            );\n          }\n        }\n        return null;\n      }\n      case CallComponent:\n        return moveCallToHandlerPhase(\n          current,\n          workInProgress,\n          renderExpirationTime\n        );\n      case CallHandlerPhase:\n        // Reset the tag to now be a first phase call.\n        workInProgress.tag = CallComponent;\n        return null;\n      case ReturnComponent:\n        // Does nothing.\n        return null;\n      case Fragment:\n        return null;\n      case HostPortal:\n        popHostContainer(workInProgress);\n        updateHostContainer(workInProgress);\n        return null;\n      // Error cases\n      case IndeterminateComponent:\n        invariant(\n          false,\n          \"An indeterminate component should have become determinate before \" +\n            \"completing. This error is likely caused by a bug in React. Please \" +\n            \"file an issue.\"\n        );\n      // eslint-disable-next-line no-fallthrough\n      default:\n        invariant(\n          false,\n          \"Unknown unit of work tag. This error is likely caused by a bug in \" +\n            \"React. Please file an issue.\"\n        );\n    }\n  }\n\n  return {\n    completeWork: completeWork\n  };\n};\n\nvar invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\n\nvar ReactFiberCommitWork = function(config, captureError) {\n  var getPublicInstance = config.getPublicInstance,\n    mutation = config.mutation,\n    persistence = config.persistence;\n\n  var callComponentWillUnmountWithTimer = function(current, instance) {\n    startPhaseTimer(current, \"componentWillUnmount\");\n    instance.props = current.memoizedProps;\n    instance.state = current.memoizedState;\n    instance.componentWillUnmount();\n    stopPhaseTimer();\n  };\n\n  // Capture errors so they don't interrupt unmounting.\n  function safelyCallComponentWillUnmount(current, instance) {\n    {\n      invokeGuardedCallback$2(\n        null,\n        callComponentWillUnmountWithTimer,\n        null,\n        current,\n        instance\n      );\n      if (hasCaughtError$1()) {\n        var unmountError = clearCaughtError$1();\n        captureError(current, unmountError);\n      }\n    }\n  }\n\n  function safelyDetachRef(current) {\n    var ref = current.ref;\n    if (ref !== null) {\n      {\n        invokeGuardedCallback$2(null, ref, null, null);\n        if (hasCaughtError$1()) {\n          var refError = clearCaughtError$1();\n          captureError(current, refError);\n        }\n      }\n    }\n  }\n\n  function commitLifeCycles(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent: {\n        var instance = finishedWork.stateNode;\n        if (finishedWork.effectTag & Update) {\n          if (current === null) {\n            startPhaseTimer(finishedWork, \"componentDidMount\");\n            instance.props = finishedWork.memoizedProps;\n            instance.state = finishedWork.memoizedState;\n            instance.componentDidMount();\n            stopPhaseTimer();\n          } else {\n            var prevProps = current.memoizedProps;\n            var prevState = current.memoizedState;\n            startPhaseTimer(finishedWork, \"componentDidUpdate\");\n            instance.props = finishedWork.memoizedProps;\n            instance.state = finishedWork.memoizedState;\n            instance.componentDidUpdate(prevProps, prevState);\n            stopPhaseTimer();\n          }\n        }\n        var updateQueue = finishedWork.updateQueue;\n        if (updateQueue !== null) {\n          commitCallbacks(updateQueue, instance);\n        }\n        return;\n      }\n      case HostRoot: {\n        var _updateQueue = finishedWork.updateQueue;\n        if (_updateQueue !== null) {\n          var _instance =\n            finishedWork.child !== null ? finishedWork.child.stateNode : null;\n          commitCallbacks(_updateQueue, _instance);\n        }\n        return;\n      }\n      case HostComponent: {\n        var _instance2 = finishedWork.stateNode;\n\n        // Renderers may schedule work to be done after host components are mounted\n        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n        // These effects should only be committed when components are first mounted,\n        // aka when there is no current/alternate.\n        if (current === null && finishedWork.effectTag & Update) {\n          var type = finishedWork.type;\n          var props = finishedWork.memoizedProps;\n          commitMount(_instance2, type, props, finishedWork);\n        }\n\n        return;\n      }\n      case HostText: {\n        // We have no life-cycles associated with text.\n        return;\n      }\n      case HostPortal: {\n        // We have no life-cycles associated with portals.\n        return;\n      }\n      default: {\n        invariant(\n          false,\n          \"This unit of work tag should not have side-effects. This error is \" +\n            \"likely caused by a bug in React. Please file an issue.\"\n        );\n      }\n    }\n  }\n\n  function commitAttachRef(finishedWork) {\n    var ref = finishedWork.ref;\n    if (ref !== null) {\n      var instance = finishedWork.stateNode;\n      switch (finishedWork.tag) {\n        case HostComponent:\n          ref(getPublicInstance(instance));\n          break;\n        default:\n          ref(instance);\n      }\n    }\n  }\n\n  function commitDetachRef(current) {\n    var currentRef = current.ref;\n    if (currentRef !== null) {\n      currentRef(null);\n    }\n  }\n\n  // User-originating errors (lifecycles and refs) should not interrupt\n  // deletion, so don't let them throw. Host-originating errors should\n  // interrupt deletion, so it's okay\n  function commitUnmount(current) {\n    if (typeof onCommitUnmount === \"function\") {\n      onCommitUnmount(current);\n    }\n\n    switch (current.tag) {\n      case ClassComponent: {\n        safelyDetachRef(current);\n        var instance = current.stateNode;\n        if (typeof instance.componentWillUnmount === \"function\") {\n          safelyCallComponentWillUnmount(current, instance);\n        }\n        return;\n      }\n      case HostComponent: {\n        safelyDetachRef(current);\n        return;\n      }\n      case CallComponent: {\n        commitNestedUnmounts(current.stateNode);\n        return;\n      }\n      case HostPortal: {\n        // TODO: this is recursive.\n        // We are also not using this parent because\n        // the portal will get pushed immediately.\n        if (enableMutatingReconciler && mutation) {\n          unmountHostComponents(current);\n        } else if (enablePersistentReconciler && persistence) {\n          emptyPortalContainer(current);\n        }\n        return;\n      }\n    }\n  }\n\n  function commitNestedUnmounts(root) {\n    // While we're inside a removed host node we don't want to call\n    // removeChild on the inner nodes because they're removed by the top\n    // call anyway. We also want to call componentWillUnmount on all\n    // composites before this host node is removed from the tree. Therefore\n    var node = root;\n    while (true) {\n      commitUnmount(node);\n      // Visit children because they may contain more composite or host nodes.\n      // Skip portals because commitUnmount() currently visits them recursively.\n      if (\n        node.child !== null &&\n        // If we use mutation we drill down into portals using commitUnmount above.\n        // If we don't use mutation we drill down into portals here instead.\n        (!mutation || node.tag !== HostPortal)\n      ) {\n        node.child[\"return\"] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === root) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || node[\"return\"] === root) {\n          return;\n        }\n        node = node[\"return\"];\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n    }\n  }\n\n  function detachFiber(current) {\n    // Cut off the return pointers to disconnect it from the tree. Ideally, we\n    // should clear the child pointer of the parent alternate to let this\n    // get GC:ed but we don't know which for sure which parent is the current\n    // one so we'll settle for GC:ing the subtree of this child. This child\n    // itself will be GC:ed when the parent updates the next time.\n    current[\"return\"] = null;\n    current.child = null;\n    if (current.alternate) {\n      current.alternate.child = null;\n      current.alternate[\"return\"] = null;\n    }\n  }\n\n  if (!mutation) {\n    var commitContainer = void 0;\n    if (persistence) {\n      var replaceContainerChildren = persistence.replaceContainerChildren,\n        createContainerChildSet = persistence.createContainerChildSet;\n\n      var emptyPortalContainer = function(current) {\n        var portal = current.stateNode;\n        var containerInfo = portal.containerInfo;\n\n        var emptyChildSet = createContainerChildSet(containerInfo);\n        replaceContainerChildren(containerInfo, emptyChildSet);\n      };\n      commitContainer = function(finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent: {\n            return;\n          }\n          case HostComponent: {\n            return;\n          }\n          case HostText: {\n            return;\n          }\n          case HostRoot:\n          case HostPortal: {\n            var portalOrRoot = finishedWork.stateNode;\n            var containerInfo = portalOrRoot.containerInfo,\n              _pendingChildren = portalOrRoot.pendingChildren;\n\n            replaceContainerChildren(containerInfo, _pendingChildren);\n            return;\n          }\n          default: {\n            invariant(\n              false,\n              \"This unit of work tag should not have side-effects. This error is \" +\n                \"likely caused by a bug in React. Please file an issue.\"\n            );\n          }\n        }\n      };\n    } else {\n      commitContainer = function(finishedWork) {\n        // Noop\n      };\n    }\n    if (enablePersistentReconciler || enableNoopReconciler) {\n      return {\n        commitResetTextContent: function(finishedWork) {},\n        commitPlacement: function(finishedWork) {},\n        commitDeletion: function(current) {\n          // Detach refs and call componentWillUnmount() on the whole subtree.\n          commitNestedUnmounts(current);\n          detachFiber(current);\n        },\n        commitWork: function(current, finishedWork) {\n          commitContainer(finishedWork);\n        },\n\n        commitLifeCycles: commitLifeCycles,\n        commitAttachRef: commitAttachRef,\n        commitDetachRef: commitDetachRef\n      };\n    } else if (persistence) {\n      invariant(false, \"Persistent reconciler is disabled.\");\n    } else {\n      invariant(false, \"Noop reconciler is disabled.\");\n    }\n  }\n  var commitMount = mutation.commitMount,\n    commitUpdate = mutation.commitUpdate,\n    resetTextContent = mutation.resetTextContent,\n    commitTextUpdate = mutation.commitTextUpdate,\n    appendChild = mutation.appendChild,\n    appendChildToContainer = mutation.appendChildToContainer,\n    insertBefore = mutation.insertBefore,\n    insertInContainerBefore = mutation.insertInContainerBefore,\n    removeChild = mutation.removeChild,\n    removeChildFromContainer = mutation.removeChildFromContainer;\n\n  function getHostParentFiber(fiber) {\n    var parent = fiber[\"return\"];\n    while (parent !== null) {\n      if (isHostParent(parent)) {\n        return parent;\n      }\n      parent = parent[\"return\"];\n    }\n    invariant(\n      false,\n      \"Expected to find a host parent. This error is likely caused by a bug \" +\n        \"in React. Please file an issue.\"\n    );\n  }\n\n  function isHostParent(fiber) {\n    return (\n      fiber.tag === HostComponent ||\n      fiber.tag === HostRoot ||\n      fiber.tag === HostPortal\n    );\n  }\n\n  function getHostSibling(fiber) {\n    // We're going to search forward into the tree until we find a sibling host\n    // node. Unfortunately, if multiple insertions are done in a row we have to\n    // search past them. This leads to exponential search for the next sibling.\n    var node = fiber;\n    siblings: while (true) {\n      // If we didn't find anything, let's try the next sibling.\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || isHostParent(node[\"return\"])) {\n          // If we pop out of the root or hit the parent the fiber we are the\n          // last sibling.\n          return null;\n        }\n        node = node[\"return\"];\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n      while (node.tag !== HostComponent && node.tag !== HostText) {\n        // If it is not host node and, we might have a host node inside it.\n        // Try to search down until we find one.\n        if (node.effectTag & Placement) {\n          // If we don't have a child, try the siblings instead.\n          continue siblings;\n        }\n        // If we don't have a child, try the siblings instead.\n        // We also skip portals because they are not part of this host tree.\n        if (node.child === null || node.tag === HostPortal) {\n          continue siblings;\n        } else {\n          node.child[\"return\"] = node;\n          node = node.child;\n        }\n      }\n      // Check if this host node is stable or about to be placed.\n      if (!(node.effectTag & Placement)) {\n        // Found it!\n        return node.stateNode;\n      }\n    }\n  }\n\n  function commitPlacement(finishedWork) {\n    // Recursively insert all host nodes into the parent.\n    var parentFiber = getHostParentFiber(finishedWork);\n    var parent = void 0;\n    var isContainer = void 0;\n    switch (parentFiber.tag) {\n      case HostComponent:\n        parent = parentFiber.stateNode;\n        isContainer = false;\n        break;\n      case HostRoot:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      case HostPortal:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      default:\n        invariant(\n          false,\n          \"Invalid host parent fiber. This error is likely caused by a bug \" +\n            \"in React. Please file an issue.\"\n        );\n    }\n    if (parentFiber.effectTag & ContentReset) {\n      // Reset the text content of the parent before doing any insertions\n      resetTextContent(parent);\n      // Clear ContentReset from the effect tag\n      parentFiber.effectTag &= ~ContentReset;\n    }\n\n    var before = getHostSibling(finishedWork);\n    // We only have the top Fiber that was inserted but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        if (before) {\n          if (isContainer) {\n            insertInContainerBefore(parent, node.stateNode, before);\n          } else {\n            insertBefore(parent, node.stateNode, before);\n          }\n        } else {\n          if (isContainer) {\n            appendChildToContainer(parent, node.stateNode);\n          } else {\n            appendChild(parent, node.stateNode);\n          }\n        }\n      } else if (node.tag === HostPortal) {\n        // If the insertion itself is a portal, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child[\"return\"] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || node[\"return\"] === finishedWork) {\n          return;\n        }\n        node = node[\"return\"];\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n    }\n  }\n\n  function unmountHostComponents(current) {\n    // We only have the top Fiber that was inserted but we need recurse down its\n    var node = current;\n\n    // Each iteration, currentParent is populated with node's host parent if not\n    // currentParentIsValid.\n    var currentParentIsValid = false;\n    var currentParent = void 0;\n    var currentParentIsContainer = void 0;\n\n    while (true) {\n      if (!currentParentIsValid) {\n        var parent = node[\"return\"];\n        findParent: while (true) {\n          invariant(\n            parent !== null,\n            \"Expected to find a host parent. This error is likely caused by \" +\n              \"a bug in React. Please file an issue.\"\n          );\n          switch (parent.tag) {\n            case HostComponent:\n              currentParent = parent.stateNode;\n              currentParentIsContainer = false;\n              break findParent;\n            case HostRoot:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n            case HostPortal:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n          }\n          parent = parent[\"return\"];\n        }\n        currentParentIsValid = true;\n      }\n\n      if (node.tag === HostComponent || node.tag === HostText) {\n        commitNestedUnmounts(node);\n        // After all the children have unmounted, it is now safe to remove the\n        // node from the tree.\n        if (currentParentIsContainer) {\n          removeChildFromContainer(currentParent, node.stateNode);\n        } else {\n          removeChild(currentParent, node.stateNode);\n        }\n        // Don't visit children because we already visited them.\n      } else if (node.tag === HostPortal) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        // Visit children because portals might contain host components.\n        if (node.child !== null) {\n          node.child[\"return\"] = node;\n          node = node.child;\n          continue;\n        }\n      } else {\n        commitUnmount(node);\n        // Visit children because we may find more host components below.\n        if (node.child !== null) {\n          node.child[\"return\"] = node;\n          node = node.child;\n          continue;\n        }\n      }\n      if (node === current) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node[\"return\"] === null || node[\"return\"] === current) {\n          return;\n        }\n        node = node[\"return\"];\n        if (node.tag === HostPortal) {\n          // When we go out of the portal, we need to restore the parent.\n          // Since we don't keep a stack of them, we will search for it.\n          currentParentIsValid = false;\n        }\n      }\n      node.sibling[\"return\"] = node[\"return\"];\n      node = node.sibling;\n    }\n  }\n\n  function commitDeletion(current) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current);\n    detachFiber(current);\n  }\n\n  function commitWork(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent: {\n        return;\n      }\n      case HostComponent: {\n        var instance = finishedWork.stateNode;\n        if (instance != null) {\n          // Commit the work prepared earlier.\n          var newProps = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          var oldProps = current !== null ? current.memoizedProps : newProps;\n          var type = finishedWork.type;\n          // TODO: Type the updateQueue to be specific to host components.\n          var updatePayload = finishedWork.updateQueue;\n          finishedWork.updateQueue = null;\n          if (updatePayload !== null) {\n            commitUpdate(\n              instance,\n              updatePayload,\n              type,\n              oldProps,\n              newProps,\n              finishedWork\n            );\n          }\n        }\n        return;\n      }\n      case HostText: {\n        invariant(\n          finishedWork.stateNode !== null,\n          \"This should have a text node initialized. This error is likely \" +\n            \"caused by a bug in React. Please file an issue.\"\n        );\n        var textInstance = finishedWork.stateNode;\n        var newText = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        var oldText = current !== null ? current.memoizedProps : newText;\n        commitTextUpdate(textInstance, oldText, newText);\n        return;\n      }\n      case HostRoot: {\n        return;\n      }\n      default: {\n        invariant(\n          false,\n          \"This unit of work tag should not have side-effects. This error is \" +\n            \"likely caused by a bug in React. Please file an issue.\"\n        );\n      }\n    }\n  }\n\n  function commitResetTextContent(current) {\n    resetTextContent(current.stateNode);\n  }\n\n  if (enableMutatingReconciler) {\n    return {\n      commitResetTextContent: commitResetTextContent,\n      commitPlacement: commitPlacement,\n      commitDeletion: commitDeletion,\n      commitWork: commitWork,\n      commitLifeCycles: commitLifeCycles,\n      commitAttachRef: commitAttachRef,\n      commitDetachRef: commitDetachRef\n    };\n  } else {\n    invariant(false, \"Mutating reconciler is disabled.\");\n  }\n};\n\nvar NO_CONTEXT = {};\n\nvar ReactFiberHostContext = function(config) {\n  var getChildHostContext = config.getChildHostContext,\n    getRootHostContext = config.getRootHostContext;\n\n  var contextStackCursor = createCursor(NO_CONTEXT);\n  var contextFiberStackCursor = createCursor(NO_CONTEXT);\n  var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\n  function requiredContext(c) {\n    invariant(\n      c !== NO_CONTEXT,\n      \"Expected host context to exist. This error is likely caused by a bug \" +\n        \"in React. Please file an issue.\"\n    );\n    return c;\n  }\n\n  function getRootHostContainer() {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    return rootInstance;\n  }\n\n  function pushHostContainer(fiber, nextRootInstance) {\n    // Push current root instance onto the stack;\n    // This allows us to reset root when portals are popped.\n    push(rootInstanceStackCursor, nextRootInstance, fiber);\n\n    var nextRootContext = getRootHostContext(nextRootInstance);\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextRootContext, fiber);\n  }\n\n  function popHostContainer(fiber) {\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n    pop(rootInstanceStackCursor, fiber);\n  }\n\n  function getHostContext() {\n    var context = requiredContext(contextStackCursor.current);\n    return context;\n  }\n\n  function pushHostContext(fiber) {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    var context = requiredContext(contextStackCursor.current);\n    var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n    // Don't push this Fiber's context unless it's unique.\n    if (context === nextContext) {\n      return;\n    }\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextContext, fiber);\n  }\n\n  function popHostContext(fiber) {\n    // Do not pop unless this Fiber provided the current context.\n    // pushHostContext() only pushes Fibers that provide unique contexts.\n    if (contextFiberStackCursor.current !== fiber) {\n      return;\n    }\n\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n  }\n\n  function resetHostContainer() {\n    contextStackCursor.current = NO_CONTEXT;\n    rootInstanceStackCursor.current = NO_CONTEXT;\n  }\n\n  return {\n    getHostContext: getHostContext,\n    getRootHostContainer: getRootHostContainer,\n    popHostContainer: popHostContainer,\n    popHostContext: popHostContext,\n    pushHostContainer: pushHostContainer,\n    pushHostContext: pushHostContext,\n    resetHostContainer: resetHostContainer\n  };\n};\n\nvar ReactFiberHydrationContext = function(config) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n    hydration = config.hydration;\n\n  // If this doesn't have hydration mode.\n\n  if (!hydration) {\n    return {\n      enterHydrationState: function() {\n        return false;\n      },\n      resetHydrationState: function() {},\n      tryToClaimNextHydratableInstance: function() {},\n      prepareToHydrateHostInstance: function() {\n        invariant(\n          false,\n          \"Expected prepareToHydrateHostInstance() to never be called. \" +\n            \"This error is likely caused by a bug in React. Please file an issue.\"\n        );\n      },\n      prepareToHydrateHostTextInstance: function() {\n        invariant(\n          false,\n          \"Expected prepareToHydrateHostTextInstance() to never be called. \" +\n            \"This error is likely caused by a bug in React. Please file an issue.\"\n        );\n      },\n      popHydrationState: function(fiber) {\n        return false;\n      }\n    };\n  }\n\n  var canHydrateInstance = hydration.canHydrateInstance,\n    canHydrateTextInstance = hydration.canHydrateTextInstance,\n    getNextHydratableSibling = hydration.getNextHydratableSibling,\n    getFirstHydratableChild = hydration.getFirstHydratableChild,\n    hydrateInstance = hydration.hydrateInstance,\n    hydrateTextInstance = hydration.hydrateTextInstance,\n    didNotMatchHydratedContainerTextInstance =\n      hydration.didNotMatchHydratedContainerTextInstance,\n    didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,\n    didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,\n    didNotHydrateInstance = hydration.didNotHydrateInstance,\n    didNotFindHydratableContainerInstance =\n      hydration.didNotFindHydratableContainerInstance,\n    didNotFindHydratableContainerTextInstance =\n      hydration.didNotFindHydratableContainerTextInstance,\n    didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,\n    didNotFindHydratableTextInstance =\n      hydration.didNotFindHydratableTextInstance;\n\n  // The deepest Fiber on the stack involved in a hydration context.\n  // This may have been an insertion or a hydration.\n\n  var hydrationParentFiber = null;\n  var nextHydratableInstance = null;\n  var isHydrating = false;\n\n  function enterHydrationState(fiber) {\n    var parentInstance = fiber.stateNode.containerInfo;\n    nextHydratableInstance = getFirstHydratableChild(parentInstance);\n    hydrationParentFiber = fiber;\n    isHydrating = true;\n    return true;\n  }\n\n  function deleteHydratableInstance(returnFiber, instance) {\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          didNotHydrateContainerInstance(\n            returnFiber.stateNode.containerInfo,\n            instance\n          );\n          break;\n        case HostComponent:\n          didNotHydrateInstance(\n            returnFiber.type,\n            returnFiber.memoizedProps,\n            returnFiber.stateNode,\n            instance\n          );\n          break;\n      }\n    }\n\n    var childToDelete = createFiberFromHostInstanceForDeletion();\n    childToDelete.stateNode = instance;\n    childToDelete[\"return\"] = returnFiber;\n    childToDelete.effectTag = Deletion;\n\n    // This might seem like it belongs on progressedFirstDeletion. However,\n    // these children are not part of the reconciliation list of children.\n    // Even if we abort and rereconcile the children, that will try to hydrate\n    // again and the nodes are still in the host tree so these will be\n    // recreated.\n    if (returnFiber.lastEffect !== null) {\n      returnFiber.lastEffect.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n  }\n\n  function insertNonHydratedInstance(returnFiber, fiber) {\n    fiber.effectTag |= Placement;\n    {\n      switch (returnFiber.tag) {\n        case HostRoot: {\n          var parentContainer = returnFiber.stateNode.containerInfo;\n          switch (fiber.tag) {\n            case HostComponent:\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              didNotFindHydratableContainerInstance(\n                parentContainer,\n                type,\n                props\n              );\n              break;\n            case HostText:\n              var text = fiber.pendingProps;\n              didNotFindHydratableContainerTextInstance(parentContainer, text);\n              break;\n          }\n          break;\n        }\n        case HostComponent: {\n          var parentType = returnFiber.type;\n          var parentProps = returnFiber.memoizedProps;\n          var parentInstance = returnFiber.stateNode;\n          switch (fiber.tag) {\n            case HostComponent:\n              var _type = fiber.type;\n              var _props = fiber.pendingProps;\n              didNotFindHydratableInstance(\n                parentType,\n                parentProps,\n                parentInstance,\n                _type,\n                _props\n              );\n              break;\n            case HostText:\n              var _text = fiber.pendingProps;\n              didNotFindHydratableTextInstance(\n                parentType,\n                parentProps,\n                parentInstance,\n                _text\n              );\n              break;\n          }\n          break;\n        }\n        default:\n          return;\n      }\n    }\n  }\n\n  function tryHydrate(fiber, nextInstance) {\n    switch (fiber.tag) {\n      case HostComponent: {\n        var type = fiber.type;\n        var props = fiber.pendingProps;\n        var instance = canHydrateInstance(nextInstance, type, props);\n        if (instance !== null) {\n          fiber.stateNode = instance;\n          return true;\n        }\n        return false;\n      }\n      case HostText: {\n        var text = fiber.pendingProps;\n        var textInstance = canHydrateTextInstance(nextInstance, text);\n        if (textInstance !== null) {\n          fiber.stateNode = textInstance;\n          return true;\n        }\n        return false;\n      }\n      default:\n        return false;\n    }\n  }\n\n  function tryToClaimNextHydratableInstance(fiber) {\n    if (!isHydrating) {\n      return;\n    }\n    var nextInstance = nextHydratableInstance;\n    if (!nextInstance) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    if (!tryHydrate(fiber, nextInstance)) {\n      // If we can't hydrate this instance let's try the next one.\n      // We use this as a heuristic. It's based on intuition and not data so it\n      // might be flawed or unnecessary.\n      nextInstance = getNextHydratableSibling(nextInstance);\n      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n        // Nothing to hydrate. Make it an insertion.\n        insertNonHydratedInstance(hydrationParentFiber, fiber);\n        isHydrating = false;\n        hydrationParentFiber = fiber;\n        return;\n      }\n      // We matched the next one, we'll now assume that the first one was\n      // superfluous and we'll delete it. Since we can't eagerly delete it\n      // we'll have to schedule a deletion. To do that, this node needs a dummy\n      // fiber associated with it.\n      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n    }\n    hydrationParentFiber = fiber;\n    nextHydratableInstance = getFirstHydratableChild(nextInstance);\n  }\n\n  function prepareToHydrateHostInstance(\n    fiber,\n    rootContainerInstance,\n    hostContext\n  ) {\n    var instance = fiber.stateNode;\n    var updatePayload = hydrateInstance(\n      instance,\n      fiber.type,\n      fiber.memoizedProps,\n      rootContainerInstance,\n      hostContext,\n      fiber\n    );\n    // TODO: Type this specific to this type of component.\n    fiber.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update.\n    if (updatePayload !== null) {\n      return true;\n    }\n    return false;\n  }\n\n  function prepareToHydrateHostTextInstance(fiber) {\n    var textInstance = fiber.stateNode;\n    var textContent = fiber.memoizedProps;\n    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n    {\n      if (shouldUpdate) {\n        // We assume that prepareToHydrateHostTextInstance is called in a context where the\n        // hydration parent is the parent host component of this host text.\n        var returnFiber = hydrationParentFiber;\n        if (returnFiber !== null) {\n          switch (returnFiber.tag) {\n            case HostRoot: {\n              var parentContainer = returnFiber.stateNode.containerInfo;\n              didNotMatchHydratedContainerTextInstance(\n                parentContainer,\n                textInstance,\n                textContent\n              );\n              break;\n            }\n            case HostComponent: {\n              var parentType = returnFiber.type;\n              var parentProps = returnFiber.memoizedProps;\n              var parentInstance = returnFiber.stateNode;\n              didNotMatchHydratedTextInstance(\n                parentType,\n                parentProps,\n                parentInstance,\n                textInstance,\n                textContent\n              );\n              break;\n            }\n          }\n        }\n      }\n    }\n    return shouldUpdate;\n  }\n\n  function popToNextHostParent(fiber) {\n    var parent = fiber[\"return\"];\n    while (\n      parent !== null &&\n      parent.tag !== HostComponent &&\n      parent.tag !== HostRoot\n    ) {\n      parent = parent[\"return\"];\n    }\n    hydrationParentFiber = parent;\n  }\n\n  function popHydrationState(fiber) {\n    if (fiber !== hydrationParentFiber) {\n      // We're deeper than the current hydration context, inside an inserted\n      // tree.\n      return false;\n    }\n    if (!isHydrating) {\n      // If we're not currently hydrating but we're in a hydration context, then\n      // we were an insertion and now need to pop up reenter hydration of our\n      // siblings.\n      popToNextHostParent(fiber);\n      isHydrating = true;\n      return false;\n    }\n\n    var type = fiber.type;\n\n    // If we have any remaining hydratable nodes, we need to delete them now.\n    // We only do this deeper than head and body since they tend to have random\n    // other nodes in them. We also ignore components with pure text content in\n    // side of them.\n    // TODO: Better heuristic.\n    if (\n      fiber.tag !== HostComponent ||\n      (type !== \"head\" &&\n        type !== \"body\" &&\n        !shouldSetTextContent(type, fiber.memoizedProps))\n    ) {\n      var nextInstance = nextHydratableInstance;\n      while (nextInstance) {\n        deleteHydratableInstance(fiber, nextInstance);\n        nextInstance = getNextHydratableSibling(nextInstance);\n      }\n    }\n\n    popToNextHostParent(fiber);\n    nextHydratableInstance = hydrationParentFiber\n      ? getNextHydratableSibling(fiber.stateNode)\n      : null;\n    return true;\n  }\n\n  function resetHydrationState() {\n    hydrationParentFiber = null;\n    nextHydratableInstance = null;\n    isHydrating = false;\n  }\n\n  return {\n    enterHydrationState: enterHydrationState,\n    resetHydrationState: resetHydrationState,\n    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n    prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n    popHydrationState: popHydrationState\n  };\n};\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\nvar invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError = ReactErrorUtils.clearCaughtError;\n\n{\n  var didWarnAboutStateTransition = false;\n  var didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  var warnAboutUpdateOnUnmounted = function(fiber) {\n    var componentName = getComponentName(fiber) || \"ReactClass\";\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warning(\n      false,\n      \"Can only update a mounted or mounting \" +\n        \"component. This usually means you called setState, replaceState, \" +\n        \"or forceUpdate on an unmounted component. This is a no-op.\\n\\nPlease \" +\n        \"check the code for the %s component.\",\n      componentName\n    );\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  var warnAboutInvalidUpdates = function(instance) {\n    switch (ReactDebugCurrentFiber.phase) {\n      case \"getChildContext\":\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warning(\n          false,\n          \"setState(...): Cannot call setState() inside getChildContext()\"\n        );\n        didWarnSetStateChildContext = true;\n        break;\n      case \"render\":\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warning(\n          false,\n          \"Cannot update during an existing state transition (such as within \" +\n            \"`render` or another component's constructor). Render methods should \" +\n            \"be a pure function of props and state; constructor side-effects are \" +\n            \"an anti-pattern, but can be moved to `componentWillMount`.\"\n        );\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\nvar ReactFiberScheduler = function(config) {\n  var hostContext = ReactFiberHostContext(config);\n  var hydrationContext = ReactFiberHydrationContext(config);\n  var popHostContainer = hostContext.popHostContainer,\n    popHostContext = hostContext.popHostContext,\n    resetHostContainer = hostContext.resetHostContainer;\n\n  var _ReactFiberBeginWork = ReactFiberBeginWork(\n      config,\n      hostContext,\n      hydrationContext,\n      scheduleWork,\n      computeExpirationForFiber\n    ),\n    beginWork = _ReactFiberBeginWork.beginWork,\n    beginFailedWork = _ReactFiberBeginWork.beginFailedWork;\n\n  var _ReactFiberCompleteWo = ReactFiberCompleteWork(\n      config,\n      hostContext,\n      hydrationContext\n    ),\n    completeWork = _ReactFiberCompleteWo.completeWork;\n\n  var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),\n    commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,\n    commitPlacement = _ReactFiberCommitWork.commitPlacement,\n    commitDeletion = _ReactFiberCommitWork.commitDeletion,\n    commitWork = _ReactFiberCommitWork.commitWork,\n    commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n    commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n    commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n\n  var now = config.now,\n    scheduleDeferredCallback = config.scheduleDeferredCallback,\n    cancelDeferredCallback = config.cancelDeferredCallback,\n    useSyncScheduling = config.useSyncScheduling,\n    prepareForCommit = config.prepareForCommit,\n    resetAfterCommit = config.resetAfterCommit;\n\n  // Represents the current time in ms.\n\n  var startTime = now();\n  var mostRecentCurrentTime = msToExpirationTime(0);\n\n  // Used to ensure computeUniqueAsyncExpiration is monotonically increases.\n  var lastUniqueAsyncExpiration = 0;\n\n  // Represents the expiration time that incoming updates should use. (If this\n  // is NoWork, use the default strategy: async updates in async mode, sync\n  // updates in sync mode.)\n  var expirationContext = NoWork;\n\n  var isWorking = false;\n\n  // The next work in progress fiber that we're currently working on.\n  var nextUnitOfWork = null;\n  var nextRoot = null;\n  // The time at which we're currently rendering work.\n  var nextRenderExpirationTime = NoWork;\n\n  // The next fiber with an effect that we're currently committing.\n  var nextEffect = null;\n\n  // Keep track of which fibers have captured an error that need to be handled.\n  // Work is removed from this collection after componentDidCatch is called.\n  var capturedErrors = null;\n  // Keep track of which fibers have failed during the current batch of work.\n  // This is a different set than capturedErrors, because it is not reset until\n  // the end of the batch. This is needed to propagate errors correctly if a\n  // subtree fails more than once.\n  var failedBoundaries = null;\n  // Error boundaries that captured an error during the current commit.\n  var commitPhaseBoundaries = null;\n  var firstUncaughtError = null;\n  var didFatal = false;\n\n  var isCommitting = false;\n  var isUnmounting = false;\n\n  // Used for performance tracking.\n  var interruptedBy = null;\n\n  function resetContextStack() {\n    // Reset the stack\n    reset();\n    // Reset the cursors\n    resetContext();\n    resetHostContainer();\n  }\n\n  function commitAllHostEffects() {\n    while (nextEffect !== null) {\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n      }\n      recordEffect();\n\n      var effectTag = nextEffect.effectTag;\n      if (effectTag & ContentReset) {\n        commitResetTextContent(nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        var current = nextEffect.alternate;\n        if (current !== null) {\n          commitDetachRef(current);\n        }\n      }\n\n      // The following switch statement is only concerned about placement,\n      // updates, and deletions. To avoid needing to add a case for every\n      // possible bitmap value, we remove the secondary effects from the\n      // effect tag and switch on that value.\n      var primaryEffectTag =\n        effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);\n      switch (primaryEffectTag) {\n        case Placement: {\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          // TODO: findDOMNode doesn't rely on this any more but isMounted\n          // does and isMounted is deprecated anyway so we should be able\n          // to kill this.\n          nextEffect.effectTag &= ~Placement;\n          break;\n        }\n        case PlacementAndUpdate: {\n          // Placement\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          nextEffect.effectTag &= ~Placement;\n\n          // Update\n          var _current = nextEffect.alternate;\n          commitWork(_current, nextEffect);\n          break;\n        }\n        case Update: {\n          var _current2 = nextEffect.alternate;\n          commitWork(_current2, nextEffect);\n          break;\n        }\n        case Deletion: {\n          isUnmounting = true;\n          commitDeletion(nextEffect);\n          isUnmounting = false;\n          break;\n        }\n      }\n      nextEffect = nextEffect.nextEffect;\n    }\n\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n  }\n\n  function commitAllLifeCycles() {\n    while (nextEffect !== null) {\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & (Update | Callback)) {\n        recordEffect();\n        var current = nextEffect.alternate;\n        commitLifeCycles(current, nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        recordEffect();\n        commitAttachRef(nextEffect);\n      }\n\n      if (effectTag & Err) {\n        recordEffect();\n        commitErrorHandling(nextEffect);\n      }\n\n      var next = nextEffect.nextEffect;\n      // Ensure that we clean these up so that we don't accidentally keep them.\n      // I'm not actually sure this matters because we can't reset firstEffect\n      // and lastEffect since they're on every node, not just the effectful\n      // ones. So we have to clean everything as we reuse nodes anyway.\n      nextEffect.nextEffect = null;\n      // Ensure that we reset the effectTag here so that we can rely on effect\n      // tags to reason about the current life-cycle.\n      nextEffect = next;\n    }\n  }\n\n  function commitRoot(finishedWork) {\n    // We keep track of this so that captureError can collect any boundaries\n    // that capture an error during the commit phase. The reason these aren't\n    // local to this function is because errors that occur during cWU are\n    // captured elsewhere, to prevent the unmount from being interrupted.\n    isWorking = true;\n    isCommitting = true;\n    startCommitTimer();\n\n    var root = finishedWork.stateNode;\n    invariant(\n      root.current !== finishedWork,\n      \"Cannot commit the same tree as before. This is probably a bug \" +\n        \"related to the return field. This error is likely caused by a bug \" +\n        \"in React. Please file an issue.\"\n    );\n    root.isReadyForCommit = false;\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    var firstEffect = void 0;\n    if (finishedWork.effectTag > PerformedWork) {\n      // A fiber's effect list consists only of its children, not itself. So if\n      // the root has an effect, we need to add it to the end of the list. The\n      // resulting list is the set that would belong to the root's parent, if\n      // it had one; that is, all the effects in the tree including the root.\n      if (finishedWork.lastEffect !== null) {\n        finishedWork.lastEffect.nextEffect = finishedWork;\n        firstEffect = finishedWork.firstEffect;\n      } else {\n        firstEffect = finishedWork;\n      }\n    } else {\n      // There is no effect on the root.\n      firstEffect = finishedWork.firstEffect;\n    }\n\n    prepareForCommit();\n\n    // Commit all the side-effects within a tree. We'll do this in two passes.\n    // The first pass performs all the host insertions, updates, deletions and\n    // ref unmounts.\n    nextEffect = firstEffect;\n    startCommitHostEffectsTimer();\n    while (nextEffect !== null) {\n      var didError = false;\n      var _error = void 0;\n      {\n        invokeGuardedCallback$1(null, commitAllHostEffects, null);\n        if (hasCaughtError()) {\n          didError = true;\n          _error = clearCaughtError();\n        }\n      }\n      if (didError) {\n        invariant(\n          nextEffect !== null,\n          \"Should have next effect. This error is likely caused by a bug \" +\n            \"in React. Please file an issue.\"\n        );\n        captureError(nextEffect, _error);\n        // Clean-up\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n    stopCommitHostEffectsTimer();\n\n    resetAfterCommit();\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the first pass of the commit phase, so that the previous tree is still\n    // current during componentWillUnmount, but before the second pass, so that\n    // the finished work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // In the second pass we'll perform all life-cycles and ref callbacks.\n    // Life-cycles happen as a separate pass so that all placements, updates,\n    // and deletions in the entire tree have already been invoked.\n    // This pass also triggers any renderer-specific initial effects.\n    nextEffect = firstEffect;\n    startCommitLifeCyclesTimer();\n    while (nextEffect !== null) {\n      var _didError = false;\n      var _error2 = void 0;\n      {\n        invokeGuardedCallback$1(null, commitAllLifeCycles, null);\n        if (hasCaughtError()) {\n          _didError = true;\n          _error2 = clearCaughtError();\n        }\n      }\n      if (_didError) {\n        invariant(\n          nextEffect !== null,\n          \"Should have next effect. This error is likely caused by a bug \" +\n            \"in React. Please file an issue.\"\n        );\n        captureError(nextEffect, _error2);\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n\n    isCommitting = false;\n    isWorking = false;\n    stopCommitLifeCyclesTimer();\n    stopCommitTimer();\n    if (typeof onCommitRoot === \"function\") {\n      onCommitRoot(finishedWork.stateNode);\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n    }\n\n    // If we caught any errors during this commit, schedule their boundaries\n    // to update.\n    if (commitPhaseBoundaries) {\n      commitPhaseBoundaries.forEach(scheduleErrorRecovery);\n      commitPhaseBoundaries = null;\n    }\n\n    if (firstUncaughtError !== null) {\n      var _error3 = firstUncaughtError;\n      firstUncaughtError = null;\n      onUncaughtError(_error3);\n    }\n\n    var remainingTime = root.current.expirationTime;\n\n    if (remainingTime === NoWork) {\n      capturedErrors = null;\n      failedBoundaries = null;\n    }\n\n    return remainingTime;\n  }\n\n  function resetExpirationTime(workInProgress, renderTime) {\n    if (renderTime !== Never && workInProgress.expirationTime === Never) {\n      // The children of this component are hidden. Don't bubble their\n      // expiration times.\n      return;\n    }\n\n    // Check for pending updates.\n    var newExpirationTime = getUpdateExpirationTime(workInProgress);\n\n    // TODO: Calls need to visit stateNode\n\n    // Bubble up the earliest expiration time.\n    var child = workInProgress.child;\n    while (child !== null) {\n      if (\n        child.expirationTime !== NoWork &&\n        (newExpirationTime === NoWork ||\n          newExpirationTime > child.expirationTime)\n      ) {\n        newExpirationTime = child.expirationTime;\n      }\n      child = child.sibling;\n    }\n    workInProgress.expirationTime = newExpirationTime;\n  }\n\n  function completeUnitOfWork(workInProgress) {\n    while (true) {\n      // The current, flushed, state of this fiber is the alternate.\n      // Ideally nothing should rely on this, but relying on it here\n      // means that we don't need an additional field on the work in\n      // progress.\n      var current = workInProgress.alternate;\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n      }\n      var next = completeWork(\n        current,\n        workInProgress,\n        nextRenderExpirationTime\n      );\n      {\n        ReactDebugCurrentFiber.resetCurrentFiber();\n      }\n\n      var returnFiber = workInProgress[\"return\"];\n      var siblingFiber = workInProgress.sibling;\n\n      resetExpirationTime(workInProgress, nextRenderExpirationTime);\n\n      if (next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        return next;\n      }\n\n      if (returnFiber !== null) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        var effectTag = workInProgress.effectTag;\n        // Skip both NoWork and PerformedWork tags when creating the effect list.\n        // PerformedWork effect is read by React DevTools but shouldn't be committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      stopWorkTimer(workInProgress);\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root.\n        var root = workInProgress.stateNode;\n        root.isReadyForCommit = true;\n        return null;\n      }\n    }\n\n    // Without this explicit null return Flow complains of invalid return type\n    // TODO Remove the above while(true) loop\n    // eslint-disable-next-line no-unreachable\n    return null;\n  }\n\n  function performUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    startWorkTimer(workInProgress);\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n\n    var next = beginWork(current, workInProgress, nextRenderExpirationTime);\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function performFailedUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    startWorkTimer(workInProgress);\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n    var next = beginFailedWork(\n      current,\n      workInProgress,\n      nextRenderExpirationTime\n    );\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function workLoop(expirationTime) {\n    if (capturedErrors !== null) {\n      // If there are unhandled errors, switch to the slow work loop.\n      // TODO: How to avoid this check in the fast path? Maybe the renderer\n      // could keep track of which roots have unhandled errors and call a\n      // forked version of renderRoot.\n      slowWorkLoopThatChecksForFailedWork(expirationTime);\n      return;\n    }\n    if (\n      nextRenderExpirationTime === NoWork ||\n      nextRenderExpirationTime > expirationTime\n    ) {\n      return;\n    }\n\n    if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    }\n  }\n\n  function slowWorkLoopThatChecksForFailedWork(expirationTime) {\n    if (\n      nextRenderExpirationTime === NoWork ||\n      nextRenderExpirationTime > expirationTime\n    ) {\n      return;\n    }\n\n    if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        if (hasCapturedError(nextUnitOfWork)) {\n          // Use a forked version of performUnitOfWork\n          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n        } else {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        }\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        if (hasCapturedError(nextUnitOfWork)) {\n          // Use a forked version of performUnitOfWork\n          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n        } else {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        }\n      }\n    }\n  }\n\n  function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {\n    // We're going to restart the error boundary that captured the error.\n    // Conceptually, we're unwinding the stack. We need to unwind the\n    // context stack, too.\n    unwindContexts(failedWork, boundary);\n\n    // Restart the error boundary using a forked version of\n    // performUnitOfWork that deletes the boundary's children. The entire\n    // failed subree will be unmounted. During the commit phase, a special\n    // lifecycle method is called on the error boundary, which triggers\n    // a re-render.\n    nextUnitOfWork = performFailedUnitOfWork(boundary);\n\n    // Continue working.\n    workLoop(expirationTime);\n  }\n\n  function renderRoot(root, expirationTime) {\n    invariant(\n      !isWorking,\n      \"renderRoot was called recursively. This error is likely caused \" +\n        \"by a bug in React. Please file an issue.\"\n    );\n    isWorking = true;\n\n    // We're about to mutate the work-in-progress tree. If the root was pending\n    // commit, it no longer is: we'll need to complete it again.\n    root.isReadyForCommit = false;\n\n    // Check if we're starting from a fresh stack, or if we're resuming from\n    // previously yielded work.\n    if (\n      root !== nextRoot ||\n      expirationTime !== nextRenderExpirationTime ||\n      nextUnitOfWork === null\n    ) {\n      // Reset the stack and start working from the root.\n      resetContextStack();\n      nextRoot = root;\n      nextRenderExpirationTime = expirationTime;\n      nextUnitOfWork = createWorkInProgress(\n        nextRoot.current,\n        null,\n        expirationTime\n      );\n    }\n\n    startWorkLoopTimer(nextUnitOfWork);\n\n    var didError = false;\n    var error = null;\n    {\n      invokeGuardedCallback$1(null, workLoop, null, expirationTime);\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    }\n\n    // An error was thrown during the render phase.\n    while (didError) {\n      if (didFatal) {\n        // This was a fatal error. Don't attempt to recover from it.\n        firstUncaughtError = error;\n        break;\n      }\n\n      var failedWork = nextUnitOfWork;\n      if (failedWork === null) {\n        // An error was thrown but there's no current unit of work. This can\n        // happen during the commit phase if there's a bug in the renderer.\n        didFatal = true;\n        continue;\n      }\n\n      // \"Capture\" the error by finding the nearest boundary. If there is no\n      // error boundary, we use the root.\n      var boundary = captureError(failedWork, error);\n      invariant(\n        boundary !== null,\n        \"Should have found an error boundary. This error is likely \" +\n          \"caused by a bug in React. Please file an issue.\"\n      );\n\n      if (didFatal) {\n        // The error we just captured was a fatal error. This happens\n        // when the error propagates to the root more than once.\n        continue;\n      }\n\n      didError = false;\n      error = null;\n      {\n        invokeGuardedCallback$1(\n          null,\n          renderRootCatchBlock,\n          null,\n          root,\n          failedWork,\n          boundary,\n          expirationTime\n        );\n        if (hasCaughtError()) {\n          didError = true;\n          error = clearCaughtError();\n          continue;\n        }\n      }\n      // We're finished working. Exit the error loop.\n      break;\n    }\n\n    var uncaughtError = firstUncaughtError;\n\n    // We're done performing work. Time to clean up.\n    stopWorkLoopTimer(interruptedBy);\n    interruptedBy = null;\n    isWorking = false;\n    didFatal = false;\n    firstUncaughtError = null;\n\n    if (uncaughtError !== null) {\n      onUncaughtError(uncaughtError);\n    }\n\n    return root.isReadyForCommit ? root.current.alternate : null;\n  }\n\n  // Returns the boundary that captured the error, or null if the error is ignored\n  function captureError(failedWork, error) {\n    // It is no longer valid because we exited the user code.\n    ReactCurrentOwner.current = null;\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n\n    // Search for the nearest error boundary.\n    var boundary = null;\n\n    // Passed to logCapturedError()\n    var errorBoundaryFound = false;\n    var willRetry = false;\n    var errorBoundaryName = null;\n\n    // Host containers are a special case. If the failed work itself is a host\n    // container, then it acts as its own boundary. In all other cases, we\n    // ignore the work itself and only search through the parents.\n    if (failedWork.tag === HostRoot) {\n      boundary = failedWork;\n\n      if (isFailedBoundary(failedWork)) {\n        // If this root already failed, there must have been an error when\n        // attempting to unmount it. This is a worst-case scenario and\n        // should only be possible if there's a bug in the renderer.\n        didFatal = true;\n      }\n    } else {\n      var node = failedWork[\"return\"];\n      while (node !== null && boundary === null) {\n        if (node.tag === ClassComponent) {\n          var instance = node.stateNode;\n          if (typeof instance.componentDidCatch === \"function\") {\n            errorBoundaryFound = true;\n            errorBoundaryName = getComponentName(node);\n\n            // Found an error boundary!\n            boundary = node;\n            willRetry = true;\n          }\n        } else if (node.tag === HostRoot) {\n          // Treat the root like a no-op error boundary\n          boundary = node;\n        }\n\n        if (isFailedBoundary(node)) {\n          // This boundary is already in a failed state.\n\n          // If we're currently unmounting, that means this error was\n          // thrown while unmounting a failed subtree. We should ignore\n          // the error.\n          if (isUnmounting) {\n            return null;\n          }\n\n          // If we're in the commit phase, we should check to see if\n          // this boundary already captured an error during this commit.\n          // This case exists because multiple errors can be thrown during\n          // a single commit without interruption.\n          if (\n            commitPhaseBoundaries !== null &&\n            (commitPhaseBoundaries.has(node) ||\n              (node.alternate !== null &&\n                commitPhaseBoundaries.has(node.alternate)))\n          ) {\n            // If so, we should ignore this error.\n            return null;\n          }\n\n          // The error should propagate to the next boundary - we keep looking.\n          boundary = null;\n          willRetry = false;\n        }\n\n        node = node[\"return\"];\n      }\n    }\n\n    if (boundary !== null) {\n      // Add to the collection of failed boundaries. This lets us know that\n      // subsequent errors in this subtree should propagate to the next boundary.\n      if (failedBoundaries === null) {\n        failedBoundaries = new Set();\n      }\n      failedBoundaries.add(boundary);\n\n      // This method is unsafe outside of the begin and complete phases.\n      // We might be in the commit phase when an error is captured.\n      // The risk is that the return path from this Fiber may not be accurate.\n      // That risk is acceptable given the benefit of providing users more context.\n      var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);\n      var _componentName = getComponentName(failedWork);\n\n      // Add to the collection of captured errors. This is stored as a global\n      // map of errors and their component stack location keyed by the boundaries\n      // that capture them. We mostly use this Map as a Set; it's a Map only to\n      // avoid adding a field to Fiber to store the error.\n      if (capturedErrors === null) {\n        capturedErrors = new Map();\n      }\n\n      var capturedError = {\n        componentName: _componentName,\n        componentStack: _componentStack,\n        error: error,\n        errorBoundary: errorBoundaryFound ? boundary.stateNode : null,\n        errorBoundaryFound: errorBoundaryFound,\n        errorBoundaryName: errorBoundaryName,\n        willRetry: willRetry\n      };\n\n      capturedErrors.set(boundary, capturedError);\n\n      try {\n        logCapturedError(capturedError);\n      } catch (e) {\n        // Prevent cycle if logCapturedError() throws.\n        // A cycle may still occur if logCapturedError renders a component that throws.\n        var suppressLogging = e && e.suppressReactErrorLogging;\n        if (!suppressLogging) {\n          console.error(e);\n        }\n      }\n\n      // If we're in the commit phase, defer scheduling an update on the\n      // boundary until after the commit is complete\n      if (isCommitting) {\n        if (commitPhaseBoundaries === null) {\n          commitPhaseBoundaries = new Set();\n        }\n        commitPhaseBoundaries.add(boundary);\n      } else {\n        // Otherwise, schedule an update now.\n        // TODO: Is this actually necessary during the render phase? Is it\n        // possible to unwind and continue rendering at the same priority,\n        // without corrupting internal state?\n        scheduleErrorRecovery(boundary);\n      }\n      return boundary;\n    } else if (firstUncaughtError === null) {\n      // If no boundary is found, we'll need to throw the error\n      firstUncaughtError = error;\n    }\n    return null;\n  }\n\n  function hasCapturedError(fiber) {\n    // TODO: capturedErrors should store the boundary instance, to avoid needing\n    // to check the alternate.\n    return (\n      capturedErrors !== null &&\n      (capturedErrors.has(fiber) ||\n        (fiber.alternate !== null && capturedErrors.has(fiber.alternate)))\n    );\n  }\n\n  function isFailedBoundary(fiber) {\n    // TODO: failedBoundaries should store the boundary instance, to avoid\n    // needing to check the alternate.\n    return (\n      failedBoundaries !== null &&\n      (failedBoundaries.has(fiber) ||\n        (fiber.alternate !== null && failedBoundaries.has(fiber.alternate)))\n    );\n  }\n\n  function commitErrorHandling(effectfulFiber) {\n    var capturedError = void 0;\n    if (capturedErrors !== null) {\n      capturedError = capturedErrors.get(effectfulFiber);\n      capturedErrors[\"delete\"](effectfulFiber);\n      if (capturedError == null) {\n        if (effectfulFiber.alternate !== null) {\n          effectfulFiber = effectfulFiber.alternate;\n          capturedError = capturedErrors.get(effectfulFiber);\n          capturedErrors[\"delete\"](effectfulFiber);\n        }\n      }\n    }\n\n    invariant(\n      capturedError != null,\n      \"No error for given unit of work. This error is likely caused by a \" +\n        \"bug in React. Please file an issue.\"\n    );\n\n    switch (effectfulFiber.tag) {\n      case ClassComponent:\n        var instance = effectfulFiber.stateNode;\n\n        var info = {\n          componentStack: capturedError.componentStack\n        };\n\n        // Allow the boundary to handle the error, usually by scheduling\n        // an update to itself\n        instance.componentDidCatch(capturedError.error, info);\n        return;\n      case HostRoot:\n        if (firstUncaughtError === null) {\n          firstUncaughtError = capturedError.error;\n        }\n        return;\n      default:\n        invariant(\n          false,\n          \"Invalid type of work. This error is likely caused by a bug in \" +\n            \"React. Please file an issue.\"\n        );\n    }\n  }\n\n  function unwindContexts(from, to) {\n    var node = from;\n    while (node !== null) {\n      switch (node.tag) {\n        case ClassComponent:\n          popContextProvider(node);\n          break;\n        case HostComponent:\n          popHostContext(node);\n          break;\n        case HostRoot:\n          popHostContainer(node);\n          break;\n        case HostPortal:\n          popHostContainer(node);\n          break;\n      }\n      if (node === to || node.alternate === to) {\n        stopFailedWorkTimer(node);\n        break;\n      } else {\n        stopWorkTimer(node);\n      }\n      node = node[\"return\"];\n    }\n  }\n\n  function computeAsyncExpiration() {\n    // Given the current clock time, returns an expiration time. We use rounding\n    // to batch like updates together.\n    // Should complete within ~1000ms. 1200ms max.\n    var currentTime = recalculateCurrentTime();\n    var expirationMs = 1000;\n    var bucketSizeMs = 200;\n    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n  }\n\n  // Creates a unique async expiration time.\n  function computeUniqueAsyncExpiration() {\n    var result = computeAsyncExpiration();\n    if (result <= lastUniqueAsyncExpiration) {\n      // Since we assume the current time monotonically increases, we only hit\n      // this branch when computeUniqueAsyncExpiration is fired multiple times\n      // within a 200ms window (or whatever the async bucket size is).\n      result = lastUniqueAsyncExpiration + 1;\n    }\n    lastUniqueAsyncExpiration = result;\n    return lastUniqueAsyncExpiration;\n  }\n\n  function computeExpirationForFiber(fiber) {\n    var expirationTime = void 0;\n    if (expirationContext !== NoWork) {\n      // An explicit expiration context was set;\n      expirationTime = expirationContext;\n    } else if (isWorking) {\n      if (isCommitting) {\n        // Updates that occur during the commit phase should have sync priority\n        // by default.\n        expirationTime = Sync;\n      } else {\n        // Updates during the render phase should expire at the same time as\n        // the work that is being rendered.\n        expirationTime = nextRenderExpirationTime;\n      }\n    } else {\n      // No explicit expiration context was set, and we're not currently\n      // performing work. Calculate a new expiration time.\n      if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {\n        // This is a sync update\n        expirationTime = Sync;\n      } else {\n        // This is an async update\n        expirationTime = computeAsyncExpiration();\n      }\n    }\n    return expirationTime;\n  }\n\n  function scheduleWork(fiber, expirationTime) {\n    return scheduleWorkImpl(fiber, expirationTime, false);\n  }\n\n  function checkRootNeedsClearing(root, fiber, expirationTime) {\n    if (\n      !isWorking &&\n      root === nextRoot &&\n      expirationTime < nextRenderExpirationTime\n    ) {\n      // Restart the root from the top.\n      if (nextUnitOfWork !== null) {\n        // This is an interruption. (Used for performance tracking.)\n        interruptedBy = fiber;\n      }\n      nextRoot = null;\n      nextUnitOfWork = null;\n      nextRenderExpirationTime = NoWork;\n    }\n  }\n\n  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {\n    recordScheduleUpdate();\n\n    {\n      if (!isErrorRecovery && fiber.tag === ClassComponent) {\n        var instance = fiber.stateNode;\n        warnAboutInvalidUpdates(instance);\n      }\n    }\n\n    var node = fiber;\n    while (node !== null) {\n      // Walk the parent path to the root and update each node's\n      // expiration time.\n      if (\n        node.expirationTime === NoWork ||\n        node.expirationTime > expirationTime\n      ) {\n        node.expirationTime = expirationTime;\n      }\n      if (node.alternate !== null) {\n        if (\n          node.alternate.expirationTime === NoWork ||\n          node.alternate.expirationTime > expirationTime\n        ) {\n          node.alternate.expirationTime = expirationTime;\n        }\n      }\n      if (node[\"return\"] === null) {\n        if (node.tag === HostRoot) {\n          var root = node.stateNode;\n\n          checkRootNeedsClearing(root, fiber, expirationTime);\n          requestWork(root, expirationTime);\n          checkRootNeedsClearing(root, fiber, expirationTime);\n        } else {\n          {\n            if (!isErrorRecovery && fiber.tag === ClassComponent) {\n              warnAboutUpdateOnUnmounted(fiber);\n            }\n          }\n          return;\n        }\n      }\n      node = node[\"return\"];\n    }\n  }\n\n  function scheduleErrorRecovery(fiber) {\n    scheduleWorkImpl(fiber, Sync, true);\n  }\n\n  function recalculateCurrentTime() {\n    // Subtract initial time so it fits inside 32bits\n    var ms = now() - startTime;\n    mostRecentCurrentTime = msToExpirationTime(ms);\n    return mostRecentCurrentTime;\n  }\n\n  function deferredUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = computeAsyncExpiration();\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  function syncUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = Sync;\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  // TODO: Everything below this is written as if it has been lifted to the\n  // renderers. I'll do this in a follow-up.\n\n  // Linked-list of roots\n  var firstScheduledRoot = null;\n  var lastScheduledRoot = null;\n\n  var callbackExpirationTime = NoWork;\n  var callbackID = -1;\n  var isRendering = false;\n  var nextFlushedRoot = null;\n  var nextFlushedExpirationTime = NoWork;\n  var deadlineDidExpire = false;\n  var hasUnhandledError = false;\n  var unhandledError = null;\n  var deadline = null;\n\n  var isBatchingUpdates = false;\n  var isUnbatchingUpdates = false;\n\n  var completedBatches = null;\n\n  // Use these to prevent an infinite loop of nested updates\n  var NESTED_UPDATE_LIMIT = 1000;\n  var nestedUpdateCount = 0;\n\n  var timeHeuristicForUnitOfWork = 1;\n\n  function scheduleCallbackWithExpiration(expirationTime) {\n    if (callbackExpirationTime !== NoWork) {\n      // A callback is already scheduled. Check its expiration time (timeout).\n      if (expirationTime > callbackExpirationTime) {\n        // Existing callback has sufficient timeout. Exit.\n        return;\n      } else {\n        // Existing callback has insufficient timeout. Cancel and schedule a\n        // new one.\n        cancelDeferredCallback(callbackID);\n      }\n      // The request callback timer is already running. Don't start a new one.\n    } else {\n      startRequestCallbackTimer();\n    }\n\n    // Compute a timeout for the given expiration time.\n    var currentMs = now() - startTime;\n    var expirationMs = expirationTimeToMs(expirationTime);\n    var timeout = expirationMs - currentMs;\n\n    callbackExpirationTime = expirationTime;\n    callbackID = scheduleDeferredCallback(performAsyncWork, {\n      timeout: timeout\n    });\n  }\n\n  // requestWork is called by the scheduler whenever a root receives an update.\n  // It's up to the renderer to call renderRoot at some point in the future.\n  function requestWork(root, expirationTime) {\n    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n      invariant(\n        false,\n        \"Maximum update depth exceeded. This can happen when a \" +\n          \"component repeatedly calls setState inside componentWillUpdate or \" +\n          \"componentDidUpdate. React limits the number of nested updates to \" +\n          \"prevent infinite loops.\"\n      );\n    }\n\n    // Add the root to the schedule.\n    // Check if this root is already part of the schedule.\n    if (root.nextScheduledRoot === null) {\n      // This root is not already scheduled. Add it.\n      root.remainingExpirationTime = expirationTime;\n      if (lastScheduledRoot === null) {\n        firstScheduledRoot = lastScheduledRoot = root;\n        root.nextScheduledRoot = root;\n      } else {\n        lastScheduledRoot.nextScheduledRoot = root;\n        lastScheduledRoot = root;\n        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n      }\n    } else {\n      // This root is already scheduled, but its priority may have increased.\n      var remainingExpirationTime = root.remainingExpirationTime;\n      if (\n        remainingExpirationTime === NoWork ||\n        expirationTime < remainingExpirationTime\n      ) {\n        // Update the priority.\n        root.remainingExpirationTime = expirationTime;\n      }\n    }\n\n    if (isRendering) {\n      // Prevent reentrancy. Remaining work will be scheduled at the end of\n      // the currently rendering batch.\n      return;\n    }\n\n    if (isBatchingUpdates) {\n      // Flush work at the end of the batch.\n      if (isUnbatchingUpdates) {\n        // ...unless we're inside unbatchedUpdates, in which case we should\n        // flush it now.\n        nextFlushedRoot = root;\n        nextFlushedExpirationTime = Sync;\n        performWorkOnRoot(root, Sync, recalculateCurrentTime());\n      }\n      return;\n    }\n\n    // TODO: Get rid of Sync and use current time?\n    if (expirationTime === Sync) {\n      performWork(Sync, null);\n    } else {\n      scheduleCallbackWithExpiration(expirationTime);\n    }\n  }\n\n  function findHighestPriorityRoot() {\n    var highestPriorityWork = NoWork;\n    var highestPriorityRoot = null;\n\n    if (lastScheduledRoot !== null) {\n      var previousScheduledRoot = lastScheduledRoot;\n      var root = firstScheduledRoot;\n      while (root !== null) {\n        var remainingExpirationTime = root.remainingExpirationTime;\n        if (remainingExpirationTime === NoWork) {\n          // This root no longer has work. Remove it from the scheduler.\n\n          // TODO: This check is redudant, but Flow is confused by the branch\n          // below where we set lastScheduledRoot to null, even though we break\n          // from the loop right after.\n          invariant(\n            previousScheduledRoot !== null && lastScheduledRoot !== null,\n            \"Should have a previous and last root. This error is likely \" +\n              \"caused by a bug in React. Please file an issue.\"\n          );\n          if (root === root.nextScheduledRoot) {\n            // This is the only root in the list.\n            root.nextScheduledRoot = null;\n            firstScheduledRoot = lastScheduledRoot = null;\n            break;\n          } else if (root === firstScheduledRoot) {\n            // This is the first root in the list.\n            var next = root.nextScheduledRoot;\n            firstScheduledRoot = next;\n            lastScheduledRoot.nextScheduledRoot = next;\n            root.nextScheduledRoot = null;\n          } else if (root === lastScheduledRoot) {\n            // This is the last root in the list.\n            lastScheduledRoot = previousScheduledRoot;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n            root.nextScheduledRoot = null;\n            break;\n          } else {\n            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n            root.nextScheduledRoot = null;\n          }\n          root = previousScheduledRoot.nextScheduledRoot;\n        } else {\n          if (\n            highestPriorityWork === NoWork ||\n            remainingExpirationTime < highestPriorityWork\n          ) {\n            // Update the priority, if it's higher\n            highestPriorityWork = remainingExpirationTime;\n            highestPriorityRoot = root;\n          }\n          if (root === lastScheduledRoot) {\n            break;\n          }\n          previousScheduledRoot = root;\n          root = root.nextScheduledRoot;\n        }\n      }\n    }\n\n    // If the next root is the same as the previous root, this is a nested\n    // update. To prevent an infinite loop, increment the nested update count.\n    var previousFlushedRoot = nextFlushedRoot;\n    if (\n      previousFlushedRoot !== null &&\n      previousFlushedRoot === highestPriorityRoot\n    ) {\n      nestedUpdateCount++;\n    } else {\n      // Reset whenever we switch roots.\n      nestedUpdateCount = 0;\n    }\n    nextFlushedRoot = highestPriorityRoot;\n    nextFlushedExpirationTime = highestPriorityWork;\n  }\n\n  function performAsyncWork(dl) {\n    performWork(NoWork, dl);\n  }\n\n  function performWork(minExpirationTime, dl) {\n    deadline = dl;\n\n    // Keep working on roots until there's no more work, or until the we reach\n    // the deadline.\n    findHighestPriorityRoot();\n\n    if (enableUserTimingAPI && deadline !== null) {\n      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();\n      stopRequestCallbackTimer(didExpire);\n    }\n\n    while (\n      nextFlushedRoot !== null &&\n      nextFlushedExpirationTime !== NoWork &&\n      (minExpirationTime === NoWork ||\n        nextFlushedExpirationTime <= minExpirationTime) &&\n      !deadlineDidExpire\n    ) {\n      performWorkOnRoot(\n        nextFlushedRoot,\n        nextFlushedExpirationTime,\n        recalculateCurrentTime()\n      );\n      // Find the next highest priority work.\n      findHighestPriorityRoot();\n    }\n\n    // We're done flushing work. Either we ran out of time in this callback,\n    // or there's no more work left with sufficient priority.\n\n    // If we're inside a callback, set this to false since we just completed it.\n    if (deadline !== null) {\n      callbackExpirationTime = NoWork;\n      callbackID = -1;\n    }\n    // If there's work left over, schedule a new callback.\n    if (nextFlushedExpirationTime !== NoWork) {\n      scheduleCallbackWithExpiration(nextFlushedExpirationTime);\n    }\n\n    // Clean-up.\n    deadline = null;\n    deadlineDidExpire = false;\n    nestedUpdateCount = 0;\n\n    finishRendering();\n  }\n\n  function flushRoot(root, expirationTime) {\n    invariant(\n      !isRendering,\n      \"work.commit(): Cannot commit while already rendering. This likely \" +\n        \"means you attempted to commit from inside a lifecycle method.\"\n    );\n    // Perform work on root as if the given expiration time is the current time.\n    // This has the effect of synchronously flushing all work up to and\n    // including the given time.\n    performWorkOnRoot(root, expirationTime, expirationTime);\n    finishRendering();\n  }\n\n  function finishRendering() {\n    if (completedBatches !== null) {\n      var batches = completedBatches;\n      completedBatches = null;\n      for (var i = 0; i < batches.length; i++) {\n        var batch = batches[i];\n        try {\n          batch._onComplete();\n        } catch (error) {\n          if (!hasUnhandledError) {\n            hasUnhandledError = true;\n            unhandledError = error;\n          }\n        }\n      }\n    }\n\n    if (hasUnhandledError) {\n      var _error4 = unhandledError;\n      unhandledError = null;\n      hasUnhandledError = false;\n      throw _error4;\n    }\n  }\n\n  function performWorkOnRoot(root, expirationTime, currentTime) {\n    invariant(\n      !isRendering,\n      \"performWorkOnRoot was called recursively. This error is likely caused \" +\n        \"by a bug in React. Please file an issue.\"\n    );\n\n    isRendering = true;\n\n    // Check if this is async work or sync/expired work.\n    if (expirationTime <= currentTime) {\n      // Flush sync work.\n      var finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        completeRoot(root, finishedWork, expirationTime);\n      } else {\n        root.finishedWork = null;\n        finishedWork = renderRoot(root, expirationTime);\n        if (finishedWork !== null) {\n          // We've completed the root. Commit it.\n          completeRoot(root, finishedWork, expirationTime);\n        }\n      }\n    } else {\n      // Flush async work.\n      var _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        completeRoot(root, _finishedWork, expirationTime);\n      } else {\n        root.finishedWork = null;\n        _finishedWork = renderRoot(root, expirationTime);\n        if (_finishedWork !== null) {\n          // We've completed the root. Check the deadline one more time\n          // before committing.\n          if (!shouldYield()) {\n            // Still time left. Commit the root.\n            completeRoot(root, _finishedWork, expirationTime);\n          } else {\n            // There's no time left. Mark this root as complete. We'll come\n            // back and commit it later.\n            root.finishedWork = _finishedWork;\n          }\n        }\n      }\n    }\n\n    isRendering = false;\n  }\n\n  function completeRoot(root, finishedWork, expirationTime) {\n    // Check if there's a batch that matches this expiration time.\n    var firstBatch = root.firstBatch;\n    if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {\n      if (completedBatches === null) {\n        completedBatches = [firstBatch];\n      } else {\n        completedBatches.push(firstBatch);\n      }\n      if (firstBatch._defer) {\n        // This root is blocked from committing by a batch. Unschedule it until\n        // we receive another update.\n        root.finishedWork = finishedWork;\n        root.remainingExpirationTime = NoWork;\n        return;\n      }\n    }\n\n    // Commit the root.\n    root.finishedWork = null;\n    root.remainingExpirationTime = commitRoot(finishedWork);\n  }\n\n  // When working on async work, the reconciler asks the renderer if it should\n  // yield execution. For DOM, we implement this with requestIdleCallback.\n  function shouldYield() {\n    if (deadline === null) {\n      return false;\n    }\n    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n      // Disregard deadline.didTimeout. Only expired work should be flushed\n      // during a timeout. This path is only hit for non-expired work.\n      return false;\n    }\n    deadlineDidExpire = true;\n    return true;\n  }\n\n  // TODO: Not happy about this hook. Conceptually, renderRoot should return a\n  // tuple of (isReadyForCommit, didError, error)\n  function onUncaughtError(error) {\n    invariant(\n      nextFlushedRoot !== null,\n      \"Should be working on a root. This error is likely caused by a bug in \" +\n        \"React. Please file an issue.\"\n    );\n    // Unschedule this root so we don't work on it again until there's\n    // another update.\n    nextFlushedRoot.remainingExpirationTime = NoWork;\n    if (!hasUnhandledError) {\n      hasUnhandledError = true;\n      unhandledError = error;\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function batchedUpdates(fn, a) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performWork(Sync, null);\n      }\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function unbatchedUpdates(fn) {\n    if (isBatchingUpdates && !isUnbatchingUpdates) {\n      isUnbatchingUpdates = true;\n      try {\n        return fn();\n      } finally {\n        isUnbatchingUpdates = false;\n      }\n    }\n    return fn();\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not within\n  // the reconciler.\n  function flushSync(fn) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return syncUpdates(fn);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      invariant(\n        !isRendering,\n        \"flushSync was called from inside a lifecycle method. It cannot be \" +\n          \"called when React is already rendering.\"\n      );\n      performWork(Sync, null);\n    }\n  }\n\n  return {\n    computeAsyncExpiration: computeAsyncExpiration,\n    computeExpirationForFiber: computeExpirationForFiber,\n    scheduleWork: scheduleWork,\n    requestWork: requestWork,\n    flushRoot: flushRoot,\n    batchedUpdates: batchedUpdates,\n    unbatchedUpdates: unbatchedUpdates,\n    flushSync: flushSync,\n    deferredUpdates: deferredUpdates,\n    computeUniqueAsyncExpiration: computeUniqueAsyncExpiration\n  };\n};\n\n{\n  var didWarnAboutNestedUpdates = false;\n}\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyObject;\n  }\n\n  var fiber = get(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n  return isContextProvider(fiber)\n    ? processChildContext(fiber, parentContext)\n    : parentContext;\n}\n\nvar ReactFiberReconciler$1 = function(config) {\n  var getPublicInstance = config.getPublicInstance;\n\n  var _ReactFiberScheduler = ReactFiberScheduler(config),\n    computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,\n    computeUniqueAsyncExpiration =\n      _ReactFiberScheduler.computeUniqueAsyncExpiration,\n    computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,\n    scheduleWork = _ReactFiberScheduler.scheduleWork,\n    requestWork = _ReactFiberScheduler.requestWork,\n    flushRoot = _ReactFiberScheduler.flushRoot,\n    batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n    unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n    flushSync = _ReactFiberScheduler.flushSync,\n    deferredUpdates = _ReactFiberScheduler.deferredUpdates;\n\n  function computeRootExpirationTime(current, element) {\n    var expirationTime = void 0;\n    // Check if the top-level element is an async wrapper component. If so,\n    // treat updates to the root as async. This is a bit weird but lets us\n    // avoid a separate `renderAsync` API.\n    if (\n      enableAsyncSubtreeAPI &&\n      element != null &&\n      element.type != null &&\n      element.type.prototype != null &&\n      element.type.prototype.unstable_isAsyncReactComponent === true\n    ) {\n      expirationTime = computeAsyncExpiration();\n    } else {\n      expirationTime = computeExpirationForFiber(current);\n    }\n    return expirationTime;\n  }\n\n  function scheduleRootUpdate(current, element, expirationTime, callback) {\n    {\n      if (\n        ReactDebugCurrentFiber.phase === \"render\" &&\n        ReactDebugCurrentFiber.current !== null &&\n        !didWarnAboutNestedUpdates\n      ) {\n        didWarnAboutNestedUpdates = true;\n        warning(\n          false,\n          \"Render methods should be a pure function of props and state; \" +\n            \"triggering nested component updates from render is not allowed. \" +\n            \"If necessary, trigger nested updates in componentDidUpdate.\\n\\n\" +\n            \"Check the render method of %s.\",\n          getComponentName(ReactDebugCurrentFiber.current) || \"Unknown\"\n        );\n      }\n    }\n\n    callback = callback === undefined ? null : callback;\n    {\n      warning(\n        callback === null || typeof callback === \"function\",\n        \"render(...): Expected the last optional `callback` argument to be a \" +\n          \"function. Instead received: %s.\",\n        callback\n      );\n    }\n\n    var update = {\n      expirationTime: expirationTime,\n      partialState: { element: element },\n      callback: callback,\n      isReplace: false,\n      isForced: false,\n      next: null\n    };\n    insertUpdateIntoFiber(current, update);\n    scheduleWork(current, expirationTime);\n\n    return expirationTime;\n  }\n\n  function updateContainerAtExpirationTime(\n    element,\n    container,\n    parentComponent,\n    expirationTime,\n    callback\n  ) {\n    // TODO: If this is a nested container, this won't be the root.\n    var current = container.current;\n\n    {\n      if (ReactFiberInstrumentation_1.debugTool) {\n        if (current.alternate === null) {\n          ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n        } else if (element === null) {\n          ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n        } else {\n          ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n        }\n      }\n    }\n\n    var context = getContextForSubtree(parentComponent);\n    if (container.context === null) {\n      container.context = context;\n    } else {\n      container.pendingContext = context;\n    }\n\n    return scheduleRootUpdate(current, element, expirationTime, callback);\n  }\n\n  function findHostInstance(fiber) {\n    var hostFiber = findCurrentHostFiber(fiber);\n    if (hostFiber === null) {\n      return null;\n    }\n    return hostFiber.stateNode;\n  }\n\n  return {\n    createContainer: function(containerInfo, hydrate) {\n      return createFiberRoot(containerInfo, hydrate);\n    },\n    updateContainer: function(element, container, parentComponent, callback) {\n      var current = container.current;\n      var expirationTime = computeRootExpirationTime(current, element);\n      return updateContainerAtExpirationTime(\n        element,\n        container,\n        parentComponent,\n        expirationTime,\n        callback\n      );\n    },\n\n    updateContainerAtExpirationTime: updateContainerAtExpirationTime,\n\n    flushRoot: flushRoot,\n\n    requestWork: requestWork,\n\n    computeUniqueAsyncExpiration: computeUniqueAsyncExpiration,\n\n    batchedUpdates: batchedUpdates,\n\n    unbatchedUpdates: unbatchedUpdates,\n\n    deferredUpdates: deferredUpdates,\n\n    flushSync: flushSync,\n\n    getPublicRootInstance: function(container) {\n      var containerFiber = container.current;\n      if (!containerFiber.child) {\n        return null;\n      }\n      switch (containerFiber.child.tag) {\n        case HostComponent:\n          return getPublicInstance(containerFiber.child.stateNode);\n        default:\n          return containerFiber.child.stateNode;\n      }\n    },\n\n    findHostInstance: findHostInstance,\n\n    findHostInstanceWithNoPortals: function(fiber) {\n      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    injectIntoDevTools: function(devToolsConfig) {\n      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\n      return injectInternals(\n        Object.assign({}, devToolsConfig, {\n          findHostInstanceByFiber: function(fiber) {\n            return findHostInstance(fiber);\n          },\n          findFiberByHostInstance: function(instance) {\n            if (!findFiberByHostInstance) {\n              // Might not be implemented by the renderer.\n              return null;\n            }\n            return findFiberByHostInstance(instance);\n          }\n        })\n      );\n    }\n  };\n};\n\nvar ReactFiberReconciler$2 = Object.freeze({\n  default: ReactFiberReconciler$1\n});\n\nvar ReactFiberReconciler$3 =\n  (ReactFiberReconciler$2 && ReactFiberReconciler$1) || ReactFiberReconciler$2;\n\n// TODO: bundle Flow types with the package.\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactReconciler = ReactFiberReconciler$3[\"default\"]\n  ? ReactFiberReconciler$3[\"default\"]\n  : ReactFiberReconciler$3;\n\nvar viewConfigCallbacks = new Map();\nvar viewConfigs = new Map();\n\n/**\n * Registers a native view/component by name.\n * A callback is provided to load the view config from UIManager.\n * The callback is deferred until the view is actually rendered.\n * This is done to avoid causing Prepack deopts.\n */\nfunction register(name, callback) {\n  invariant(\n    !viewConfigCallbacks.has(name),\n    \"Tried to register two views with the same name %s\",\n    name\n  );\n  viewConfigCallbacks.set(name, callback);\n  return name;\n}\n\n/**\n * Retrieves a config for the specified view.\n * If this is the first time the view has been used,\n * This configuration will be lazy-loaded from UIManager.\n */\nfunction get$1(name) {\n  var viewConfig = void 0;\n  if (!viewConfigs.has(name)) {\n    var callback = viewConfigCallbacks.get(name);\n    invariant(\n      typeof callback === \"function\",\n      \"View config not found for name %s\",\n      name\n    );\n    viewConfigCallbacks.set(name, null);\n    viewConfig = callback();\n    viewConfigs.set(name, viewConfig);\n  } else {\n    viewConfig = viewConfigs.get(name);\n  }\n  invariant(viewConfig, \"View config not found for name %s\", name);\n  return viewConfig;\n}\n\nfunction _classCallCheck$1(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n// Modules provided by RN:\n/**\n * This component defines the same methods as NativeMethodsMixin but without the\n * findNodeHandle wrapper. This wrapper is unnecessary for HostComponent views\n * and would also result in a circular require.js dependency (since\n * ReactNativeFiber depends on this component and NativeMethodsMixin depends on\n * ReactNativeFiber).\n */\n\nvar ReactNativeFiberHostComponent = (function() {\n  function ReactNativeFiberHostComponent(tag, viewConfig) {\n    _classCallCheck$1(this, ReactNativeFiberHostComponent);\n\n    this._nativeTag = tag;\n    this._children = [];\n    this.viewConfig = viewConfig;\n  }\n\n  ReactNativeFiberHostComponent.prototype.blur = function blur() {\n    TextInputState.blurTextInput(this._nativeTag);\n  };\n\n  ReactNativeFiberHostComponent.prototype.focus = function focus() {\n    TextInputState.focusTextInput(this._nativeTag);\n  };\n\n  ReactNativeFiberHostComponent.prototype.measure = function measure(callback) {\n    UIManager.measure(this._nativeTag, mountSafeCallback(this, callback));\n  };\n\n  ReactNativeFiberHostComponent.prototype.measureInWindow = function measureInWindow(\n    callback\n  ) {\n    UIManager.measureInWindow(\n      this._nativeTag,\n      mountSafeCallback(this, callback)\n    );\n  };\n\n  ReactNativeFiberHostComponent.prototype.measureLayout = function measureLayout(\n    relativeToNativeNode,\n    onSuccess,\n    onFail /* currently unused */\n  ) {\n    UIManager.measureLayout(\n      this._nativeTag,\n      relativeToNativeNode,\n      mountSafeCallback(this, onFail),\n      mountSafeCallback(this, onSuccess)\n    );\n  };\n\n  ReactNativeFiberHostComponent.prototype.setNativeProps = function setNativeProps(\n    nativeProps\n  ) {\n    {\n      warnForStyleProps(nativeProps, this.viewConfig.validAttributes);\n    }\n\n    var updatePayload = create(nativeProps, this.viewConfig.validAttributes);\n\n    // Avoid the overhead of bridge calls if there's no update.\n    // This is an expensive no-op for Android, and causes an unnecessary\n    // view invalidation for certain components (eg RCTTextInput) on iOS.\n    if (updatePayload != null) {\n      UIManager.updateView(\n        this._nativeTag,\n        this.viewConfig.uiViewClassName,\n        updatePayload\n      );\n    }\n  };\n\n  return ReactNativeFiberHostComponent;\n})();\n\nvar hasNativePerformanceNow =\n  typeof performance === \"object\" && typeof performance.now === \"function\";\n\nvar now = hasNativePerformanceNow\n  ? function() {\n      return performance.now();\n    }\n  : function() {\n      return Date.now();\n    };\n\nvar scheduledCallback = null;\nvar frameDeadline = 0;\n\nvar frameDeadlineObject = {\n  timeRemaining: function() {\n    return frameDeadline - now();\n  }\n};\n\nfunction setTimeoutCallback() {\n  // TODO (bvaughn) Hard-coded 5ms unblocks initial async testing.\n  // React API probably changing to boolean rather than time remaining.\n  // Longer-term plan is to rewrite this using shared memory,\n  // And just return the value of the bit as the boolean.\n  frameDeadline = now() + 5;\n\n  var callback = scheduledCallback;\n  scheduledCallback = null;\n  if (callback !== null) {\n    callback(frameDeadlineObject);\n  }\n}\n\n// RN has a poor polyfill for requestIdleCallback so we aren't using it.\n// This implementation is only intended for short-term use anyway.\n// We also don't implement cancel functionality b'c Fiber doesn't currently need it.\nfunction scheduleDeferredCallback(callback) {\n  // We assume only one callback is scheduled at a time b'c that's how Fiber works.\n  scheduledCallback = callback;\n  return setTimeout(setTimeoutCallback, 1);\n}\n\nfunction cancelDeferredCallback(callbackID) {\n  scheduledCallback = null;\n  clearTimeout(callbackID);\n}\n\n// Modules provided by RN:\nfunction recursivelyUncacheFiberNode(node) {\n  if (typeof node === \"number\") {\n    // Leaf node (eg text)\n    uncacheFiberNode(node);\n  } else {\n    uncacheFiberNode(node._nativeTag);\n\n    node._children.forEach(recursivelyUncacheFiberNode);\n  }\n}\n\nvar NativeRenderer = reactReconciler({\n  appendInitialChild: function(parentInstance, child) {\n    parentInstance._children.push(child);\n  },\n  createInstance: function(\n    type,\n    props,\n    rootContainerInstance,\n    hostContext,\n    internalInstanceHandle\n  ) {\n    var tag = ReactNativeTagHandles.allocateTag();\n    var viewConfig = get$1(type);\n\n    {\n      for (var key in viewConfig.validAttributes) {\n        if (props.hasOwnProperty(key)) {\n          deepFreezeAndThrowOnMutationInDev(props[key]);\n        }\n      }\n    }\n\n    var updatePayload = create(props, viewConfig.validAttributes);\n\n    UIManager.createView(\n      tag, // reactTag\n      viewConfig.uiViewClassName, // viewName\n      rootContainerInstance, // rootTag\n      updatePayload\n    );\n\n    var component = new ReactNativeFiberHostComponent(tag, viewConfig);\n\n    precacheFiberNode(internalInstanceHandle, tag);\n    updateFiberProps(tag, props);\n\n    // Not sure how to avoid this cast. Flow is okay if the component is defined\n    // in the same file but if it's external it can't see the types.\n    return component;\n  },\n  createTextInstance: function(\n    text,\n    rootContainerInstance,\n    hostContext,\n    internalInstanceHandle\n  ) {\n    var tag = ReactNativeTagHandles.allocateTag();\n\n    UIManager.createView(\n      tag, // reactTag\n      \"RCTRawText\", // viewName\n      rootContainerInstance, // rootTag\n      { text: text }\n    );\n\n    precacheFiberNode(internalInstanceHandle, tag);\n\n    return tag;\n  },\n  finalizeInitialChildren: function(\n    parentInstance,\n    type,\n    props,\n    rootContainerInstance\n  ) {\n    // Don't send a no-op message over the bridge.\n    if (parentInstance._children.length === 0) {\n      return false;\n    }\n\n    // Map from child objects to native tags.\n    // Either way we need to pass a copy of the Array to prevent it from being frozen.\n    var nativeTags = parentInstance._children.map(function(child) {\n      return typeof child === \"number\"\n        ? child // Leaf node (eg text)\n        : child._nativeTag;\n    });\n\n    UIManager.setChildren(\n      parentInstance._nativeTag, // containerTag\n      nativeTags\n    );\n\n    return false;\n  },\n  getRootHostContext: function() {\n    return emptyObject;\n  },\n  getChildHostContext: function() {\n    return emptyObject;\n  },\n  getPublicInstance: function(instance) {\n    return instance;\n  },\n\n  now: now,\n\n  prepareForCommit: function() {\n    // Noop\n  },\n  prepareUpdate: function(\n    instance,\n    type,\n    oldProps,\n    newProps,\n    rootContainerInstance,\n    hostContext\n  ) {\n    return emptyObject;\n  },\n  resetAfterCommit: function() {\n    // Noop\n  },\n\n  scheduleDeferredCallback: scheduleDeferredCallback,\n  cancelDeferredCallback: cancelDeferredCallback,\n\n  shouldDeprioritizeSubtree: function(type, props) {\n    return false;\n  },\n  shouldSetTextContent: function(type, props) {\n    // TODO (bvaughn) Revisit this decision.\n    // Always returning false simplifies the createInstance() implementation,\n    // But creates an additional child Fiber for raw text children.\n    // No additional native views are created though.\n    // It's not clear to me which is better so I'm deferring for now.\n    // More context @ github.com/facebook/react/pull/8560#discussion_r92111303\n    return false;\n  },\n\n  useSyncScheduling: true,\n\n  mutation: {\n    appendChild: function(parentInstance, child) {\n      var childTag = typeof child === \"number\" ? child : child._nativeTag;\n      var children = parentInstance._children;\n      var index = children.indexOf(child);\n\n      if (index >= 0) {\n        children.splice(index, 1);\n        children.push(child);\n\n        UIManager.manageChildren(\n          parentInstance._nativeTag, // containerTag\n          [index], // moveFromIndices\n          [children.length - 1], // moveToIndices\n          [], // addChildReactTags\n          [], // addAtIndices\n          []\n        );\n      } else {\n        children.push(child);\n\n        UIManager.manageChildren(\n          parentInstance._nativeTag, // containerTag\n          [], // moveFromIndices\n          [], // moveToIndices\n          [childTag], // addChildReactTags\n          [children.length - 1], // addAtIndices\n          []\n        );\n      }\n    },\n    appendChildToContainer: function(parentInstance, child) {\n      var childTag = typeof child === \"number\" ? child : child._nativeTag;\n      UIManager.setChildren(\n        parentInstance, // containerTag\n        [childTag]\n      );\n    },\n    commitTextUpdate: function(textInstance, oldText, newText) {\n      UIManager.updateView(\n        textInstance, // reactTag\n        \"RCTRawText\", // viewName\n        { text: newText }\n      );\n    },\n    commitMount: function(instance, type, newProps, internalInstanceHandle) {\n      // Noop\n    },\n    commitUpdate: function(\n      instance,\n      updatePayloadTODO,\n      type,\n      oldProps,\n      newProps,\n      internalInstanceHandle\n    ) {\n      var viewConfig = instance.viewConfig;\n\n      updateFiberProps(instance._nativeTag, newProps);\n\n      var updatePayload = diff(oldProps, newProps, viewConfig.validAttributes);\n\n      // Avoid the overhead of bridge calls if there's no update.\n      // This is an expensive no-op for Android, and causes an unnecessary\n      // view invalidation for certain components (eg RCTTextInput) on iOS.\n      if (updatePayload != null) {\n        UIManager.updateView(\n          instance._nativeTag, // reactTag\n          viewConfig.uiViewClassName, // viewName\n          updatePayload\n        );\n      }\n    },\n    insertBefore: function(parentInstance, child, beforeChild) {\n      var children = parentInstance._children;\n      var index = children.indexOf(child);\n\n      // Move existing child or add new child?\n      if (index >= 0) {\n        children.splice(index, 1);\n        var beforeChildIndex = children.indexOf(beforeChild);\n        children.splice(beforeChildIndex, 0, child);\n\n        UIManager.manageChildren(\n          parentInstance._nativeTag, // containerID\n          [index], // moveFromIndices\n          [beforeChildIndex], // moveToIndices\n          [], // addChildReactTags\n          [], // addAtIndices\n          []\n        );\n      } else {\n        var _beforeChildIndex = children.indexOf(beforeChild);\n        children.splice(_beforeChildIndex, 0, child);\n\n        var childTag = typeof child === \"number\" ? child : child._nativeTag;\n\n        UIManager.manageChildren(\n          parentInstance._nativeTag, // containerID\n          [], // moveFromIndices\n          [], // moveToIndices\n          [childTag], // addChildReactTags\n          [_beforeChildIndex], // addAtIndices\n          []\n        );\n      }\n    },\n    insertInContainerBefore: function(parentInstance, child, beforeChild) {\n      // TODO (bvaughn): Remove this check when...\n      // We create a wrapper object for the container in ReactNative render()\n      // Or we refactor to remove wrapper objects entirely.\n      // For more info on pros/cons see PR #8560 description.\n      invariant(\n        typeof parentInstance !== \"number\",\n        \"Container does not support insertBefore operation\"\n      );\n    },\n    removeChild: function(parentInstance, child) {\n      recursivelyUncacheFiberNode(child);\n      var children = parentInstance._children;\n      var index = children.indexOf(child);\n\n      children.splice(index, 1);\n\n      UIManager.manageChildren(\n        parentInstance._nativeTag, // containerID\n        [], // moveFromIndices\n        [], // moveToIndices\n        [], // addChildReactTags\n        [], // addAtIndices\n        [index]\n      );\n    },\n    removeChildFromContainer: function(parentInstance, child) {\n      recursivelyUncacheFiberNode(child);\n      UIManager.manageChildren(\n        parentInstance, // containerID\n        [], // moveFromIndices\n        [], // moveToIndices\n        [], // addChildReactTags\n        [], // addAtIndices\n        [0]\n      );\n    },\n    resetTextContent: function(instance) {\n      // Noop\n    }\n  }\n});\n\n/**\n * ReactNative vs ReactWeb\n * -----------------------\n * React treats some pieces of data opaquely. This means that the information\n * is first class (it can be passed around), but cannot be inspected. This\n * allows us to build infrastructure that reasons about resources, without\n * making assumptions about the nature of those resources, and this allows that\n * infra to be shared across multiple platforms, where the resources are very\n * different. General infra (such as `ReactMultiChild`) reasons opaquely about\n * the data, but platform specific code (such as `ReactNativeBaseComponent`) can\n * make assumptions about the data.\n *\n *\n * `rootNodeID`, uniquely identifies a position in the generated native view\n * tree. Many layers of composite components (created with `React.createClass`)\n * can all share the same `rootNodeID`.\n *\n * `nodeHandle`: A sufficiently unambiguous way to refer to a lower level\n * resource (dom node, native view etc). The `rootNodeID` is sufficient for web\n * `nodeHandle`s, because the position in a tree is always enough to uniquely\n * identify a DOM node (we never have nodes in some bank outside of the\n * document). The same would be true for `ReactNative`, but we must maintain a\n * mapping that we can send efficiently serializable\n * strings across native boundaries.\n *\n * Opaque name      TodaysWebReact   FutureWebWorkerReact   ReactNative\n * ----------------------------------------------------------------------------\n * nodeHandle       N/A              rootNodeID             tag\n */\n\n// TODO (bvaughn) Rename the findNodeHandle module to something more descriptive\n// eg findInternalHostInstance. This will reduce the likelihood of someone\n// accidentally deep-requiring this version.\nfunction findNodeHandle(componentOrHandle) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.stateNode !== null) {\n      warning(\n        owner.stateNode._warnedAboutRefsInRender,\n        \"%s is accessing findNodeHandle inside its render(). \" +\n          \"render() should be a pure function of props and state. It should \" +\n          \"never access something that requires stale data from the previous \" +\n          \"render, such as refs. Move this logic to componentDidMount and \" +\n          \"componentDidUpdate instead.\",\n        getComponentName(owner) || \"A component\"\n      );\n\n      owner.stateNode._warnedAboutRefsInRender = true;\n    }\n  }\n  if (componentOrHandle == null) {\n    return null;\n  }\n  if (typeof componentOrHandle === \"number\") {\n    // Already a node handle\n    return componentOrHandle;\n  }\n\n  var component = componentOrHandle;\n\n  // TODO (balpert): Wrap iOS native components in a composite wrapper, then\n  // ReactInstanceMap.get here will always succeed for mounted components\n  var internalInstance = get(component);\n  if (internalInstance) {\n    return NativeRenderer.findHostInstance(internalInstance);\n  } else {\n    if (component) {\n      return component;\n    } else {\n      invariant(\n        // Native\n        (typeof component === \"object\" && \"_nativeTag\" in component) ||\n          // Composite\n          (component.render != null && typeof component.render === \"function\"),\n        \"findNodeHandle(...): Argument is not a component \" +\n          \"(type: %s, keys: %s)\",\n        typeof component,\n        Object.keys(component)\n      );\n      invariant(\n        false,\n        \"findNodeHandle(...): Unable to find node handle for unmounted \" +\n          \"component.\"\n      );\n    }\n  }\n}\n\n/**\n * External users of findNodeHandle() expect the host tag number return type.\n * The injected findNodeHandle() strategy returns the instance wrapper though.\n * See NativeMethodsMixin#setNativeProps for more info on why this is done.\n */\nfunction findNumericNodeHandleFiber(componentOrHandle) {\n  var instance = findNodeHandle(componentOrHandle);\n  if (instance == null || typeof instance === \"number\") {\n    return instance;\n  }\n  return instance._nativeTag;\n}\n\n// Modules provided by RN:\n/**\n * `NativeMethodsMixin` provides methods to access the underlying native\n * component directly. This can be useful in cases when you want to focus\n * a view or measure its on-screen dimensions, for example.\n *\n * The methods described here are available on most of the default components\n * provided by React Native. Note, however, that they are *not* available on\n * composite components that aren't directly backed by a native view. This will\n * generally include most components that you define in your own app. For more\n * information, see [Direct\n * Manipulation](docs/direct-manipulation.html).\n *\n * Note the Flow $Exact<> syntax is required to support mixins.\n * React createClass mixins can only be used with exact types.\n */\nvar NativeMethodsMixin = {\n  /**\n   * Determines the location on screen, width, and height of the given view and\n   * returns the values via an async callback. If successful, the callback will\n   * be called with the following arguments:\n   *\n   *  - x\n   *  - y\n   *  - width\n   *  - height\n   *  - pageX\n   *  - pageY\n   *\n   * Note that these measurements are not available until after the rendering\n   * has been completed in native. If you need the measurements as soon as\n   * possible, consider using the [`onLayout`\n   * prop](docs/view.html#onlayout) instead.\n   */\n  measure: function(callback) {\n    UIManager.measure(\n      findNumericNodeHandleFiber(this),\n      mountSafeCallback(this, callback)\n    );\n  },\n\n  /**\n   * Determines the location of the given view in the window and returns the\n   * values via an async callback. If the React root view is embedded in\n   * another native view, this will give you the absolute coordinates. If\n   * successful, the callback will be called with the following\n   * arguments:\n   *\n   *  - x\n   *  - y\n   *  - width\n   *  - height\n   *\n   * Note that these measurements are not available until after the rendering\n   * has been completed in native.\n   */\n  measureInWindow: function(callback) {\n    UIManager.measureInWindow(\n      findNumericNodeHandleFiber(this),\n      mountSafeCallback(this, callback)\n    );\n  },\n\n  /**\n   * Like [`measure()`](#measure), but measures the view relative an ancestor,\n   * specified as `relativeToNativeNode`. This means that the returned x, y\n   * are relative to the origin x, y of the ancestor view.\n   *\n   * As always, to obtain a native node handle for a component, you can use\n   * `findNumericNodeHandle(component)`.\n   */\n  measureLayout: function(\n    relativeToNativeNode,\n    onSuccess,\n    onFail /* currently unused */\n  ) {\n    UIManager.measureLayout(\n      findNumericNodeHandleFiber(this),\n      relativeToNativeNode,\n      mountSafeCallback(this, onFail),\n      mountSafeCallback(this, onSuccess)\n    );\n  },\n\n  /**\n   * This function sends props straight to native. They will not participate in\n   * future diff process - this means that if you do not include them in the\n   * next render, they will remain active (see [Direct\n   * Manipulation](docs/direct-manipulation.html)).\n   */\n  setNativeProps: function(nativeProps) {\n    // Class components don't have viewConfig -> validateAttributes.\n    // Nor does it make sense to set native props on a non-native component.\n    // Instead, find the nearest host component and set props on it.\n    // Use findNodeHandle() rather than findNumericNodeHandle() because\n    // We want the instance/wrapper (not the native tag).\n    var maybeInstance = void 0;\n\n    // Fiber errors if findNodeHandle is called for an umounted component.\n    // Tests using ReactTestRenderer will trigger this case indirectly.\n    // Mimicking stack behavior, we should silently ignore this case.\n    // TODO Fix ReactTestRenderer so we can remove this try/catch.\n    try {\n      maybeInstance = findNodeHandle(this);\n    } catch (error) {}\n\n    // If there is no host component beneath this we should fail silently.\n    // This is not an error; it could mean a class component rendered null.\n    if (maybeInstance == null) {\n      return;\n    }\n\n    var viewConfig = maybeInstance.viewConfig;\n\n    {\n      warnForStyleProps(nativeProps, viewConfig.validAttributes);\n    }\n\n    var updatePayload = create(nativeProps, viewConfig.validAttributes);\n\n    // Avoid the overhead of bridge calls if there's no update.\n    // This is an expensive no-op for Android, and causes an unnecessary\n    // view invalidation for certain components (eg RCTTextInput) on iOS.\n    if (updatePayload != null) {\n      UIManager.updateView(\n        maybeInstance._nativeTag,\n        viewConfig.uiViewClassName,\n        updatePayload\n      );\n    }\n  },\n\n  /**\n   * Requests focus for the given input or view. The exact behavior triggered\n   * will depend on the platform and type of view.\n   */\n  focus: function() {\n    TextInputState.focusTextInput(findNumericNodeHandleFiber(this));\n  },\n\n  /**\n   * Removes focus from an input or view. This is the opposite of `focus()`.\n   */\n  blur: function() {\n    TextInputState.blurTextInput(findNumericNodeHandleFiber(this));\n  }\n};\n\n{\n  // hide this from Flow since we can't define these properties outside of\n  // true without actually implementing them (setting them to undefined\n  // isn't allowed by ReactClass)\n  var NativeMethodsMixin_DEV = NativeMethodsMixin;\n  invariant(\n    !NativeMethodsMixin_DEV.componentWillMount &&\n      !NativeMethodsMixin_DEV.componentWillReceiveProps,\n    \"Do not override existing functions.\"\n  );\n  NativeMethodsMixin_DEV.componentWillMount = function() {\n    throwOnStylesProp(this, this.props);\n  };\n  NativeMethodsMixin_DEV.componentWillReceiveProps = function(newProps) {\n    throwOnStylesProp(this, newProps);\n  };\n}\n\nfunction _classCallCheck$2(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\n      \"this hasn't been initialised - super() hasn't been called\"\n    );\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\")\n    ? call\n    : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\n      \"Super expression must either be null or a function, not \" +\n        typeof superClass\n    );\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass)\n    Object.setPrototypeOf\n      ? Object.setPrototypeOf(subClass, superClass)\n      : (subClass.__proto__ = superClass);\n}\n\n// Modules provided by RN:\n/**\n * Superclass that provides methods to access the underlying native component.\n * This can be useful when you want to focus a view or measure its dimensions.\n *\n * Methods implemented by this class are available on most default components\n * provided by React Native. However, they are *not* available on composite\n * components that are not directly backed by a native view. For more\n * information, see [Direct Manipulation](docs/direct-manipulation.html).\n *\n * @abstract\n */\n\nvar ReactNativeComponent = (function(_React$Component) {\n  _inherits(ReactNativeComponent, _React$Component);\n\n  function ReactNativeComponent() {\n    _classCallCheck$2(this, ReactNativeComponent);\n\n    return _possibleConstructorReturn(\n      this,\n      _React$Component.apply(this, arguments)\n    );\n  }\n\n  /**\n   * Removes focus. This is the opposite of `focus()`.\n   */\n  ReactNativeComponent.prototype.blur = function blur() {\n    TextInputState.blurTextInput(findNumericNodeHandleFiber(this));\n  };\n\n  /**\n   * Requests focus. The exact behavior depends on the platform and view.\n   */\n\n  ReactNativeComponent.prototype.focus = function focus() {\n    TextInputState.focusTextInput(findNumericNodeHandleFiber(this));\n  };\n\n  /**\n   * Measures the on-screen location and dimensions. If successful, the callback\n   * will be called asynchronously with the following arguments:\n   *\n   *  - x\n   *  - y\n   *  - width\n   *  - height\n   *  - pageX\n   *  - pageY\n   *\n   * These values are not available until after natives rendering completes. If\n   * you need the measurements as soon as possible, consider using the\n   * [`onLayout` prop](docs/view.html#onlayout) instead.\n   */\n\n  ReactNativeComponent.prototype.measure = function measure(callback) {\n    UIManager.measure(\n      findNumericNodeHandleFiber(this),\n      mountSafeCallback(this, callback)\n    );\n  };\n\n  /**\n   * Measures the on-screen location and dimensions. Even if the React Native\n   * root view is embedded within another native view, this method will give you\n   * the absolute coordinates measured from the window. If successful, the\n   * callback will be called asynchronously with the following arguments:\n   *\n   *  - x\n   *  - y\n   *  - width\n   *  - height\n   *\n   * These values are not available until after natives rendering completes.\n   */\n\n  ReactNativeComponent.prototype.measureInWindow = function measureInWindow(\n    callback\n  ) {\n    UIManager.measureInWindow(\n      findNumericNodeHandleFiber(this),\n      mountSafeCallback(this, callback)\n    );\n  };\n\n  /**\n   * Similar to [`measure()`](#measure), but the resulting location will be\n   * relative to the supplied ancestor's location.\n   *\n   * Obtain a native node handle with `ReactNative.findNodeHandle(component)`.\n   */\n\n  ReactNativeComponent.prototype.measureLayout = function measureLayout(\n    relativeToNativeNode,\n    onSuccess,\n    onFail /* currently unused */\n  ) {\n    UIManager.measureLayout(\n      findNumericNodeHandleFiber(this),\n      relativeToNativeNode,\n      mountSafeCallback(this, onFail),\n      mountSafeCallback(this, onSuccess)\n    );\n  };\n\n  /**\n   * This function sends props straight to native. They will not participate in\n   * future diff process - this means that if you do not include them in the\n   * next render, they will remain active (see [Direct\n   * Manipulation](docs/direct-manipulation.html)).\n   */\n\n  ReactNativeComponent.prototype.setNativeProps = function setNativeProps(\n    nativeProps\n  ) {\n    // Class components don't have viewConfig -> validateAttributes.\n    // Nor does it make sense to set native props on a non-native component.\n    // Instead, find the nearest host component and set props on it.\n    // Use findNodeHandle() rather than ReactNative.findNodeHandle() because\n    // We want the instance/wrapper (not the native tag).\n    var maybeInstance = void 0;\n\n    // Fiber errors if findNodeHandle is called for an umounted component.\n    // Tests using ReactTestRenderer will trigger this case indirectly.\n    // Mimicking stack behavior, we should silently ignore this case.\n    // TODO Fix ReactTestRenderer so we can remove this try/catch.\n    try {\n      maybeInstance = findNodeHandle(this);\n    } catch (error) {}\n\n    // If there is no host component beneath this we should fail silently.\n    // This is not an error; it could mean a class component rendered null.\n    if (maybeInstance == null) {\n      return;\n    }\n\n    var viewConfig = maybeInstance.viewConfig;\n\n    var updatePayload = create(nativeProps, viewConfig.validAttributes);\n\n    // Avoid the overhead of bridge calls if there's no update.\n    // This is an expensive no-op for Android, and causes an unnecessary\n    // view invalidation for certain components (eg RCTTextInput) on iOS.\n    if (updatePayload != null) {\n      UIManager.updateView(\n        maybeInstance._nativeTag,\n        viewConfig.uiViewClassName,\n        updatePayload\n      );\n    }\n  };\n\n  return ReactNativeComponent;\n})(React.Component);\n\n// Module provided by RN:\nvar getInspectorDataForViewTag = void 0;\n\n{\n  var traverseOwnerTreeUp = function(hierarchy, instance) {\n    if (instance) {\n      hierarchy.unshift(instance);\n      traverseOwnerTreeUp(hierarchy, instance._debugOwner);\n    }\n  };\n\n  var getOwnerHierarchy = function(instance) {\n    var hierarchy = [];\n    traverseOwnerTreeUp(hierarchy, instance);\n    return hierarchy;\n  };\n\n  var lastNonHostInstance = function(hierarchy) {\n    for (var i = hierarchy.length - 1; i > 1; i--) {\n      var instance = hierarchy[i];\n\n      if (instance.tag !== HostComponent) {\n        return instance;\n      }\n    }\n    return hierarchy[0];\n  };\n\n  var getHostProps = function(fiber) {\n    var host = findCurrentHostFiber(fiber);\n    if (host) {\n      return host.memoizedProps || emptyObject;\n    }\n    return emptyObject;\n  };\n\n  var getHostNode = function(fiber, findNodeHandle) {\n    var hostNode = void 0;\n    // look for children first for the hostNode\n    // as composite fibers do not have a hostNode\n    while (fiber) {\n      if (fiber.stateNode !== null && fiber.tag === HostComponent) {\n        hostNode = findNodeHandle(fiber.stateNode);\n      }\n      if (hostNode) {\n        return hostNode;\n      }\n      fiber = fiber.child;\n    }\n    return null;\n  };\n\n  var createHierarchy = function(fiberHierarchy) {\n    return fiberHierarchy.map(function(fiber) {\n      return {\n        name: getComponentName(fiber),\n        getInspectorData: function(findNodeHandle) {\n          return {\n            measure: function(callback) {\n              return UIManager.measure(\n                getHostNode(fiber, findNodeHandle),\n                callback\n              );\n            },\n            props: getHostProps(fiber),\n            source: fiber._debugSource\n          };\n        }\n      };\n    });\n  };\n\n  getInspectorDataForViewTag = function(viewTag) {\n    var closestInstance = getInstanceFromTag(viewTag);\n\n    // Handle case where user clicks outside of ReactNative\n    if (!closestInstance) {\n      return {\n        hierarchy: [],\n        props: emptyObject,\n        selection: null,\n        source: null\n      };\n    }\n\n    var fiber = findCurrentFiberUsingSlowPath(closestInstance);\n    var fiberHierarchy = getOwnerHierarchy(fiber);\n    var instance = lastNonHostInstance(fiberHierarchy);\n    var hierarchy = createHierarchy(fiberHierarchy);\n    var props = getHostProps(instance);\n    var source = instance._debugSource;\n    var selection = fiberHierarchy.indexOf(instance);\n\n    return {\n      hierarchy: hierarchy,\n      props: props,\n      selection: selection,\n      source: source\n    };\n  };\n}\n\n/**\n * Creates a renderable ReactNative host component.\n * Use this method for view configs that are loaded from UIManager.\n * Use createReactNativeComponentClass() for view configs defined within JavaScript.\n *\n * @param {string} config iOS View configuration.\n * @private\n */\nvar createReactNativeComponentClass = function(name, callback) {\n  return register(name, callback);\n};\n\n// Module provided by RN:\n/**\n * Capture an image of the screen, window or an individual view. The image\n * will be stored in a temporary file that will only exist for as long as the\n * app is running.\n *\n * The `view` argument can be the literal string `window` if you want to\n * capture the entire window, or it can be a reference to a specific\n * React Native component.\n *\n * The `options` argument may include:\n * - width/height (number) - the width and height of the image to capture.\n * - format (string) - either 'png' or 'jpeg'. Defaults to 'png'.\n * - quality (number) - the quality when using jpeg. 0.0 - 1.0 (default).\n *\n * Returns a Promise.\n * @platform ios\n */\nfunction takeSnapshot(view, options) {\n  if (typeof view !== \"number\" && view !== \"window\") {\n    view = findNumericNodeHandleFiber(view) || \"window\";\n  }\n\n  // Call the hidden '__takeSnapshot' method; the main one throws an error to\n  // prevent accidental backwards-incompatible usage.\n  return UIManager.__takeSnapshot(view, options);\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\n// Module provided by RN:\ninjection$2.injectFiberBatchedUpdates(NativeRenderer.batchedUpdates);\n\nvar roots = new Map();\n\n// Intercept lifecycle errors and ensure they are shown with the correct stack\n// trace within the native redbox component.\ninjection$4.injectDialog(showDialog$1);\n\nvar ReactNativeRenderer = {\n  NativeComponent: ReactNativeComponent,\n\n  findNodeHandle: findNumericNodeHandleFiber,\n\n  render: function(element, containerTag, callback) {\n    var root = roots.get(containerTag);\n\n    if (!root) {\n      // TODO (bvaughn): If we decide to keep the wrapper component,\n      // We could create a wrapper for containerTag as well to reduce special casing.\n      root = NativeRenderer.createContainer(containerTag, false);\n      roots.set(containerTag, root);\n    }\n    NativeRenderer.updateContainer(element, root, null, callback);\n\n    return NativeRenderer.getPublicRootInstance(root);\n  },\n  unmountComponentAtNode: function(containerTag) {\n    var root = roots.get(containerTag);\n    if (root) {\n      // TODO: Is it safe to reset this now or should I wait since this unmount could be deferred?\n      NativeRenderer.updateContainer(null, root, null, function() {\n        roots[\"delete\"](containerTag);\n      });\n    }\n  },\n  unmountComponentAtNodeAndRemoveContainer: function(containerTag) {\n    ReactNativeRenderer.unmountComponentAtNode(containerTag);\n\n    // Call back into native to remove all of the subviews from this container\n    UIManager.removeRootView(containerTag);\n  },\n  createPortal: function(children, containerTag) {\n    var key =\n      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    return createPortal(children, containerTag, null, key);\n  },\n\n  unstable_batchedUpdates: batchedUpdates,\n\n  flushSync: NativeRenderer.flushSync,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    // Used as a mixin in many createClass-based components\n    NativeMethodsMixin: NativeMethodsMixin,\n    // Used by react-native-github/Libraries/ components\n    ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin, // requireNativeComponent\n    ReactGlobalSharedState: ReactGlobalSharedState, // Systrace\n    ReactNativeComponentTree: ReactNativeComponentTree, // InspectorUtils, ScrollResponder\n    ReactNativePropRegistry: ReactNativePropRegistry, // flattenStyle, Stylesheet\n    TouchHistoryMath: TouchHistoryMath, // PanResponder\n    createReactNativeComponentClass: createReactNativeComponentClass, // RCTText, RCTView, ReactNativeART\n    takeSnapshot: takeSnapshot\n  }\n};\n\n{\n  // $FlowFixMe\n  Object.assign(\n    ReactNativeRenderer.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,\n    {\n      // TODO: none of these work since Fiber. Remove these dependencies.\n      // Used by RCTRenderingPerf, Systrace:\n      ReactDebugTool: {\n        addHook: function() {},\n        removeHook: function() {}\n      },\n      // Used by ReactPerfStallHandler, RCTRenderingPerf:\n      ReactPerf: {\n        start: function() {},\n        stop: function() {},\n        printInclusive: function() {},\n        printWasted: function() {}\n      }\n    }\n  );\n}\n\nNativeRenderer.injectIntoDevTools({\n  findFiberByHostInstance: getInstanceFromTag,\n  getInspectorDataForViewTag: getInspectorDataForViewTag,\n  bundleType: 1,\n  version: ReactVersion,\n  rendererPackageName: \"react-native-renderer\"\n});\n\nvar ReactNativeRenderer$2 = Object.freeze({\n  default: ReactNativeRenderer\n});\n\nvar ReactNativeRenderer$3 =\n  (ReactNativeRenderer$2 && ReactNativeRenderer) || ReactNativeRenderer$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactNativeRenderer = ReactNativeRenderer$3[\"default\"]\n  ? ReactNativeRenderer$3[\"default\"]\n  : ReactNativeRenderer$3;\n\nmodule.exports = reactNativeRenderer;\n\n  })();\n}\n"]}